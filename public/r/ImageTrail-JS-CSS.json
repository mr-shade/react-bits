{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ImageTrail-JS-CSS",
  "type": "registry:block",
  "title": "ImageTrail",
  "description": "Cursor-based image trail with several built-in variants.",
  "dependencies": [
    "gsap"
  ],
  "files": [
    {
      "path": "public/default/src/content/Animations/ImageTrail/ImageTrail.jsx",
      "content": "import { useRef, useEffect } from 'react';\r\nimport { gsap } from 'gsap';\r\n\r\nimport './ImageTrail.css';\r\n\r\nfunction lerp(a, b, n) {\r\n  return (1 - n) * a + n * b;\r\n}\r\n\r\nfunction getLocalPointerPos(e, rect) {\r\n  let clientX = 0,\r\n    clientY = 0;\r\n  if (e.touches && e.touches.length > 0) {\r\n    clientX = e.touches[0].clientX;\r\n    clientY = e.touches[0].clientY;\r\n  } else {\r\n    clientX = e.clientX;\r\n    clientY = e.clientY;\r\n  }\r\n  return {\r\n    x: clientX - rect.left,\r\n    y: clientY - rect.top\r\n  };\r\n}\r\nfunction getMouseDistance(p1, p2) {\r\n  const dx = p1.x - p2.x;\r\n  const dy = p1.y - p2.y;\r\n  return Math.hypot(dx, dy);\r\n}\r\n\r\nclass ImageItem {\r\n  DOM = { el: null, inner: null };\r\n  defaultStyle = { scale: 1, x: 0, y: 0, opacity: 0 };\r\n  rect = null;\r\n\r\n  constructor(DOM_el) {\r\n    this.DOM.el = DOM_el;\r\n    this.DOM.inner = this.DOM.el.querySelector('.content__img-inner');\r\n    this.getRect();\r\n    this.initEvents();\r\n  }\r\n  initEvents() {\r\n    this.resize = () => {\r\n      gsap.set(this.DOM.el, this.defaultStyle);\r\n      this.getRect();\r\n    };\r\n    window.addEventListener('resize', this.resize);\r\n  }\r\n  getRect() {\r\n    this.rect = this.DOM.el.getBoundingClientRect();\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant1 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...this.DOM.el.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = this.container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = this.container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n\r\n      requestAnimationFrame(() => this.render());\r\n\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) {\r\n      this.zIndexVal = 1;\r\n    }\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n\r\n    gsap.killTweensOf(img.DOM.el);\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          scale: 1,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power3',\r\n          opacity: 0,\r\n          scale: 0.2\r\n        },\r\n        0.4\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) {\r\n      this.isIdle = true;\r\n    }\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant2 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n\r\n      requestAnimationFrame(() => this.render());\r\n\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) {\r\n      this.zIndexVal = 1;\r\n    }\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n\r\n    gsap.killTweensOf(img.DOM.el);\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          scale: 0,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1,\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      )\r\n      .fromTo(\r\n        img.DOM.inner,\r\n        {\r\n          scale: 2.8,\r\n          filter: 'brightness(250%)'\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1,\r\n          filter: 'brightness(100%)'\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power2',\r\n          opacity: 0,\r\n          scale: 0.2\r\n        },\r\n        0.45\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) this.isIdle = true;\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant3 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) {\r\n      this.zIndexVal = 1;\r\n    }\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n    gsap.killTweensOf(img.DOM.el);\r\n\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          scale: 0,\r\n          zIndex: this.zIndexVal,\r\n          xPercent: 0,\r\n          yPercent: 0,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1,\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      )\r\n      .fromTo(\r\n        img.DOM.inner,\r\n        {\r\n          scale: 1.2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.6,\r\n          ease: 'power2',\r\n          opacity: 0,\r\n          scale: 0.2,\r\n          xPercent: () => gsap.utils.random(-30, 30),\r\n          yPercent: -200\r\n        },\r\n        0.6\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) this.isIdle = true;\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant4 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n\r\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n    gsap.killTweensOf(img.DOM.el);\r\n\r\n    let dx = this.mousePos.x - this.cacheMousePos.x;\r\n    let dy = this.mousePos.y - this.cacheMousePos.y;\r\n    let distance = Math.sqrt(dx * dx + dy * dy);\r\n    if (distance !== 0) {\r\n      dx /= distance;\r\n      dy /= distance;\r\n    }\r\n    dx *= distance / 100;\r\n    dy *= distance / 100;\r\n\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          scale: 0,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1,\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      )\r\n      .fromTo(\r\n        img.DOM.inner,\r\n        {\r\n          scale: 2,\r\n          filter: `brightness(${Math.max((400 * distance) / 100, 100)}%) contrast(${Math.max((400 * distance) / 100, 100)}%)`\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power1',\r\n          scale: 1,\r\n          filter: 'brightness(100%) contrast(100%)'\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power3',\r\n          opacity: 0\r\n        },\r\n        0.4\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 1.5,\r\n          ease: 'power4',\r\n          x: `+=${dx * 110}`,\r\n          y: `+=${dy * 110}`\r\n        },\r\n        0.05\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) this.isIdle = true;\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant5 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n    this.lastAngle = 0;\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    let dx = this.mousePos.x - this.cacheMousePos.x;\r\n    let dy = this.mousePos.y - this.cacheMousePos.y;\r\n    let angle = Math.atan2(dy, dx) * (180 / Math.PI);\r\n    if (angle < 0) angle += 360;\r\n    if (angle > 90 && angle <= 270) angle += 180;\r\n    const isMovingClockwise = angle >= this.lastAngle;\r\n    this.lastAngle = angle;\r\n    let startAngle = isMovingClockwise ? angle - 10 : angle + 10;\r\n    let distance = Math.sqrt(dx * dx + dy * dy);\r\n    if (distance !== 0) {\r\n      dx /= distance;\r\n      dy /= distance;\r\n    }\r\n    dx *= distance / 150;\r\n    dy *= distance / 150;\r\n\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n    gsap.killTweensOf(img.DOM.el);\r\n\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          filter: 'brightness(80%)',\r\n          scale: 0.1,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2,\r\n          rotation: startAngle\r\n        },\r\n        {\r\n          duration: 1,\r\n          ease: 'power2',\r\n          scale: 1,\r\n          filter: 'brightness(100%)',\r\n          x: this.mousePos.x - img.rect.width / 2 + dx * 70,\r\n          y: this.mousePos.y - img.rect.height / 2 + dy * 70,\r\n          rotation: this.lastAngle\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'expo',\r\n          opacity: 0\r\n        },\r\n        0.5\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 1.5,\r\n          ease: 'power4',\r\n          x: `+=${dx * 120}`,\r\n          y: `+=${dy * 120}`\r\n        },\r\n        0.05\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) this.isIdle = true;\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant6 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.3);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.3);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) {\r\n      this.zIndexVal = 1;\r\n    }\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  mapSpeedToSize(speed, minSize, maxSize) {\r\n    const maxSpeed = 200;\r\n    return minSize + (maxSize - minSize) * Math.min(speed / maxSpeed, 1);\r\n  }\r\n  mapSpeedToBrightness(speed, minB, maxB) {\r\n    const maxSpeed = 70;\r\n    return minB + (maxB - minB) * Math.min(speed / maxSpeed, 1);\r\n  }\r\n  mapSpeedToBlur(speed, minBlur, maxBlur) {\r\n    const maxSpeed = 90;\r\n    return minBlur + (maxBlur - minBlur) * Math.min(speed / maxSpeed, 1);\r\n  }\r\n  mapSpeedToGrayscale(speed, minG, maxG) {\r\n    const maxSpeed = 90;\r\n    return minG + (maxG - minG) * Math.min(speed / maxSpeed, 1);\r\n  }\r\n\r\n  showNextImage() {\r\n    let dx = this.mousePos.x - this.cacheMousePos.x;\r\n    let dy = this.mousePos.y - this.cacheMousePos.y;\r\n    let speed = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n\r\n    let scaleFactor = this.mapSpeedToSize(speed, 0.3, 2);\r\n    let brightnessValue = this.mapSpeedToBrightness(speed, 0, 1.3);\r\n    let blurValue = this.mapSpeedToBlur(speed, 20, 0);\r\n    let grayscaleValue = this.mapSpeedToGrayscale(speed, 600, 0);\r\n\r\n    gsap.killTweensOf(img.DOM.el);\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          scale: 0,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.8,\r\n          ease: 'power3',\r\n          scale: scaleFactor,\r\n          filter: `grayscale(${grayscaleValue * 100}%) brightness(${brightnessValue * 100}%) blur(${blurValue}px)`,\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      )\r\n      .fromTo(\r\n        img.DOM.inner,\r\n        {\r\n          scale: 2\r\n        },\r\n        {\r\n          duration: 0.8,\r\n          ease: 'power3',\r\n          scale: 1\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power3.in',\r\n          opacity: 0,\r\n          scale: 0.2\r\n        },\r\n        0.45\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) {\r\n      this.isIdle = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getNewPosition(position, offset, arr) {\r\n  const realOffset = Math.abs(offset) % arr.length;\r\n  if (position - realOffset >= 0) {\r\n    return position - realOffset;\r\n  } else {\r\n    return arr.length - (realOffset - position);\r\n  }\r\n}\r\nclass ImageTrailVariant7 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    this.visibleImagesCount = 0;\r\n    this.visibleImagesTotal = 9;\r\n    this.visibleImagesTotal = Math.min(this.visibleImagesTotal, this.imagesTotal - 1);\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.3);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.3);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) this.zIndexVal = 1;\r\n\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n    ++this.visibleImagesCount;\r\n\r\n    gsap.killTweensOf(img.DOM.el);\r\n    const scaleValue = gsap.utils.random(0.5, 1.6);\r\n\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          scale: scaleValue - Math.max(gsap.utils.random(0.2, 0.6), 0),\r\n          rotationZ: 0,\r\n          opacity: 1,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2\r\n        },\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power3',\r\n          scale: scaleValue,\r\n          rotationZ: gsap.utils.random(-3, 3),\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2\r\n        },\r\n        0\r\n      );\r\n\r\n    if (this.visibleImagesCount >= this.visibleImagesTotal) {\r\n      const lastInQueue = getNewPosition(this.imgPosition, this.visibleImagesTotal, this.images);\r\n      const oldImg = this.images[lastInQueue];\r\n      gsap.to(oldImg.DOM.el, {\r\n        duration: 0.4,\r\n        ease: 'power4',\r\n        opacity: 0,\r\n        scale: 1.3,\r\n        onComplete: () => {\r\n          if (this.activeImagesCount === 0) {\r\n            this.isIdle = true;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n  }\r\n}\r\n\r\nclass ImageTrailVariant8 {\r\n  constructor(container) {\r\n    this.container = container;\r\n    this.DOM = { el: container };\r\n    this.images = [...container.querySelectorAll('.content__img')].map(img => new ImageItem(img));\r\n    this.imagesTotal = this.images.length;\r\n    this.imgPosition = 0;\r\n    this.zIndexVal = 1;\r\n    this.activeImagesCount = 0;\r\n    this.isIdle = true;\r\n    this.threshold = 80;\r\n\r\n    this.mousePos = { x: 0, y: 0 };\r\n    this.lastMousePos = { x: 0, y: 0 };\r\n    this.cacheMousePos = { x: 0, y: 0 };\r\n\r\n    this.rotation = { x: 0, y: 0 };\r\n    this.cachedRotation = { x: 0, y: 0 };\r\n    this.zValue = 0;\r\n    this.cachedZValue = 0;\r\n\r\n    const handlePointerMove = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n    };\r\n    container.addEventListener('mousemove', handlePointerMove);\r\n    container.addEventListener('touchmove', handlePointerMove);\r\n\r\n    const initRender = ev => {\r\n      const rect = container.getBoundingClientRect();\r\n      this.mousePos = getLocalPointerPos(ev, rect);\r\n      this.cacheMousePos = { ...this.mousePos };\r\n      requestAnimationFrame(() => this.render());\r\n      container.removeEventListener('mousemove', initRender);\r\n      container.removeEventListener('touchmove', initRender);\r\n    };\r\n    container.addEventListener('mousemove', initRender);\r\n    container.addEventListener('touchmove', initRender);\r\n  }\r\n\r\n  render() {\r\n    let distance = getMouseDistance(this.mousePos, this.lastMousePos);\r\n    this.cacheMousePos.x = lerp(this.cacheMousePos.x, this.mousePos.x, 0.1);\r\n    this.cacheMousePos.y = lerp(this.cacheMousePos.y, this.mousePos.y, 0.1);\r\n\r\n    if (distance > this.threshold) {\r\n      this.showNextImage();\r\n      this.lastMousePos = { ...this.mousePos };\r\n    }\r\n    if (this.isIdle && this.zIndexVal !== 1) {\r\n      this.zIndexVal = 1;\r\n    }\r\n    requestAnimationFrame(() => this.render());\r\n  }\r\n\r\n  showNextImage() {\r\n    const rect = this.container.getBoundingClientRect();\r\n    const centerX = rect.width / 2;\r\n    const centerY = rect.height / 2;\r\n    const relX = this.mousePos.x - centerX;\r\n    const relY = this.mousePos.y - centerY;\r\n\r\n    this.rotation.x = -(relY / centerY) * 30;\r\n    this.rotation.y = (relX / centerX) * 30;\r\n    this.cachedRotation = { ...this.rotation };\r\n\r\n    const distanceFromCenter = Math.sqrt(relX * relX + relY * relY);\r\n    const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);\r\n    const proportion = distanceFromCenter / maxDistance;\r\n    this.zValue = proportion * 1200 - 600;\r\n    this.cachedZValue = this.zValue;\r\n    const normalizedZ = (this.zValue + 600) / 1200;\r\n    const brightness = 0.2 + normalizedZ * 2.3;\r\n\r\n    ++this.zIndexVal;\r\n    this.imgPosition = this.imgPosition < this.imagesTotal - 1 ? this.imgPosition + 1 : 0;\r\n    const img = this.images[this.imgPosition];\r\n    gsap.killTweensOf(img.DOM.el);\r\n\r\n    gsap\r\n      .timeline({\r\n        onStart: () => this.onImageActivated(),\r\n        onComplete: () => this.onImageDeactivated()\r\n      })\r\n      .set(this.DOM.el, { perspective: 1000 }, 0)\r\n      .fromTo(\r\n        img.DOM.el,\r\n        {\r\n          opacity: 1,\r\n          z: 0,\r\n          scale: 1 + this.cachedZValue / 1000,\r\n          zIndex: this.zIndexVal,\r\n          x: this.cacheMousePos.x - img.rect.width / 2,\r\n          y: this.cacheMousePos.y - img.rect.height / 2,\r\n          rotationX: this.cachedRotation.x,\r\n          rotationY: this.cachedRotation.y,\r\n          filter: `brightness(${brightness})`\r\n        },\r\n        {\r\n          duration: 1,\r\n          ease: 'expo',\r\n          scale: 1 + this.zValue / 1000,\r\n          x: this.mousePos.x - img.rect.width / 2,\r\n          y: this.mousePos.y - img.rect.height / 2,\r\n          rotationX: this.rotation.x,\r\n          rotationY: this.rotation.y\r\n        },\r\n        0\r\n      )\r\n      .to(\r\n        img.DOM.el,\r\n        {\r\n          duration: 0.4,\r\n          ease: 'power2',\r\n          opacity: 0,\r\n          z: -800\r\n        },\r\n        0.3\r\n      );\r\n  }\r\n\r\n  onImageActivated() {\r\n    this.activeImagesCount++;\r\n    this.isIdle = false;\r\n  }\r\n  onImageDeactivated() {\r\n    this.activeImagesCount--;\r\n    if (this.activeImagesCount === 0) this.isIdle = true;\r\n  }\r\n}\r\n\r\nconst variantMap = {\r\n  1: ImageTrailVariant1,\r\n  2: ImageTrailVariant2,\r\n  3: ImageTrailVariant3,\r\n  4: ImageTrailVariant4,\r\n  5: ImageTrailVariant5,\r\n  6: ImageTrailVariant6,\r\n  7: ImageTrailVariant7,\r\n  8: ImageTrailVariant8\r\n};\r\n\r\nexport default function ImageTrail({ items = [], variant = 1 }) {\r\n  const containerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const Cls = variantMap[variant] || variantMap[1];\r\n    new Cls(containerRef.current);\r\n  }, [variant, items]);\r\n\r\n  return (\r\n    <div className=\"content\" ref={containerRef}>\r\n      {items.map((url, i) => (\r\n        <div className=\"content__img\" key={i}>\r\n          <div className=\"content__img-inner\" style={{ backgroundImage: `url(${url})` }} />\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Animations/ImageTrail/ImageTrail.css",
      "content": ".content {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n  z-index: 100;\r\n  border-radius: 8px;\r\n  background: transparent;\r\n  overflow: visible;\r\n}\r\n\r\n.content__img {\r\n  width: 190px;\r\n  aspect-ratio: 1.1;\r\n  border-radius: 15px;\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  opacity: 0;\r\n  overflow: hidden;\r\n  will-change: transform, filter;\r\n}\r\n\r\n.content__img-inner {\r\n  background-position: 50% 50%;\r\n  width: calc(100% + 20px);\r\n  height: calc(100% + 20px);\r\n  background-size: cover;\r\n  position: absolute;\r\n  top: calc(-1 * 20px / 2);\r\n  left: calc(-1 * 20px / 2);\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}