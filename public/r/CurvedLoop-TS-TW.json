{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "CurvedLoop-TS-TW",
  "type": "registry:block",
  "title": "CurvedLoop",
  "description": "Flowing looping text path along a customizable curve with drag interaction.",
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/TextAnimations/CurvedLoop/CurvedLoop.tsx",
      "content": "import { useRef, useEffect, useState, useMemo, useId, FC, PointerEvent } from 'react';\r\n\r\ninterface CurvedLoopProps {\r\n  marqueeText?: string;\r\n  speed?: number;\r\n  className?: string;\r\n  curveAmount?: number;\r\n  direction?: 'left' | 'right';\r\n  interactive?: boolean;\r\n}\r\n\r\nconst CurvedLoop: FC<CurvedLoopProps> = ({\r\n  marqueeText = '',\r\n  speed = 2,\r\n  className,\r\n  curveAmount = 400,\r\n  direction = 'left',\r\n  interactive = true\r\n}) => {\r\n  const text = useMemo(() => {\r\n    const hasTrailing = /\\s|\\u00A0$/.test(marqueeText);\r\n    return (hasTrailing ? marqueeText.replace(/\\s+$/, '') : marqueeText) + '\\u00A0';\r\n  }, [marqueeText]);\r\n\r\n  const measureRef = useRef<SVGTextElement | null>(null);\r\n  const textPathRef = useRef<SVGTextPathElement | null>(null);\r\n  const pathRef = useRef<SVGPathElement | null>(null);\r\n  const [spacing, setSpacing] = useState(0);\r\n  const [offset, setOffset] = useState(0);\r\n  const uid = useId();\r\n  const pathId = `curve-${uid}`;\r\n  const pathD = `M-100,40 Q500,${40 + curveAmount} 1540,40`;\r\n\r\n  const dragRef = useRef(false);\r\n  const lastXRef = useRef(0);\r\n  const dirRef = useRef<'left' | 'right'>(direction);\r\n  const velRef = useRef(0);\r\n\r\n  const textLength = spacing;\r\n  const totalText = textLength\r\n    ? Array(Math.ceil(1800 / textLength) + 2)\r\n        .fill(text)\r\n        .join('')\r\n    : text;\r\n  const ready = spacing > 0;\r\n\r\n  useEffect(() => {\r\n    if (measureRef.current) setSpacing(measureRef.current.getComputedTextLength());\r\n  }, [text, className]);\r\n\r\n  useEffect(() => {\r\n    if (!spacing) return;\r\n    if (textPathRef.current) {\r\n      const initial = -spacing;\r\n      textPathRef.current.setAttribute('startOffset', initial + 'px');\r\n      setOffset(initial);\r\n    }\r\n  }, [spacing]);\r\n\r\n  useEffect(() => {\r\n    if (!spacing || !ready) return;\r\n    let frame = 0;\r\n    const step = () => {\r\n      if (!dragRef.current && textPathRef.current) {\r\n        const delta = dirRef.current === 'right' ? speed : -speed;\r\n        const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');\r\n        let newOffset = currentOffset + delta;\r\n        const wrapPoint = spacing;\r\n        if (newOffset <= -wrapPoint) newOffset += wrapPoint;\r\n        if (newOffset > 0) newOffset -= wrapPoint;\r\n        textPathRef.current.setAttribute('startOffset', newOffset + 'px');\r\n        setOffset(newOffset);\r\n      }\r\n      frame = requestAnimationFrame(step);\r\n    };\r\n    frame = requestAnimationFrame(step);\r\n    return () => cancelAnimationFrame(frame);\r\n  }, [spacing, speed, ready]);\r\n\r\n  const onPointerDown = (e: PointerEvent) => {\r\n    if (!interactive) return;\r\n    dragRef.current = true;\r\n    lastXRef.current = e.clientX;\r\n    velRef.current = 0;\r\n    (e.target as HTMLElement).setPointerCapture(e.pointerId);\r\n  };\r\n\r\n  const onPointerMove = (e: PointerEvent) => {\r\n    if (!interactive || !dragRef.current || !textPathRef.current) return;\r\n    const dx = e.clientX - lastXRef.current;\r\n    lastXRef.current = e.clientX;\r\n    velRef.current = dx;\r\n    const currentOffset = parseFloat(textPathRef.current.getAttribute('startOffset') || '0');\r\n    let newOffset = currentOffset + dx;\r\n    const wrapPoint = spacing;\r\n    if (newOffset <= -wrapPoint) newOffset += wrapPoint;\r\n    if (newOffset > 0) newOffset -= wrapPoint;\r\n    textPathRef.current.setAttribute('startOffset', newOffset + 'px');\r\n    setOffset(newOffset);\r\n  };\r\n\r\n  const endDrag = () => {\r\n    if (!interactive) return;\r\n    dragRef.current = false;\r\n    dirRef.current = velRef.current > 0 ? 'right' : 'left';\r\n  };\r\n\r\n  const cursorStyle = interactive ? (dragRef.current ? 'grabbing' : 'grab') : 'auto';\r\n\r\n  return (\r\n    <div\r\n      className=\"min-h-screen flex items-center justify-center w-full\"\r\n      style={{ visibility: ready ? 'visible' : 'hidden', cursor: cursorStyle }}\r\n      onPointerDown={onPointerDown}\r\n      onPointerMove={onPointerMove}\r\n      onPointerUp={endDrag}\r\n      onPointerLeave={endDrag}\r\n    >\r\n      <svg\r\n        className=\"select-none w-full overflow-visible block aspect-[100/12] text-[6rem] font-bold uppercase leading-none\"\r\n        viewBox=\"0 0 1440 120\"\r\n      >\r\n        <text ref={measureRef} xmlSpace=\"preserve\" style={{ visibility: 'hidden', opacity: 0, pointerEvents: 'none' }}>\r\n          {text}\r\n        </text>\r\n        <defs>\r\n          <path ref={pathRef} id={pathId} d={pathD} fill=\"none\" stroke=\"transparent\" />\r\n        </defs>\r\n        {ready && (\r\n          <text xmlSpace=\"preserve\" className={`fill-white ${className ?? ''}`}>\r\n            <textPath ref={textPathRef} href={`#${pathId}`} startOffset={offset + 'px'} xmlSpace=\"preserve\">\r\n              {totalText}\r\n            </textPath>\r\n          </text>\r\n        )}\r\n      </svg>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default CurvedLoop;\r\n",
      "type": "registry:component"
    }
  ]
}