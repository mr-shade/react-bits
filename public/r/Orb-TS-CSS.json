{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Orb-TS-CSS",
  "type": "registry:block",
  "title": "Orb",
  "description": "Floating energy orb with customizable hover effect.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/Backgrounds/Orb/Orb.tsx",
      "content": "import { useEffect, useRef } from 'react';\r\nimport { Renderer, Program, Mesh, Triangle, Vec3 } from 'ogl';\r\n\r\nimport './Orb.css';\r\n\r\ninterface OrbProps {\r\n  hue?: number;\r\n  hoverIntensity?: number;\r\n  rotateOnHover?: boolean;\r\n  forceHoverState?: boolean;\r\n}\r\n\r\nexport default function Orb({\r\n  hue = 0,\r\n  hoverIntensity = 0.2,\r\n  rotateOnHover = true,\r\n  forceHoverState = false\r\n}: OrbProps) {\r\n  const ctnDom = useRef<HTMLDivElement>(null);\r\n\r\n  const vert = /* glsl */ `\r\n    precision highp float;\r\n    attribute vec2 position;\r\n    attribute vec2 uv;\r\n    varying vec2 vUv;\r\n    void main() {\r\n      vUv = uv;\r\n      gl_Position = vec4(position, 0.0, 1.0);\r\n    }\r\n  `;\r\n\r\n  const frag = /* glsl */ `\r\n    precision highp float;\r\n\r\n    uniform float iTime;\r\n    uniform vec3 iResolution;\r\n    uniform float hue;\r\n    uniform float hover;\r\n    uniform float rot;\r\n    uniform float hoverIntensity;\r\n    varying vec2 vUv;\r\n\r\n    vec3 rgb2yiq(vec3 c) {\r\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\r\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\r\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\r\n      return vec3(y, i, q);\r\n    }\r\n    \r\n    vec3 yiq2rgb(vec3 c) {\r\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\r\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\r\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\r\n      return vec3(r, g, b);\r\n    }\r\n    \r\n    vec3 adjustHue(vec3 color, float hueDeg) {\r\n      float hueRad = hueDeg * 3.14159265 / 180.0;\r\n      vec3 yiq = rgb2yiq(color);\r\n      float cosA = cos(hueRad);\r\n      float sinA = sin(hueRad);\r\n      float i = yiq.y * cosA - yiq.z * sinA;\r\n      float q = yiq.y * sinA + yiq.z * cosA;\r\n      yiq.y = i;\r\n      yiq.z = q;\r\n      return yiq2rgb(yiq);\r\n    }\r\n    \r\n    vec3 hash33(vec3 p3) {\r\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\r\n      p3 += dot(p3, p3.yxz + 19.19);\r\n      return -1.0 + 2.0 * fract(vec3(\r\n        p3.x + p3.y,\r\n        p3.x + p3.z,\r\n        p3.y + p3.z\r\n      ) * p3.zyx);\r\n    }\r\n    \r\n    float snoise3(vec3 p) {\r\n      const float K1 = 0.333333333;\r\n      const float K2 = 0.166666667;\r\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\r\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\r\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\r\n      vec3 i1 = e * (1.0 - e.zxy);\r\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\r\n      vec3 d1 = d0 - (i1 - K2);\r\n      vec3 d2 = d0 - (i2 - K1);\r\n      vec3 d3 = d0 - 0.5;\r\n      vec4 h = max(0.6 - vec4(\r\n        dot(d0, d0),\r\n        dot(d1, d1),\r\n        dot(d2, d2),\r\n        dot(d3, d3)\r\n      ), 0.0);\r\n      vec4 n = h * h * h * h * vec4(\r\n        dot(d0, hash33(i)),\r\n        dot(d1, hash33(i + i1)),\r\n        dot(d2, hash33(i + i2)),\r\n        dot(d3, hash33(i + 1.0))\r\n      );\r\n      return dot(vec4(31.316), n);\r\n    }\r\n    \r\n    vec4 extractAlpha(vec3 colorIn) {\r\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\r\n      return vec4(colorIn.rgb / (a + 1e-5), a);\r\n    }\r\n    \r\n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\r\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\r\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\r\n    const float innerRadius = 0.6;\r\n    const float noiseScale = 0.65;\r\n    \r\n    float light1(float intensity, float attenuation, float dist) {\r\n      return intensity / (1.0 + dist * attenuation);\r\n    }\r\n    \r\n    float light2(float intensity, float attenuation, float dist) {\r\n      return intensity / (1.0 + dist * dist * attenuation);\r\n    }\r\n    \r\n    vec4 draw(vec2 uv) {\r\n      vec3 color1 = adjustHue(baseColor1, hue);\r\n      vec3 color2 = adjustHue(baseColor2, hue);\r\n      vec3 color3 = adjustHue(baseColor3, hue);\r\n      \r\n      float ang = atan(uv.y, uv.x);\r\n      float len = length(uv);\r\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\r\n      \r\n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\r\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\r\n      float d0 = distance(uv, (r0 * invLen) * uv);\r\n      float v0 = light1(1.0, 10.0, d0);\r\n      v0 *= smoothstep(r0 * 1.05, r0, len);\r\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\r\n      \r\n      float a = iTime * -1.0;\r\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\r\n      float d = distance(uv, pos);\r\n      float v1 = light2(1.5, 5.0, d);\r\n      v1 *= light1(1.0, 50.0, d0);\r\n      \r\n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\r\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\r\n      \r\n      vec3 col = mix(color1, color2, cl);\r\n      col = mix(color3, col, v0);\r\n      col = (col + v1) * v2 * v3;\r\n      col = clamp(col, 0.0, 1.0);\r\n      \r\n      return extractAlpha(col);\r\n    }\r\n    \r\n    vec4 mainImage(vec2 fragCoord) {\r\n      vec2 center = iResolution.xy * 0.5;\r\n      float size = min(iResolution.x, iResolution.y);\r\n      vec2 uv = (fragCoord - center) / size * 2.0;\r\n      \r\n      float angle = rot;\r\n      float s = sin(angle);\r\n      float c = cos(angle);\r\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\r\n      \r\n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\r\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\r\n      \r\n      return draw(uv);\r\n    }\r\n    \r\n    void main() {\r\n      vec2 fragCoord = vUv * iResolution.xy;\r\n      vec4 col = mainImage(fragCoord);\r\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\r\n    }\r\n  `;\r\n\r\n  useEffect(() => {\r\n    const container = ctnDom.current;\r\n    if (!container) return;\r\n\r\n    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\r\n    const gl = renderer.gl;\r\n    gl.clearColor(0, 0, 0, 0);\r\n    container.appendChild(gl.canvas);\r\n\r\n    const geometry = new Triangle(gl);\r\n    const program = new Program(gl, {\r\n      vertex: vert,\r\n      fragment: frag,\r\n      uniforms: {\r\n        iTime: { value: 0 },\r\n        iResolution: {\r\n          value: new Vec3(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\r\n        },\r\n        hue: { value: hue },\r\n        hover: { value: 0 },\r\n        rot: { value: 0 },\r\n        hoverIntensity: { value: hoverIntensity }\r\n      }\r\n    });\r\n\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n\r\n    function resize() {\r\n      if (!container) return;\r\n      const dpr = window.devicePixelRatio || 1;\r\n      const width = container.clientWidth;\r\n      const height = container.clientHeight;\r\n      renderer.setSize(width * dpr, height * dpr);\r\n      gl.canvas.style.width = width + 'px';\r\n      gl.canvas.style.height = height + 'px';\r\n      program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height);\r\n    }\r\n    window.addEventListener('resize', resize);\r\n    resize();\r\n\r\n    let targetHover = 0;\r\n    let lastTime = 0;\r\n    let currentRot = 0;\r\n    const rotationSpeed = 0.3;\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const rect = container.getBoundingClientRect();\r\n      const x = e.clientX - rect.left;\r\n      const y = e.clientY - rect.top;\r\n      const width = rect.width;\r\n      const height = rect.height;\r\n      const size = Math.min(width, height);\r\n      const centerX = width / 2;\r\n      const centerY = height / 2;\r\n      const uvX = ((x - centerX) / size) * 2.0;\r\n      const uvY = ((y - centerY) / size) * 2.0;\r\n\r\n      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\r\n        targetHover = 1;\r\n      } else {\r\n        targetHover = 0;\r\n      }\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      targetHover = 0;\r\n    };\r\n\r\n    container.addEventListener('mousemove', handleMouseMove);\r\n    container.addEventListener('mouseleave', handleMouseLeave);\r\n\r\n    let rafId: number;\r\n    const update = (t: number) => {\r\n      rafId = requestAnimationFrame(update);\r\n      const dt = (t - lastTime) * 0.001;\r\n      lastTime = t;\r\n      program.uniforms.iTime.value = t * 0.001;\r\n      program.uniforms.hue.value = hue;\r\n      program.uniforms.hoverIntensity.value = hoverIntensity;\r\n\r\n      const effectiveHover = forceHoverState ? 1 : targetHover;\r\n      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\r\n\r\n      if (rotateOnHover && effectiveHover > 0.5) {\r\n        currentRot += dt * rotationSpeed;\r\n      }\r\n      program.uniforms.rot.value = currentRot;\r\n\r\n      renderer.render({ scene: mesh });\r\n    };\r\n    rafId = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(rafId);\r\n      window.removeEventListener('resize', resize);\r\n      container.removeEventListener('mousemove', handleMouseMove);\r\n      container.removeEventListener('mouseleave', handleMouseLeave);\r\n      container.removeChild(gl.canvas);\r\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\r\n    };\r\n  }, [hue, hoverIntensity, rotateOnHover, forceHoverState]);\r\n\r\n  return <div ref={ctnDom} className=\"orb-container\" />;\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/Backgrounds/Orb/Orb.css",
      "content": ".orb-container {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}