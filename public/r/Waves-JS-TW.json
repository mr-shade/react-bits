{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Waves-JS-TW",
  "type": "registry:block",
  "title": "Waves",
  "description": "Layered lines that form smooth wave patterns with animation.",
  "files": [
    {
      "path": "public/tailwind/src/tailwind/Backgrounds/Waves/Waves.jsx",
      "content": "import { useRef, useEffect } from 'react';\r\n\r\nclass Grad {\r\n  constructor(x, y, z) {\r\n    this.x = x;\r\n    this.y = y;\r\n    this.z = z;\r\n  }\r\n  dot2(x, y) {\r\n    return this.x * x + this.y * y;\r\n  }\r\n}\r\n\r\nclass Noise {\r\n  constructor(seed = 0) {\r\n    this.grad3 = [\r\n      new Grad(1, 1, 0),\r\n      new Grad(-1, 1, 0),\r\n      new Grad(1, -1, 0),\r\n      new Grad(-1, -1, 0),\r\n      new Grad(1, 0, 1),\r\n      new Grad(-1, 0, 1),\r\n      new Grad(1, 0, -1),\r\n      new Grad(-1, 0, -1),\r\n      new Grad(0, 1, 1),\r\n      new Grad(0, -1, 1),\r\n      new Grad(0, 1, -1),\r\n      new Grad(0, -1, -1)\r\n    ];\r\n    this.p = [\r\n      151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240,\r\n      21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88,\r\n      237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83,\r\n      111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216,\r\n      80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186,\r\n      3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58,\r\n      17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\r\n      129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193,\r\n      238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157,\r\n      184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128,\r\n      195, 78, 66, 215, 61, 156, 180\r\n    ];\r\n    this.perm = new Array(512);\r\n    this.gradP = new Array(512);\r\n    this.seed(seed);\r\n  }\r\n  seed(seed) {\r\n    if (seed > 0 && seed < 1) seed *= 65536;\r\n    seed = Math.floor(seed);\r\n    if (seed < 256) seed |= seed << 8;\r\n    for (let i = 0; i < 256; i++) {\r\n      let v = i & 1 ? this.p[i] ^ (seed & 255) : this.p[i] ^ ((seed >> 8) & 255);\r\n      this.perm[i] = this.perm[i + 256] = v;\r\n      this.gradP[i] = this.gradP[i + 256] = this.grad3[v % 12];\r\n    }\r\n  }\r\n  fade(t) {\r\n    return t * t * t * (t * (t * 6 - 15) + 10);\r\n  }\r\n  lerp(a, b, t) {\r\n    return (1 - t) * a + t * b;\r\n  }\r\n  perlin2(x, y) {\r\n    let X = Math.floor(x),\r\n      Y = Math.floor(y);\r\n    x -= X;\r\n    y -= Y;\r\n    X &= 255;\r\n    Y &= 255;\r\n    const n00 = this.gradP[X + this.perm[Y]].dot2(x, y);\r\n    const n01 = this.gradP[X + this.perm[Y + 1]].dot2(x, y - 1);\r\n    const n10 = this.gradP[X + 1 + this.perm[Y]].dot2(x - 1, y);\r\n    const n11 = this.gradP[X + 1 + this.perm[Y + 1]].dot2(x - 1, y - 1);\r\n    const u = this.fade(x);\r\n    return this.lerp(this.lerp(n00, n10, u), this.lerp(n01, n11, u), this.fade(y));\r\n  }\r\n}\r\n\r\nconst Waves = ({\r\n  lineColor = 'black',\r\n  backgroundColor = 'transparent',\r\n  waveSpeedX = 0.0125,\r\n  waveSpeedY = 0.005,\r\n  waveAmpX = 32,\r\n  waveAmpY = 16,\r\n  xGap = 10,\r\n  yGap = 32,\r\n  friction = 0.925,\r\n  tension = 0.005,\r\n  maxCursorMove = 100,\r\n  style = {},\r\n  className = ''\r\n}) => {\r\n  const containerRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n  const ctxRef = useRef(null);\r\n  const boundingRef = useRef({ width: 0, height: 0, left: 0, top: 0 });\r\n  const noiseRef = useRef(new Noise(Math.random()));\r\n  const linesRef = useRef([]);\r\n  const mouseRef = useRef({\r\n    x: -10,\r\n    y: 0,\r\n    lx: 0,\r\n    ly: 0,\r\n    sx: 0,\r\n    sy: 0,\r\n    v: 0,\r\n    vs: 0,\r\n    a: 0,\r\n    set: false\r\n  });\r\n\r\n  const configRef = useRef({\r\n    lineColor,\r\n    waveSpeedX,\r\n    waveSpeedY,\r\n    waveAmpX,\r\n    waveAmpY,\r\n    friction,\r\n    tension,\r\n    maxCursorMove,\r\n    xGap,\r\n    yGap\r\n  });\r\n  const frameIdRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    configRef.current = {\r\n      lineColor,\r\n      waveSpeedX,\r\n      waveSpeedY,\r\n      waveAmpX,\r\n      waveAmpY,\r\n      friction,\r\n      tension,\r\n      maxCursorMove,\r\n      xGap,\r\n      yGap\r\n    };\r\n  }, [lineColor, waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove, xGap, yGap]);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const container = containerRef.current;\r\n    ctxRef.current = canvas.getContext('2d');\r\n\r\n    function setSize() {\r\n      boundingRef.current = container.getBoundingClientRect();\r\n      canvas.width = boundingRef.current.width;\r\n      canvas.height = boundingRef.current.height;\r\n    }\r\n\r\n    function setLines() {\r\n      const { width, height } = boundingRef.current;\r\n      linesRef.current = [];\r\n      const oWidth = width + 200,\r\n        oHeight = height + 30;\r\n      const { xGap, yGap } = configRef.current;\r\n      const totalLines = Math.ceil(oWidth / xGap);\r\n      const totalPoints = Math.ceil(oHeight / yGap);\r\n      const xStart = (width - xGap * totalLines) / 2;\r\n      const yStart = (height - yGap * totalPoints) / 2;\r\n      for (let i = 0; i <= totalLines; i++) {\r\n        const pts = [];\r\n        for (let j = 0; j <= totalPoints; j++) {\r\n          pts.push({\r\n            x: xStart + xGap * i,\r\n            y: yStart + yGap * j,\r\n            wave: { x: 0, y: 0 },\r\n            cursor: { x: 0, y: 0, vx: 0, vy: 0 }\r\n          });\r\n        }\r\n        linesRef.current.push(pts);\r\n      }\r\n    }\r\n\r\n    function movePoints(time) {\r\n      const lines = linesRef.current,\r\n        mouse = mouseRef.current,\r\n        noise = noiseRef.current;\r\n      const { waveSpeedX, waveSpeedY, waveAmpX, waveAmpY, friction, tension, maxCursorMove } = configRef.current;\r\n      lines.forEach(pts => {\r\n        pts.forEach(p => {\r\n          const move = noise.perlin2((p.x + time * waveSpeedX) * 0.002, (p.y + time * waveSpeedY) * 0.0015) * 12;\r\n          p.wave.x = Math.cos(move) * waveAmpX;\r\n          p.wave.y = Math.sin(move) * waveAmpY;\r\n\r\n          const dx = p.x - mouse.sx,\r\n            dy = p.y - mouse.sy;\r\n          const dist = Math.hypot(dx, dy),\r\n            l = Math.max(175, mouse.vs);\r\n          if (dist < l) {\r\n            const s = 1 - dist / l;\r\n            const f = Math.cos(dist * 0.001) * s;\r\n            p.cursor.vx += Math.cos(mouse.a) * f * l * mouse.vs * 0.00065;\r\n            p.cursor.vy += Math.sin(mouse.a) * f * l * mouse.vs * 0.00065;\r\n          }\r\n\r\n          p.cursor.vx += (0 - p.cursor.x) * tension;\r\n          p.cursor.vy += (0 - p.cursor.y) * tension;\r\n          p.cursor.vx *= friction;\r\n          p.cursor.vy *= friction;\r\n          p.cursor.x += p.cursor.vx * 2;\r\n          p.cursor.y += p.cursor.vy * 2;\r\n          p.cursor.x = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.x));\r\n          p.cursor.y = Math.min(maxCursorMove, Math.max(-maxCursorMove, p.cursor.y));\r\n        });\r\n      });\r\n    }\r\n\r\n    function moved(point, withCursor = true) {\r\n      const x = point.x + point.wave.x + (withCursor ? point.cursor.x : 0);\r\n      const y = point.y + point.wave.y + (withCursor ? point.cursor.y : 0);\r\n      return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };\r\n    }\r\n\r\n    function drawLines() {\r\n      const { width, height } = boundingRef.current;\r\n      const ctx = ctxRef.current;\r\n      ctx.clearRect(0, 0, width, height);\r\n      ctx.beginPath();\r\n      ctx.strokeStyle = configRef.current.lineColor;\r\n      linesRef.current.forEach(points => {\r\n        let p1 = moved(points[0], false);\r\n        ctx.moveTo(p1.x, p1.y);\r\n        points.forEach((p, idx) => {\r\n          const isLast = idx === points.length - 1;\r\n          p1 = moved(p, !isLast);\r\n          const p2 = moved(points[idx + 1] || points[points.length - 1], !isLast);\r\n          ctx.lineTo(p1.x, p1.y);\r\n          if (isLast) ctx.moveTo(p2.x, p2.y);\r\n        });\r\n      });\r\n      ctx.stroke();\r\n    }\r\n\r\n    function tick(t) {\r\n      const mouse = mouseRef.current;\r\n      mouse.sx += (mouse.x - mouse.sx) * 0.1;\r\n      mouse.sy += (mouse.y - mouse.sy) * 0.1;\r\n      const dx = mouse.x - mouse.lx,\r\n        dy = mouse.y - mouse.ly;\r\n      const d = Math.hypot(dx, dy);\r\n      mouse.v = d;\r\n      mouse.vs += (d - mouse.vs) * 0.1;\r\n      mouse.vs = Math.min(100, mouse.vs);\r\n      mouse.lx = mouse.x;\r\n      mouse.ly = mouse.y;\r\n      mouse.a = Math.atan2(dy, dx);\r\n      container.style.setProperty('--x', `${mouse.sx}px`);\r\n      container.style.setProperty('--y', `${mouse.sy}px`);\r\n\r\n      movePoints(t);\r\n      drawLines();\r\n      frameIdRef.current = requestAnimationFrame(tick);\r\n    }\r\n\r\n    function onResize() {\r\n      setSize();\r\n      setLines();\r\n    }\r\n    function onMouseMove(e) {\r\n      updateMouse(e.clientX, e.clientY);\r\n    }\r\n    function onTouchMove(e) {\r\n      const touch = e.touches[0];\r\n      updateMouse(touch.clientX, touch.clientY);\r\n    }\r\n    function updateMouse(x, y) {\r\n      const mouse = mouseRef.current,\r\n        b = boundingRef.current;\r\n      mouse.x = x - b.left;\r\n      mouse.y = y - b.top;\r\n      if (!mouse.set) {\r\n        mouse.sx = mouse.x;\r\n        mouse.sy = mouse.y;\r\n        mouse.lx = mouse.x;\r\n        mouse.ly = mouse.y;\r\n        mouse.set = true;\r\n      }\r\n    }\r\n\r\n    setSize();\r\n    setLines();\r\n    frameIdRef.current = requestAnimationFrame(tick);\r\n    window.addEventListener('resize', onResize);\r\n    window.addEventListener('mousemove', onMouseMove);\r\n    window.addEventListener('touchmove', onTouchMove, { passive: false });\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', onResize);\r\n      window.removeEventListener('mousemove', onMouseMove);\r\n      window.removeEventListener('touchmove', onTouchMove);\r\n      cancelAnimationFrame(frameIdRef.current);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      style={{\r\n        backgroundColor,\r\n        ...style\r\n      }}\r\n      className={`absolute top-0 left-0 w-full h-full overflow-hidden ${className}`}\r\n    >\r\n      <div\r\n        className=\"absolute top-0 left-0 bg-[#160000] rounded-full w-[0.5rem] h-[0.5rem]\"\r\n        style={{\r\n          transform: 'translate3d(calc(var(--x) - 50%), calc(var(--y) - 50%), 0)',\r\n          willChange: 'transform'\r\n        }}\r\n      />\r\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Waves;\r\n",
      "type": "registry:component"
    }
  ]
}