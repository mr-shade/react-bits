{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ScrollStack-TS-CSS",
  "type": "registry:block",
  "title": "ScrollStack",
  "description": "Overlapping card stack reveals on scroll with depth layering.",
  "dependencies": [
    "lenis"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/Components/ScrollStack/ScrollStack.tsx",
      "content": "import React, { ReactNode, useLayoutEffect, useRef, useCallback } from 'react';\r\nimport Lenis from 'lenis';\r\nimport './ScrollStack.css';\r\n\r\nexport interface ScrollStackItemProps {\r\n  itemClassName?: string;\r\n  children: ReactNode;\r\n}\r\n\r\nexport const ScrollStackItem: React.FC<ScrollStackItemProps> = ({ children, itemClassName = '' }) => (\r\n  <div className={`scroll-stack-card ${itemClassName}`.trim()}>{children}</div>\r\n);\r\n\r\ninterface ScrollStackProps {\r\n  className?: string;\r\n  children: ReactNode;\r\n  itemDistance?: number;\r\n  itemScale?: number;\r\n  itemStackDistance?: number;\r\n  stackPosition?: string;\r\n  scaleEndPosition?: string;\r\n  baseScale?: number;\r\n  scaleDuration?: number;\r\n  rotationAmount?: number;\r\n  blurAmount?: number;\r\n  useWindowScroll?: boolean;\r\n  onStackComplete?: () => void;\r\n}\r\n\r\nconst ScrollStack: React.FC<ScrollStackProps> = ({\r\n  children,\r\n  className = '',\r\n  itemDistance = 100,\r\n  itemScale = 0.03,\r\n  itemStackDistance = 30,\r\n  stackPosition = '20%',\r\n  scaleEndPosition = '10%',\r\n  baseScale = 0.85,\r\n  scaleDuration = 0.5,\r\n  rotationAmount = 0,\r\n  blurAmount = 0,\r\n  useWindowScroll = false,\r\n  onStackComplete\r\n}) => {\r\n  const scrollerRef = useRef<HTMLDivElement>(null);\r\n  const stackCompletedRef = useRef(false);\r\n  const animationFrameRef = useRef<number | null>(null);\r\n  const lenisRef = useRef<Lenis | null>(null);\r\n  const cardsRef = useRef<HTMLElement[]>([]);\r\n  const lastTransformsRef = useRef(new Map<number, any>());\r\n  const isUpdatingRef = useRef(false);\r\n\r\n  const calculateProgress = useCallback((scrollTop: number, start: number, end: number) => {\r\n    if (scrollTop < start) return 0;\r\n    if (scrollTop > end) return 1;\r\n    return (scrollTop - start) / (end - start);\r\n  }, []);\r\n\r\n  const parsePercentage = useCallback((value: string | number, containerHeight: number) => {\r\n    if (typeof value === 'string' && value.includes('%')) {\r\n      return (parseFloat(value) / 100) * containerHeight;\r\n    }\r\n    return parseFloat(value as string);\r\n  }, []);\r\n\r\n  const getScrollData = useCallback(() => {\r\n    if (useWindowScroll) {\r\n      return {\r\n        scrollTop: window.scrollY,\r\n        containerHeight: window.innerHeight,\r\n        scrollContainer: document.documentElement\r\n      };\r\n    } else {\r\n      const scroller = scrollerRef.current;\r\n      return {\r\n        scrollTop: scroller!.scrollTop,\r\n        containerHeight: scroller!.clientHeight,\r\n        scrollContainer: scroller!\r\n      };\r\n    }\r\n  }, [useWindowScroll]);\r\n\r\n  const getElementOffset = useCallback(\r\n    (element: HTMLElement) => {\r\n      if (useWindowScroll) {\r\n        const rect = element.getBoundingClientRect();\r\n        return rect.top + window.scrollY;\r\n      } else {\r\n        return element.offsetTop;\r\n      }\r\n    },\r\n    [useWindowScroll]\r\n  );\r\n\r\n  const updateCardTransforms = useCallback(() => {\r\n    if (!cardsRef.current.length || isUpdatingRef.current) return;\r\n\r\n    isUpdatingRef.current = true;\r\n\r\n    const { scrollTop, containerHeight } = getScrollData();\r\n    const stackPositionPx = parsePercentage(stackPosition, containerHeight);\r\n    const scaleEndPositionPx = parsePercentage(scaleEndPosition, containerHeight);\r\n\r\n    const endElement = useWindowScroll\r\n      ? (document.querySelector('.scroll-stack-end') as HTMLElement)\r\n      : (scrollerRef.current?.querySelector('.scroll-stack-end') as HTMLElement);\r\n\r\n    const endElementTop = endElement ? getElementOffset(endElement) : 0;\r\n\r\n    cardsRef.current.forEach((card, i) => {\r\n      if (!card) return;\r\n\r\n      const cardTop = getElementOffset(card);\r\n      const triggerStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n      const triggerEnd = cardTop - scaleEndPositionPx;\r\n      const pinStart = cardTop - stackPositionPx - itemStackDistance * i;\r\n      const pinEnd = endElementTop - containerHeight / 2;\r\n\r\n      const scaleProgress = calculateProgress(scrollTop, triggerStart, triggerEnd);\r\n      const targetScale = baseScale + i * itemScale;\r\n      const scale = 1 - scaleProgress * (1 - targetScale);\r\n      const rotation = rotationAmount ? i * rotationAmount * scaleProgress : 0;\r\n\r\n      let blur = 0;\r\n      if (blurAmount) {\r\n        let topCardIndex = 0;\r\n        for (let j = 0; j < cardsRef.current.length; j++) {\r\n          const jCardTop = getElementOffset(cardsRef.current[j]);\r\n          const jTriggerStart = jCardTop - stackPositionPx - itemStackDistance * j;\r\n          if (scrollTop >= jTriggerStart) {\r\n            topCardIndex = j;\r\n          }\r\n        }\r\n\r\n        if (i < topCardIndex) {\r\n          const depthInStack = topCardIndex - i;\r\n          blur = Math.max(0, depthInStack * blurAmount);\r\n        }\r\n      }\r\n\r\n      let translateY = 0;\r\n      const isPinned = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n\r\n      if (isPinned) {\r\n        translateY = scrollTop - cardTop + stackPositionPx + itemStackDistance * i;\r\n      } else if (scrollTop > pinEnd) {\r\n        translateY = pinEnd - cardTop + stackPositionPx + itemStackDistance * i;\r\n      }\r\n\r\n      const newTransform = {\r\n        translateY: Math.round(translateY * 100) / 100,\r\n        scale: Math.round(scale * 1000) / 1000,\r\n        rotation: Math.round(rotation * 100) / 100,\r\n        blur: Math.round(blur * 100) / 100\r\n      };\r\n\r\n      const lastTransform = lastTransformsRef.current.get(i);\r\n      const hasChanged =\r\n        !lastTransform ||\r\n        Math.abs(lastTransform.translateY - newTransform.translateY) > 0.1 ||\r\n        Math.abs(lastTransform.scale - newTransform.scale) > 0.001 ||\r\n        Math.abs(lastTransform.rotation - newTransform.rotation) > 0.1 ||\r\n        Math.abs(lastTransform.blur - newTransform.blur) > 0.1;\r\n\r\n      if (hasChanged) {\r\n        const transform = `translate3d(0, ${newTransform.translateY}px, 0) scale(${newTransform.scale}) rotate(${newTransform.rotation}deg)`;\r\n        const filter = newTransform.blur > 0 ? `blur(${newTransform.blur}px)` : '';\r\n\r\n        card.style.transform = transform;\r\n        card.style.filter = filter;\r\n\r\n        lastTransformsRef.current.set(i, newTransform);\r\n      }\r\n\r\n      if (i === cardsRef.current.length - 1) {\r\n        const isInView = scrollTop >= pinStart && scrollTop <= pinEnd;\r\n        if (isInView && !stackCompletedRef.current) {\r\n          stackCompletedRef.current = true;\r\n          onStackComplete?.();\r\n        } else if (!isInView && stackCompletedRef.current) {\r\n          stackCompletedRef.current = false;\r\n        }\r\n      }\r\n    });\r\n\r\n    isUpdatingRef.current = false;\r\n  }, [\r\n    itemScale,\r\n    itemStackDistance,\r\n    stackPosition,\r\n    scaleEndPosition,\r\n    baseScale,\r\n    rotationAmount,\r\n    blurAmount,\r\n    useWindowScroll,\r\n    onStackComplete,\r\n    calculateProgress,\r\n    parsePercentage,\r\n    getScrollData,\r\n    getElementOffset\r\n  ]);\r\n\r\n  const handleScroll = useCallback(() => {\r\n    updateCardTransforms();\r\n  }, [updateCardTransforms]);\r\n\r\n  const setupLenis = useCallback(() => {\r\n    if (useWindowScroll) {\r\n      const lenis = new Lenis({\r\n        duration: 1.2,\r\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n        smoothWheel: true,\r\n        touchMultiplier: 2,\r\n        infinite: false,\r\n        wheelMultiplier: 1,\r\n        lerp: 0.1,\r\n        syncTouch: true,\r\n        syncTouchLerp: 0.075\r\n      });\r\n\r\n      lenis.on('scroll', handleScroll);\r\n\r\n      const raf = (time: number) => {\r\n        lenis.raf(time);\r\n        animationFrameRef.current = requestAnimationFrame(raf);\r\n      };\r\n      animationFrameRef.current = requestAnimationFrame(raf);\r\n\r\n      lenisRef.current = lenis;\r\n      return lenis;\r\n    } else {\r\n      const scroller = scrollerRef.current;\r\n      if (!scroller) return;\r\n\r\n      const lenis = new Lenis({\r\n        wrapper: scroller,\r\n        content: scroller.querySelector('.scroll-stack-inner') as HTMLElement,\r\n        duration: 1.2,\r\n        easing: t => Math.min(1, 1.001 - Math.pow(2, -10 * t)),\r\n        smoothWheel: true,\r\n        touchMultiplier: 2,\r\n        infinite: false,\r\n        gestureOrientation: 'vertical',\r\n        wheelMultiplier: 1,\r\n        lerp: 0.1,\r\n        syncTouch: true,\r\n        syncTouchLerp: 0.075\r\n      });\r\n\r\n      lenis.on('scroll', handleScroll);\r\n\r\n      const raf = (time: number) => {\r\n        lenis.raf(time);\r\n        animationFrameRef.current = requestAnimationFrame(raf);\r\n      };\r\n      animationFrameRef.current = requestAnimationFrame(raf);\r\n\r\n      lenisRef.current = lenis;\r\n      return lenis;\r\n    }\r\n  }, [handleScroll, useWindowScroll]);\r\n\r\n  useLayoutEffect(() => {\r\n    const scroller = scrollerRef.current;\r\n    if (!scroller) return;\r\n\r\n    const cards = Array.from(\r\n      useWindowScroll\r\n        ? document.querySelectorAll('.scroll-stack-card')\r\n        : scroller.querySelectorAll('.scroll-stack-card')\r\n    ) as HTMLElement[];\r\n\r\n    cardsRef.current = cards;\r\n    const transformsCache = lastTransformsRef.current;\r\n\r\n    cards.forEach((card, i) => {\r\n      if (i < cards.length - 1) {\r\n        card.style.marginBottom = `${itemDistance}px`;\r\n      }\r\n      card.style.willChange = 'transform, filter';\r\n      card.style.transformOrigin = 'top center';\r\n      card.style.backfaceVisibility = 'hidden';\r\n      card.style.transform = 'translateZ(0)';\r\n      card.style.webkitTransform = 'translateZ(0)';\r\n      card.style.perspective = '1000px';\r\n      card.style.webkitPerspective = '1000px';\r\n    });\r\n\r\n    setupLenis();\r\n\r\n    updateCardTransforms();\r\n\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n      if (lenisRef.current) {\r\n        lenisRef.current.destroy();\r\n      }\r\n      stackCompletedRef.current = false;\r\n      cardsRef.current = [];\r\n      transformsCache.clear();\r\n      isUpdatingRef.current = false;\r\n    };\r\n  }, [\r\n    itemDistance,\r\n    itemScale,\r\n    itemStackDistance,\r\n    stackPosition,\r\n    scaleEndPosition,\r\n    baseScale,\r\n    scaleDuration,\r\n    rotationAmount,\r\n    blurAmount,\r\n    useWindowScroll,\r\n    onStackComplete,\r\n    setupLenis,\r\n    updateCardTransforms\r\n  ]);\r\n\r\n  return (\r\n    <div className={`scroll-stack-scroller ${className}`.trim()} ref={scrollerRef}>\r\n      <div className=\"scroll-stack-inner\">\r\n        {children}\r\n        {/* Spacer so the last pin can release cleanly */}\r\n        <div className=\"scroll-stack-end\" />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ScrollStack;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/Components/ScrollStack/ScrollStack.css",
      "content": ".scroll-stack-scroller {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow-y: auto;\r\n  overflow-x: visible;\r\n  overscroll-behavior: contain;\r\n  -webkit-overflow-scrolling: touch;\r\n  scroll-behavior: smooth;\r\n  -webkit-transform: translateZ(0);\r\n  transform: translateZ(0);\r\n  will-change: scroll-position;\r\n}\r\n\r\n.scroll-stack-inner {\r\n  padding: 20vh 5rem 50rem;\r\n  min-height: 100vh;\r\n}\r\n\r\n.scroll-stack-card-wrapper {\r\n  position: relative;\r\n}\r\n\r\n.scroll-stack-card {\r\n  transform-origin: top center;\r\n  will-change: transform, filter;\r\n  backface-visibility: hidden;\r\n  transform-style: preserve-3d;\r\n  box-shadow: 0 0 30px rgba(0, 0, 0, 0.1);\r\n  height: 20rem;\r\n  width: 100%;\r\n  margin: 30px 0;\r\n  padding: 3rem;\r\n  border-radius: 40px;\r\n  box-sizing: border-box;\r\n  -webkit-transform: translateZ(0);\r\n  transform: translateZ(0);\r\n  position: relative;\r\n}\r\n\r\n.scroll-stack-end {\r\n  width: 100%;\r\n  height: 1px;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}