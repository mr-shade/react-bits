{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Hyperspeed-JS-CSS",
  "type": "registry:block",
  "title": "Hyperspeed",
  "description": "Animated lines continously moving to simulate hyperspace travel on click hold.",
  "dependencies": [
    "postprocessing",
    "three"
  ],
  "files": [
    {
      "path": "public/default/src/content/Backgrounds/Hyperspeed/Hyperspeed.jsx",
      "content": "import { useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { BloomEffect, EffectComposer, EffectPass, RenderPass, SMAAEffect, SMAAPreset } from 'postprocessing';\r\n\r\nimport './Hyperspeed.css';\r\n\r\nconst Hyperspeed = ({\r\n  effectOptions = {\r\n    onSpeedUp: () => {},\r\n    onSlowDown: () => {},\r\n    distortion: 'turbulentDistortion',\r\n    length: 400,\r\n    roadWidth: 10,\r\n    islandWidth: 2,\r\n    lanesPerRoad: 4,\r\n    fov: 90,\r\n    fovSpeedUp: 150,\r\n    speedUp: 2,\r\n    carLightsFade: 0.4,\r\n    totalSideLightSticks: 20,\r\n    lightPairsPerRoadWay: 40,\r\n    shoulderLinesWidthPercentage: 0.05,\r\n    brokenLinesWidthPercentage: 0.1,\r\n    brokenLinesLengthPercentage: 0.5,\r\n    lightStickWidth: [0.12, 0.5],\r\n    lightStickHeight: [1.3, 1.7],\r\n    movingAwaySpeed: [60, 80],\r\n    movingCloserSpeed: [-120, -160],\r\n    carLightsLength: [400 * 0.03, 400 * 0.2],\r\n    carLightsRadius: [0.05, 0.14],\r\n    carWidthPercentage: [0.3, 0.5],\r\n    carShiftX: [-0.8, 0.8],\r\n    carFloorSeparation: [0, 5],\r\n    colors: {\r\n      roadColor: 0x080808,\r\n      islandColor: 0x0a0a0a,\r\n      background: 0x000000,\r\n      shoulderLines: 0xffffff,\r\n      brokenLines: 0xffffff,\r\n      leftCars: [0xd856bf, 0x6750a2, 0xc247ac],\r\n      rightCars: [0x03b3c3, 0x0e5ea5, 0x324555],\r\n      sticks: 0x03b3c3\r\n    }\r\n  }\r\n}) => {\r\n  const hyperspeed = useRef(null);\r\n  const appRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (appRef.current) {\r\n      appRef.current.dispose();\r\n      const container = document.getElementById('lights');\r\n      if (container) {\r\n        while (container.firstChild) {\r\n          container.removeChild(container.firstChild);\r\n        }\r\n      }\r\n    }\r\n    const mountainUniforms = {\r\n      uFreq: { value: new THREE.Vector3(3, 6, 10) },\r\n      uAmp: { value: new THREE.Vector3(30, 30, 20) }\r\n    };\r\n\r\n    const xyUniforms = {\r\n      uFreq: { value: new THREE.Vector2(5, 2) },\r\n      uAmp: { value: new THREE.Vector2(25, 15) }\r\n    };\r\n\r\n    const LongRaceUniforms = {\r\n      uFreq: { value: new THREE.Vector2(2, 3) },\r\n      uAmp: { value: new THREE.Vector2(35, 10) }\r\n    };\r\n\r\n    const turbulentUniforms = {\r\n      uFreq: { value: new THREE.Vector4(4, 8, 8, 1) },\r\n      uAmp: { value: new THREE.Vector4(25, 5, 10, 10) }\r\n    };\r\n\r\n    const deepUniforms = {\r\n      uFreq: { value: new THREE.Vector2(4, 8) },\r\n      uAmp: { value: new THREE.Vector2(10, 20) },\r\n      uPowY: { value: new THREE.Vector2(20, 2) }\r\n    };\r\n\r\n    let nsin = val => Math.sin(val) * 0.5 + 0.5;\r\n\r\n    const distortions = {\r\n      mountainDistortion: {\r\n        uniforms: mountainUniforms,\r\n        getDistortion: `\r\n          uniform vec3 uAmp;\r\n          uniform vec3 uFreq;\r\n          #define PI 3.14159265358979\r\n          float nsin(float val){\r\n            return sin(val) * 0.5 + 0.5;\r\n          }\r\n          vec3 getDistortion(float progress){\r\n            float movementProgressFix = 0.02;\r\n            return vec3( \r\n              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\r\n              nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\r\n              nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\r\n            );\r\n          }\r\n        `,\r\n        getJS: (progress, time) => {\r\n          let movementProgressFix = 0.02;\r\n          let uFreq = mountainUniforms.uFreq.value;\r\n          let uAmp = mountainUniforms.uAmp.value;\r\n          let distortion = new THREE.Vector3(\r\n            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n              Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\r\n            nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\r\n              nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\r\n            nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\r\n              nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\r\n          );\r\n          let lookAtAmp = new THREE.Vector3(2, 2, 2);\r\n          let lookAtOffset = new THREE.Vector3(0, 0, -5);\r\n          return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n        }\r\n      },\r\n      xyDistortion: {\r\n        uniforms: xyUniforms,\r\n        getDistortion: `\r\n          uniform vec2 uFreq;\r\n          uniform vec2 uAmp;\r\n          #define PI 3.14159265358979\r\n          vec3 getDistortion(float progress){\r\n            float movementProgressFix = 0.02;\r\n            return vec3( \r\n              cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\r\n              sin(progress * PI * uFreq.y + PI/2. + uTime) * uAmp.y - sin(movementProgressFix * PI * uFreq.y + PI/2. + uTime) * uAmp.y,\r\n              0.\r\n            );\r\n          }\r\n        `,\r\n        getJS: (progress, time) => {\r\n          let movementProgressFix = 0.02;\r\n          let uFreq = xyUniforms.uFreq.value;\r\n          let uAmp = xyUniforms.uAmp.value;\r\n          let distortion = new THREE.Vector3(\r\n            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n              Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\r\n            Math.sin(progress * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y -\r\n              Math.sin(movementProgressFix * Math.PI * uFreq.y + time + Math.PI / 2) * uAmp.y,\r\n            0\r\n          );\r\n          let lookAtAmp = new THREE.Vector3(2, 0.4, 1);\r\n          let lookAtOffset = new THREE.Vector3(0, 0, -3);\r\n          return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n        }\r\n      },\r\n      LongRaceDistortion: {\r\n        uniforms: LongRaceUniforms,\r\n        getDistortion: `\r\n          uniform vec2 uFreq;\r\n          uniform vec2 uAmp;\r\n          #define PI 3.14159265358979\r\n          vec3 getDistortion(float progress){\r\n            float camProgress = 0.0125;\r\n            return vec3( \r\n              sin(progress * PI * uFreq.x + uTime) * uAmp.x - sin(camProgress * PI * uFreq.x + uTime) * uAmp.x,\r\n              sin(progress * PI * uFreq.y + uTime) * uAmp.y - sin(camProgress * PI * uFreq.y + uTime) * uAmp.y,\r\n              0.\r\n            );\r\n          }\r\n        `,\r\n        getJS: (progress, time) => {\r\n          let camProgress = 0.0125;\r\n          let uFreq = LongRaceUniforms.uFreq.value;\r\n          let uAmp = LongRaceUniforms.uAmp.value;\r\n          let distortion = new THREE.Vector3(\r\n            Math.sin(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n              Math.sin(camProgress * Math.PI * uFreq.x + time) * uAmp.x,\r\n            Math.sin(progress * Math.PI * uFreq.y + time) * uAmp.y -\r\n              Math.sin(camProgress * Math.PI * uFreq.y + time) * uAmp.y,\r\n            0\r\n          );\r\n          let lookAtAmp = new THREE.Vector3(1, 1, 0);\r\n          let lookAtOffset = new THREE.Vector3(0, 0, -5);\r\n          return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n        }\r\n      },\r\n      turbulentDistortion: {\r\n        uniforms: turbulentUniforms,\r\n        getDistortion: `\r\n          uniform vec4 uFreq;\r\n          uniform vec4 uAmp;\r\n          float nsin(float val){\r\n            return sin(val) * 0.5 + 0.5;\r\n          }\r\n          #define PI 3.14159265358979\r\n          float getDistortionX(float progress){\r\n            return (\r\n              cos(PI * progress * uFreq.r + uTime) * uAmp.r +\r\n              pow(cos(PI * progress * uFreq.g + uTime * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\r\n            );\r\n          }\r\n          float getDistortionY(float progress){\r\n            return (\r\n              -nsin(PI * progress * uFreq.b + uTime) * uAmp.b +\r\n              -pow(nsin(PI * progress * uFreq.a + uTime / (uFreq.b / uFreq.a)), 5.) * uAmp.a\r\n            );\r\n          }\r\n          vec3 getDistortion(float progress){\r\n            return vec3(\r\n              getDistortionX(progress) - getDistortionX(0.0125),\r\n              getDistortionY(progress) - getDistortionY(0.0125),\r\n              0.\r\n            );\r\n          }\r\n        `,\r\n        getJS: (progress, time) => {\r\n          const uFreq = turbulentUniforms.uFreq.value;\r\n          const uAmp = turbulentUniforms.uAmp.value;\r\n\r\n          const getX = p =>\r\n            Math.cos(Math.PI * p * uFreq.x + time) * uAmp.x +\r\n            Math.pow(Math.cos(Math.PI * p * uFreq.y + time * (uFreq.y / uFreq.x)), 2) * uAmp.y;\r\n\r\n          const getY = p =>\r\n            -nsin(Math.PI * p * uFreq.z + time) * uAmp.z -\r\n            Math.pow(nsin(Math.PI * p * uFreq.w + time / (uFreq.z / uFreq.w)), 5) * uAmp.w;\r\n\r\n          let distortion = new THREE.Vector3(\r\n            getX(progress) - getX(progress + 0.007),\r\n            getY(progress) - getY(progress + 0.007),\r\n            0\r\n          );\r\n          let lookAtAmp = new THREE.Vector3(-2, -5, 0);\r\n          let lookAtOffset = new THREE.Vector3(0, 0, -10);\r\n          return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n        }\r\n      },\r\n      turbulentDistortionStill: {\r\n        uniforms: turbulentUniforms,\r\n        getDistortion: `\r\n          uniform vec4 uFreq;\r\n          uniform vec4 uAmp;\r\n          float nsin(float val){\r\n            return sin(val) * 0.5 + 0.5;\r\n          }\r\n          #define PI 3.14159265358979\r\n          float getDistortionX(float progress){\r\n            return (\r\n              cos(PI * progress * uFreq.r) * uAmp.r +\r\n              pow(cos(PI * progress * uFreq.g * (uFreq.g / uFreq.r)), 2. ) * uAmp.g\r\n            );\r\n          }\r\n          float getDistortionY(float progress){\r\n            return (\r\n              -nsin(PI * progress * uFreq.b) * uAmp.b +\r\n              -pow(nsin(PI * progress * uFreq.a / (uFreq.b / uFreq.a)), 5.) * uAmp.a\r\n            );\r\n          }\r\n          vec3 getDistortion(float progress){\r\n            return vec3(\r\n              getDistortionX(progress) - getDistortionX(0.02),\r\n              getDistortionY(progress) - getDistortionY(0.02),\r\n              0.\r\n            );\r\n          }\r\n        `\r\n      },\r\n      deepDistortionStill: {\r\n        uniforms: deepUniforms,\r\n        getDistortion: `\r\n          uniform vec4 uFreq;\r\n          uniform vec4 uAmp;\r\n          uniform vec2 uPowY;\r\n          float nsin(float val){\r\n            return sin(val) * 0.5 + 0.5;\r\n          }\r\n          #define PI 3.14159265358979\r\n          float getDistortionX(float progress){\r\n            return (\r\n              sin(progress * PI * uFreq.x) * uAmp.x * 2.\r\n            );\r\n          }\r\n          float getDistortionY(float progress){\r\n            return (\r\n              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y) * uAmp.y\r\n            );\r\n          }\r\n          vec3 getDistortion(float progress){\r\n            return vec3(\r\n              getDistortionX(progress) - getDistortionX(0.02),\r\n              getDistortionY(progress) - getDistortionY(0.05),\r\n              0.\r\n            );\r\n          }\r\n        `\r\n      },\r\n      deepDistortion: {\r\n        uniforms: deepUniforms,\r\n        getDistortion: `\r\n          uniform vec4 uFreq;\r\n          uniform vec4 uAmp;\r\n          uniform vec2 uPowY;\r\n          float nsin(float val){\r\n            return sin(val) * 0.5 + 0.5;\r\n          }\r\n          #define PI 3.14159265358979\r\n          float getDistortionX(float progress){\r\n            return (\r\n              sin(progress * PI * uFreq.x + uTime) * uAmp.x\r\n            );\r\n          }\r\n          float getDistortionY(float progress){\r\n            return (\r\n              pow(abs(progress * uPowY.x), uPowY.y) + sin(progress * PI * uFreq.y + uTime) * uAmp.y\r\n            );\r\n          }\r\n          vec3 getDistortion(float progress){\r\n            return vec3(\r\n              getDistortionX(progress) - getDistortionX(0.02),\r\n              getDistortionY(progress) - getDistortionY(0.02),\r\n              0.\r\n            );\r\n          }\r\n        `,\r\n        getJS: (progress, time) => {\r\n          const uFreq = deepUniforms.uFreq.value;\r\n          const uAmp = deepUniforms.uAmp.value;\r\n          const uPowY = deepUniforms.uPowY.value;\r\n\r\n          const getX = p => Math.sin(p * Math.PI * uFreq.x + time) * uAmp.x;\r\n          const getY = p => Math.pow(p * uPowY.x, uPowY.y) + Math.sin(p * Math.PI * uFreq.y + time) * uAmp.y;\r\n\r\n          let distortion = new THREE.Vector3(\r\n            getX(progress) - getX(progress + 0.01),\r\n            getY(progress) - getY(progress + 0.01),\r\n            0\r\n          );\r\n          let lookAtAmp = new THREE.Vector3(-2, -4, 0);\r\n          let lookAtOffset = new THREE.Vector3(0, 0, -10);\r\n          return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n        }\r\n      }\r\n    };\r\n\r\n    class App {\r\n      constructor(container, options = {}) {\r\n        this.options = options;\r\n        if (this.options.distortion == null) {\r\n          this.options.distortion = {\r\n            uniforms: distortion_uniforms,\r\n            getDistortion: distortion_vertex\r\n          };\r\n        }\r\n        this.container = container;\r\n        this.renderer = new THREE.WebGLRenderer({\r\n          antialias: false,\r\n          alpha: true\r\n        });\r\n        this.renderer.setSize(container.offsetWidth, container.offsetHeight, false);\r\n        this.renderer.setPixelRatio(window.devicePixelRatio);\r\n        this.composer = new EffectComposer(this.renderer);\r\n        container.append(this.renderer.domElement);\r\n\r\n        this.camera = new THREE.PerspectiveCamera(\r\n          options.fov,\r\n          container.offsetWidth / container.offsetHeight,\r\n          0.1,\r\n          10000\r\n        );\r\n        this.camera.position.z = -5;\r\n        this.camera.position.y = 8;\r\n        this.camera.position.x = 0;\r\n        this.scene = new THREE.Scene();\r\n        this.scene.background = null;\r\n\r\n        let fog = new THREE.Fog(options.colors.background, options.length * 0.2, options.length * 500);\r\n        this.scene.fog = fog;\r\n        this.fogUniforms = {\r\n          fogColor: { value: fog.color },\r\n          fogNear: { value: fog.near },\r\n          fogFar: { value: fog.far }\r\n        };\r\n        this.clock = new THREE.Clock();\r\n        this.assets = {};\r\n        this.disposed = false;\r\n\r\n        this.road = new Road(this, options);\r\n        this.leftCarLights = new CarLights(\r\n          this,\r\n          options,\r\n          options.colors.leftCars,\r\n          options.movingAwaySpeed,\r\n          new THREE.Vector2(0, 1 - options.carLightsFade)\r\n        );\r\n        this.rightCarLights = new CarLights(\r\n          this,\r\n          options,\r\n          options.colors.rightCars,\r\n          options.movingCloserSpeed,\r\n          new THREE.Vector2(1, 0 + options.carLightsFade)\r\n        );\r\n        this.leftSticks = new LightsSticks(this, options);\r\n\r\n        this.fovTarget = options.fov;\r\n        this.speedUpTarget = 0;\r\n        this.speedUp = 0;\r\n        this.timeOffset = 0;\r\n\r\n        this.tick = this.tick.bind(this);\r\n        this.init = this.init.bind(this);\r\n        this.setSize = this.setSize.bind(this);\r\n        this.onMouseDown = this.onMouseDown.bind(this);\r\n        this.onMouseUp = this.onMouseUp.bind(this);\r\n\r\n        this.onTouchStart = this.onTouchStart.bind(this);\r\n        this.onTouchEnd = this.onTouchEnd.bind(this);\r\n        this.onContextMenu = this.onContextMenu.bind(this);\r\n\r\n        window.addEventListener('resize', this.onWindowResize.bind(this));\r\n      }\r\n\r\n      onWindowResize() {\r\n        const width = this.container.offsetWidth;\r\n        const height = this.container.offsetHeight;\r\n\r\n        this.renderer.setSize(width, height);\r\n        this.camera.aspect = width / height;\r\n        this.camera.updateProjectionMatrix();\r\n        this.composer.setSize(width, height);\r\n      }\r\n\r\n      initPasses() {\r\n        this.renderPass = new RenderPass(this.scene, this.camera);\r\n        this.bloomPass = new EffectPass(\r\n          this.camera,\r\n          new BloomEffect({\r\n            luminanceThreshold: 0.2,\r\n            luminanceSmoothing: 0,\r\n            resolutionScale: 1\r\n          })\r\n        );\r\n\r\n        const smaaPass = new EffectPass(\r\n          this.camera,\r\n          new SMAAEffect({\r\n            preset: SMAAPreset.MEDIUM,\r\n            searchImage: SMAAEffect.searchImageDataURL,\r\n            areaImage: SMAAEffect.areaImageDataURL\r\n          })\r\n        );\r\n        this.renderPass.renderToScreen = false;\r\n        this.bloomPass.renderToScreen = false;\r\n        smaaPass.renderToScreen = true;\r\n        this.composer.addPass(this.renderPass);\r\n        this.composer.addPass(this.bloomPass);\r\n        this.composer.addPass(smaaPass);\r\n      }\r\n\r\n      loadAssets() {\r\n        const assets = this.assets;\r\n        return new Promise(resolve => {\r\n          const manager = new THREE.LoadingManager(resolve);\r\n\r\n          const searchImage = new Image();\r\n          const areaImage = new Image();\r\n          assets.smaa = {};\r\n          searchImage.addEventListener('load', function () {\r\n            assets.smaa.search = this;\r\n            manager.itemEnd('smaa-search');\r\n          });\r\n\r\n          areaImage.addEventListener('load', function () {\r\n            assets.smaa.area = this;\r\n            manager.itemEnd('smaa-area');\r\n          });\r\n          manager.itemStart('smaa-search');\r\n          manager.itemStart('smaa-area');\r\n\r\n          searchImage.src = SMAAEffect.searchImageDataURL;\r\n          areaImage.src = SMAAEffect.areaImageDataURL;\r\n        });\r\n      }\r\n\r\n      init() {\r\n        this.initPasses();\r\n        const options = this.options;\r\n        this.road.init();\r\n        this.leftCarLights.init();\r\n\r\n        this.leftCarLights.mesh.position.setX(-options.roadWidth / 2 - options.islandWidth / 2);\r\n        this.rightCarLights.init();\r\n        this.rightCarLights.mesh.position.setX(options.roadWidth / 2 + options.islandWidth / 2);\r\n        this.leftSticks.init();\r\n        this.leftSticks.mesh.position.setX(-(options.roadWidth + options.islandWidth / 2));\r\n\r\n        this.container.addEventListener('mousedown', this.onMouseDown);\r\n        this.container.addEventListener('mouseup', this.onMouseUp);\r\n        this.container.addEventListener('mouseout', this.onMouseUp);\r\n\r\n        this.container.addEventListener('touchstart', this.onTouchStart, { passive: true });\r\n        this.container.addEventListener('touchend', this.onTouchEnd, { passive: true });\r\n        this.container.addEventListener('touchcancel', this.onTouchEnd, { passive: true });\r\n\r\n        this.container.addEventListener('contextmenu', this.onContextMenu);\r\n\r\n        this.tick();\r\n      }\r\n\r\n      onMouseDown(ev) {\r\n        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\r\n        this.fovTarget = this.options.fovSpeedUp;\r\n        this.speedUpTarget = this.options.speedUp;\r\n      }\r\n\r\n      onMouseUp(ev) {\r\n        if (this.options.onSlowDown) this.options.onSlowDown(ev);\r\n        this.fovTarget = this.options.fov;\r\n        this.speedUpTarget = 0;\r\n      }\r\n\r\n      onTouchStart(ev) {\r\n        if (this.options.onSpeedUp) this.options.onSpeedUp(ev);\r\n        this.fovTarget = this.options.fovSpeedUp;\r\n        this.speedUpTarget = this.options.speedUp;\r\n      }\r\n\r\n      onTouchEnd(ev) {\r\n        if (this.options.onSlowDown) this.options.onSlowDown(ev);\r\n        this.fovTarget = this.options.fov;\r\n        this.speedUpTarget = 0;\r\n      }\r\n\r\n      onContextMenu(ev) {\r\n        ev.preventDefault();\r\n      }\r\n\r\n      update(delta) {\r\n        let lerpPercentage = Math.exp(-(-60 * Math.log2(1 - 0.1)) * delta);\r\n        this.speedUp += lerp(this.speedUp, this.speedUpTarget, lerpPercentage, 0.00001);\r\n        this.timeOffset += this.speedUp * delta;\r\n\r\n        let time = this.clock.elapsedTime + this.timeOffset;\r\n\r\n        this.rightCarLights.update(time);\r\n        this.leftCarLights.update(time);\r\n        this.leftSticks.update(time);\r\n        this.road.update(time);\r\n\r\n        let updateCamera = false;\r\n        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpPercentage);\r\n        if (fovChange !== 0) {\r\n          this.camera.fov += fovChange * delta * 6;\r\n          updateCamera = true;\r\n        }\r\n\r\n        if (this.options.distortion.getJS) {\r\n          const distortion = this.options.distortion.getJS(0.025, time);\r\n\r\n          this.camera.lookAt(\r\n            new THREE.Vector3(\r\n              this.camera.position.x + distortion.x,\r\n              this.camera.position.y + distortion.y,\r\n              this.camera.position.z + distortion.z\r\n            )\r\n          );\r\n          updateCamera = true;\r\n        }\r\n        if (updateCamera) {\r\n          this.camera.updateProjectionMatrix();\r\n        }\r\n\r\n        if (this.options.isHyper) {\r\n          console.log(this.options.isHyper);\r\n        }\r\n      }\r\n\r\n      render(delta) {\r\n        this.composer.render(delta);\r\n      }\r\n\r\n      dispose() {\r\n        this.disposed = true;\r\n\r\n        if (this.renderer) {\r\n          this.renderer.dispose();\r\n        }\r\n        if (this.composer) {\r\n          this.composer.dispose();\r\n        }\r\n        if (this.scene) {\r\n          this.scene.clear();\r\n        }\r\n\r\n        window.removeEventListener('resize', this.onWindowResize.bind(this));\r\n        if (this.container) {\r\n          this.container.removeEventListener('mousedown', this.onMouseDown);\r\n          this.container.removeEventListener('mouseup', this.onMouseUp);\r\n          this.container.removeEventListener('mouseout', this.onMouseUp);\r\n\r\n          this.container.removeEventListener('touchstart', this.onTouchStart);\r\n          this.container.removeEventListener('touchend', this.onTouchEnd);\r\n          this.container.removeEventListener('touchcancel', this.onTouchEnd);\r\n          this.container.removeEventListener('contextmenu', this.onContextMenu);\r\n        }\r\n      }\r\n\r\n      setSize(width, height, updateStyles) {\r\n        this.composer.setSize(width, height, updateStyles);\r\n      }\r\n\r\n      tick() {\r\n        if (this.disposed || !this) return;\r\n        if (resizeRendererToDisplaySize(this.renderer, this.setSize)) {\r\n          const canvas = this.renderer.domElement;\r\n          this.camera.aspect = canvas.clientWidth / canvas.clientHeight;\r\n          this.camera.updateProjectionMatrix();\r\n        }\r\n        const delta = this.clock.getDelta();\r\n        this.render(delta);\r\n        this.update(delta);\r\n        requestAnimationFrame(this.tick);\r\n      }\r\n    }\r\n\r\n    const distortion_uniforms = {\r\n      uDistortionX: { value: new THREE.Vector2(80, 3) },\r\n      uDistortionY: { value: new THREE.Vector2(-40, 2.5) }\r\n    };\r\n\r\n    const distortion_vertex = `\r\n      #define PI 3.14159265358979\r\n      uniform vec2 uDistortionX;\r\n      uniform vec2 uDistortionY;\r\n      float nsin(float val){\r\n        return sin(val) * 0.5 + 0.5;\r\n      }\r\n      vec3 getDistortion(float progress){\r\n        progress = clamp(progress, 0., 1.);\r\n        float xAmp = uDistortionX.r;\r\n        float xFreq = uDistortionX.g;\r\n        float yAmp = uDistortionY.r;\r\n        float yFreq = uDistortionY.g;\r\n        return vec3( \r\n          xAmp * nsin(progress * PI * xFreq - PI / 2.),\r\n          yAmp * nsin(progress * PI * yFreq - PI / 2.),\r\n          0.\r\n        );\r\n      }\r\n    `;\r\n\r\n    const random = base => {\r\n      if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];\r\n      return Math.random() * base;\r\n    };\r\n\r\n    const pickRandom = arr => {\r\n      if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\r\n      return arr;\r\n    };\r\n\r\n    function lerp(current, target, speed = 0.1, limit = 0.001) {\r\n      let change = (target - current) * speed;\r\n      if (Math.abs(change) < limit) {\r\n        change = target - current;\r\n      }\r\n      return change;\r\n    }\r\n\r\n    class CarLights {\r\n      constructor(webgl, options, colors, speed, fade) {\r\n        this.webgl = webgl;\r\n        this.options = options;\r\n        this.colors = colors;\r\n        this.speed = speed;\r\n        this.fade = fade;\r\n      }\r\n\r\n      init() {\r\n        const options = this.options;\r\n        let curve = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1));\r\n        let geometry = new THREE.TubeGeometry(curve, 40, 1, 8, false);\r\n\r\n        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\r\n        instanced.instanceCount = options.lightPairsPerRoadWay * 2;\r\n\r\n        let laneWidth = options.roadWidth / options.lanesPerRoad;\r\n\r\n        let aOffset = [];\r\n        let aMetrics = [];\r\n        let aColor = [];\r\n\r\n        let colors = this.colors;\r\n        if (Array.isArray(colors)) {\r\n          colors = colors.map(c => new THREE.Color(c));\r\n        } else {\r\n          colors = new THREE.Color(colors);\r\n        }\r\n\r\n        for (let i = 0; i < options.lightPairsPerRoadWay; i++) {\r\n          let radius = random(options.carLightsRadius);\r\n          let length = random(options.carLightsLength);\r\n          let speed = random(this.speed);\r\n\r\n          let carLane = i % options.lanesPerRoad;\r\n          let laneX = carLane * laneWidth - options.roadWidth / 2 + laneWidth / 2;\r\n\r\n          let carWidth = random(options.carWidthPercentage) * laneWidth;\r\n          let carShiftX = random(options.carShiftX) * laneWidth;\r\n          laneX += carShiftX;\r\n\r\n          let offsetY = random(options.carFloorSeparation) + radius * 1.3;\r\n\r\n          let offsetZ = -random(options.length);\r\n\r\n          aOffset.push(laneX - carWidth / 2);\r\n          aOffset.push(offsetY);\r\n          aOffset.push(offsetZ);\r\n\r\n          aOffset.push(laneX + carWidth / 2);\r\n          aOffset.push(offsetY);\r\n          aOffset.push(offsetZ);\r\n\r\n          aMetrics.push(radius);\r\n          aMetrics.push(length);\r\n          aMetrics.push(speed);\r\n\r\n          aMetrics.push(radius);\r\n          aMetrics.push(length);\r\n          aMetrics.push(speed);\r\n\r\n          let color = pickRandom(colors);\r\n          aColor.push(color.r);\r\n          aColor.push(color.g);\r\n          aColor.push(color.b);\r\n\r\n          aColor.push(color.r);\r\n          aColor.push(color.g);\r\n          aColor.push(color.b);\r\n        }\r\n\r\n        instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false));\r\n        instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 3, false));\r\n        instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));\r\n\r\n        let material = new THREE.ShaderMaterial({\r\n          fragmentShader: carLightsFragment,\r\n          vertexShader: carLightsVertex,\r\n          transparent: true,\r\n          uniforms: Object.assign(\r\n            {\r\n              uTime: { value: 0 },\r\n              uTravelLength: { value: options.length },\r\n              uFade: { value: this.fade }\r\n            },\r\n            this.webgl.fogUniforms,\r\n            options.distortion.uniforms\r\n          )\r\n        });\r\n\r\n        material.onBeforeCompile = shader => {\r\n          shader.vertexShader = shader.vertexShader.replace(\r\n            '#include <getDistortion_vertex>',\r\n            options.distortion.getDistortion\r\n          );\r\n        };\r\n\r\n        let mesh = new THREE.Mesh(instanced, material);\r\n        mesh.frustumCulled = false;\r\n        this.webgl.scene.add(mesh);\r\n        this.mesh = mesh;\r\n      }\r\n\r\n      update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n      }\r\n    }\r\n\r\n    const carLightsFragment = `\r\n      #define USE_FOG;\r\n      ${THREE.ShaderChunk['fog_pars_fragment']}\r\n      varying vec3 vColor;\r\n      varying vec2 vUv; \r\n      uniform vec2 uFade;\r\n      void main() {\r\n        vec3 color = vec3(vColor);\r\n        float alpha = smoothstep(uFade.x, uFade.y, vUv.x);\r\n        gl_FragColor = vec4(color, alpha);\r\n        if (gl_FragColor.a < 0.0001) discard;\r\n        ${THREE.ShaderChunk['fog_fragment']}\r\n      }\r\n    `;\r\n\r\n    const carLightsVertex = `\r\n      #define USE_FOG;\r\n      ${THREE.ShaderChunk['fog_pars_vertex']}\r\n      attribute vec3 aOffset;\r\n      attribute vec3 aMetrics;\r\n      attribute vec3 aColor;\r\n      uniform float uTravelLength;\r\n      uniform float uTime;\r\n      varying vec2 vUv; \r\n      varying vec3 vColor; \r\n      #include <getDistortion_vertex>\r\n      void main() {\r\n        vec3 transformed = position.xyz;\r\n        float radius = aMetrics.r;\r\n        float myLength = aMetrics.g;\r\n        float speed = aMetrics.b;\r\n\r\n        transformed.xy *= radius;\r\n        transformed.z *= myLength;\r\n\r\n        transformed.z += myLength - mod(uTime * speed + aOffset.z, uTravelLength);\r\n        transformed.xy += aOffset.xy;\r\n\r\n        float progress = abs(transformed.z / uTravelLength);\r\n        transformed.xyz += getDistortion(progress);\r\n\r\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n        vUv = uv;\r\n        vColor = aColor;\r\n        ${THREE.ShaderChunk['fog_vertex']}\r\n      }\r\n    `;\r\n\r\n    class LightsSticks {\r\n      constructor(webgl, options) {\r\n        this.webgl = webgl;\r\n        this.options = options;\r\n      }\r\n\r\n      init() {\r\n        const options = this.options;\r\n        const geometry = new THREE.PlaneGeometry(1, 1);\r\n        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\r\n        let totalSticks = options.totalSideLightSticks;\r\n        instanced.instanceCount = totalSticks;\r\n\r\n        let stickoffset = options.length / (totalSticks - 1);\r\n        const aOffset = [];\r\n        const aColor = [];\r\n        const aMetrics = [];\r\n\r\n        let colors = options.colors.sticks;\r\n        if (Array.isArray(colors)) {\r\n          colors = colors.map(c => new THREE.Color(c));\r\n        } else {\r\n          colors = new THREE.Color(colors);\r\n        }\r\n\r\n        for (let i = 0; i < totalSticks; i++) {\r\n          let width = random(options.lightStickWidth);\r\n          let height = random(options.lightStickHeight);\r\n          aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\r\n\r\n          let color = pickRandom(colors);\r\n          aColor.push(color.r);\r\n          aColor.push(color.g);\r\n          aColor.push(color.b);\r\n\r\n          aMetrics.push(width);\r\n          aMetrics.push(height);\r\n        }\r\n\r\n        instanced.setAttribute('aOffset', new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false));\r\n        instanced.setAttribute('aColor', new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false));\r\n        instanced.setAttribute('aMetrics', new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false));\r\n\r\n        const material = new THREE.ShaderMaterial({\r\n          fragmentShader: sideSticksFragment,\r\n          vertexShader: sideSticksVertex,\r\n          side: THREE.DoubleSide,\r\n          uniforms: Object.assign(\r\n            {\r\n              uTravelLength: { value: options.length },\r\n              uTime: { value: 0 }\r\n            },\r\n            this.webgl.fogUniforms,\r\n            options.distortion.uniforms\r\n          )\r\n        });\r\n\r\n        material.onBeforeCompile = shader => {\r\n          shader.vertexShader = shader.vertexShader.replace(\r\n            '#include <getDistortion_vertex>',\r\n            options.distortion.getDistortion\r\n          );\r\n        };\r\n\r\n        const mesh = new THREE.Mesh(instanced, material);\r\n        mesh.frustumCulled = false;\r\n        this.webgl.scene.add(mesh);\r\n        this.mesh = mesh;\r\n      }\r\n\r\n      update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n      }\r\n    }\r\n\r\n    const sideSticksVertex = `\r\n      #define USE_FOG;\r\n      ${THREE.ShaderChunk['fog_pars_vertex']}\r\n      attribute float aOffset;\r\n      attribute vec3 aColor;\r\n      attribute vec2 aMetrics;\r\n      uniform float uTravelLength;\r\n      uniform float uTime;\r\n      varying vec3 vColor;\r\n      mat4 rotationY( in float angle ) {\r\n        return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\r\n                     0,\t\t1.0,\t\t\t 0,\t0,\r\n                -sin(angle),\t0,\t\tcos(angle),\t0,\r\n                0, \t\t0,\t\t\t\t0,\t1);\r\n      }\r\n      #include <getDistortion_vertex>\r\n      void main(){\r\n        vec3 transformed = position.xyz;\r\n        float width = aMetrics.x;\r\n        float height = aMetrics.y;\r\n\r\n        transformed.xy *= vec2(width, height);\r\n        float time = mod(uTime * 60. * 2. + aOffset, uTravelLength);\r\n\r\n        transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\r\n\r\n        transformed.z += - uTravelLength + time;\r\n\r\n        float progress = abs(transformed.z / uTravelLength);\r\n        transformed.xyz += getDistortion(progress);\r\n\r\n        transformed.y += height / 2.;\r\n        transformed.x += -width / 2.;\r\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n        vColor = aColor;\r\n        ${THREE.ShaderChunk['fog_vertex']}\r\n      }\r\n    `;\r\n\r\n    const sideSticksFragment = `\r\n      #define USE_FOG;\r\n      ${THREE.ShaderChunk['fog_pars_fragment']}\r\n      varying vec3 vColor;\r\n      void main(){\r\n        vec3 color = vec3(vColor);\r\n        gl_FragColor = vec4(color,1.);\r\n        ${THREE.ShaderChunk['fog_fragment']}\r\n      }\r\n    `;\r\n\r\n    class Road {\r\n      constructor(webgl, options) {\r\n        this.webgl = webgl;\r\n        this.options = options;\r\n        this.uTime = { value: 0 };\r\n      }\r\n\r\n      createPlane(side, width, isRoad) {\r\n        const options = this.options;\r\n        let segments = 100;\r\n        const geometry = new THREE.PlaneGeometry(\r\n          isRoad ? options.roadWidth : options.islandWidth,\r\n          options.length,\r\n          20,\r\n          segments\r\n        );\r\n        let uniforms = {\r\n          uTravelLength: { value: options.length },\r\n          uColor: { value: new THREE.Color(isRoad ? options.colors.roadColor : options.colors.islandColor) },\r\n          uTime: this.uTime\r\n        };\r\n\r\n        if (isRoad) {\r\n          uniforms = Object.assign(uniforms, {\r\n            uLanes: { value: options.lanesPerRoad },\r\n            uBrokenLinesColor: { value: new THREE.Color(options.colors.brokenLines) },\r\n            uShoulderLinesColor: { value: new THREE.Color(options.colors.shoulderLines) },\r\n            uShoulderLinesWidthPercentage: { value: options.shoulderLinesWidthPercentage },\r\n            uBrokenLinesLengthPercentage: { value: options.brokenLinesLengthPercentage },\r\n            uBrokenLinesWidthPercentage: { value: options.brokenLinesWidthPercentage }\r\n          });\r\n        }\r\n\r\n        const material = new THREE.ShaderMaterial({\r\n          fragmentShader: isRoad ? roadFragment : islandFragment,\r\n          vertexShader: roadVertex,\r\n          side: THREE.DoubleSide,\r\n          uniforms: Object.assign(uniforms, this.webgl.fogUniforms, options.distortion.uniforms)\r\n        });\r\n\r\n        material.onBeforeCompile = shader => {\r\n          shader.vertexShader = shader.vertexShader.replace(\r\n            '#include <getDistortion_vertex>',\r\n            options.distortion.getDistortion\r\n          );\r\n        };\r\n\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n        mesh.rotation.x = -Math.PI / 2;\r\n        mesh.position.z = -options.length / 2;\r\n        mesh.position.x += (this.options.islandWidth / 2 + options.roadWidth / 2) * side;\r\n        this.webgl.scene.add(mesh);\r\n\r\n        return mesh;\r\n      }\r\n\r\n      init() {\r\n        this.leftRoadWay = this.createPlane(-1, this.options.roadWidth, true);\r\n        this.rightRoadWay = this.createPlane(1, this.options.roadWidth, true);\r\n        this.island = this.createPlane(0, this.options.islandWidth, false);\r\n      }\r\n\r\n      update(time) {\r\n        this.uTime.value = time;\r\n      }\r\n    }\r\n\r\n    const roadBaseFragment = `\r\n      #define USE_FOG;\r\n      varying vec2 vUv; \r\n      uniform vec3 uColor;\r\n      uniform float uTime;\r\n      #include <roadMarkings_vars>\r\n      ${THREE.ShaderChunk['fog_pars_fragment']}\r\n      void main() {\r\n        vec2 uv = vUv;\r\n        vec3 color = vec3(uColor);\r\n        #include <roadMarkings_fragment>\r\n        gl_FragColor = vec4(color, 1.);\r\n        ${THREE.ShaderChunk['fog_fragment']}\r\n      }\r\n    `;\r\n\r\n    const islandFragment = roadBaseFragment\r\n      .replace('#include <roadMarkings_fragment>', '')\r\n      .replace('#include <roadMarkings_vars>', '');\r\n\r\n    const roadMarkings_vars = `\r\n      uniform float uLanes;\r\n      uniform vec3 uBrokenLinesColor;\r\n      uniform vec3 uShoulderLinesColor;\r\n      uniform float uShoulderLinesWidthPercentage;\r\n      uniform float uBrokenLinesWidthPercentage;\r\n      uniform float uBrokenLinesLengthPercentage;\r\n      highp float random(vec2 co) {\r\n        highp float a = 12.9898;\r\n        highp float b = 78.233;\r\n        highp float c = 43758.5453;\r\n        highp float dt = dot(co.xy, vec2(a, b));\r\n        highp float sn = mod(dt, 3.14);\r\n        return fract(sin(sn) * c);\r\n      }\r\n    `;\r\n\r\n    const roadMarkings_fragment = `\r\n      uv.y = mod(uv.y + uTime * 0.05, 1.);\r\n      float laneWidth = 1.0 / uLanes;\r\n      float brokenLineWidth = laneWidth * uBrokenLinesWidthPercentage;\r\n      float laneEmptySpace = 1. - uBrokenLinesLengthPercentage;\r\n\r\n      float brokenLines = step(1.0 - brokenLineWidth, fract(uv.x * 2.0)) * step(laneEmptySpace, fract(uv.y * 10.0));\r\n      float sideLines = step(1.0 - brokenLineWidth, fract((uv.x - laneWidth * (uLanes - 1.0)) * 2.0)) + step(brokenLineWidth, uv.x);\r\n\r\n      brokenLines = mix(brokenLines, sideLines, uv.x);\r\n    `;\r\n\r\n    const roadFragment = roadBaseFragment\r\n      .replace('#include <roadMarkings_fragment>', roadMarkings_fragment)\r\n      .replace('#include <roadMarkings_vars>', roadMarkings_vars);\r\n\r\n    const roadVertex = `\r\n      #define USE_FOG;\r\n      uniform float uTime;\r\n      ${THREE.ShaderChunk['fog_pars_vertex']}\r\n      uniform float uTravelLength;\r\n      varying vec2 vUv; \r\n      #include <getDistortion_vertex>\r\n      void main() {\r\n        vec3 transformed = position.xyz;\r\n        vec3 distortion = getDistortion((transformed.y + uTravelLength / 2.) / uTravelLength);\r\n        transformed.x += distortion.x;\r\n        transformed.z += distortion.y;\r\n        transformed.y += -1. * distortion.z;  \r\n        \r\n        vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.);\r\n        gl_Position = projectionMatrix * mvPosition;\r\n        vUv = uv;\r\n        ${THREE.ShaderChunk['fog_vertex']}\r\n      }\r\n    `;\r\n\r\n    function resizeRendererToDisplaySize(renderer, setSize) {\r\n      const canvas = renderer.domElement;\r\n      const width = canvas.clientWidth;\r\n      const height = canvas.clientHeight;\r\n      const needResize = canvas.width !== width || canvas.height !== height;\r\n      if (needResize) {\r\n        setSize(width, height, false);\r\n      }\r\n      return needResize;\r\n    }\r\n\r\n    (function () {\r\n      const container = document.getElementById('lights');\r\n      const options = { ...effectOptions };\r\n      options.distortion = distortions[options.distortion];\r\n\r\n      const myApp = new App(container, options);\r\n      appRef.current = myApp;\r\n      myApp.loadAssets().then(myApp.init);\r\n    })();\r\n\r\n    return () => {\r\n      if (appRef.current) {\r\n        appRef.current.dispose();\r\n      }\r\n    };\r\n  }, [effectOptions]);\r\n\r\n  return <div id=\"lights\" ref={hyperspeed}></div>;\r\n};\r\n\r\nexport default Hyperspeed;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Backgrounds/Hyperspeed/Hyperspeed.css",
      "content": "#lights {\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: hidden;\r\n  position: absolute;\r\n}\r\n\r\ncanvas {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}