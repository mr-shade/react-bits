{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "GradientBlinds-TS-TW",
  "type": "registry:block",
  "title": "GradientBlinds",
  "description": "Layered gradient blinds with spotlight and noise distortion.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/GradientBlinds/GradientBlinds.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\nimport { Renderer, Program, Mesh, Triangle } from 'ogl';\r\n\r\nexport interface GradientBlindsProps {\r\n  className?: string;\r\n  dpr?: number;\r\n  paused?: boolean;\r\n  gradientColors?: string[];\r\n  angle?: number;\r\n  noise?: number;\r\n  blindCount?: number;\r\n  blindMinWidth?: number;\r\n  mouseDampening?: number;\r\n  mirrorGradient?: boolean;\r\n  spotlightRadius?: number;\r\n  spotlightSoftness?: number;\r\n  spotlightOpacity?: number;\r\n  distortAmount?: number;\r\n  shineDirection?: 'left' | 'right';\r\n  mixBlendMode?: string;\r\n}\r\n\r\nconst MAX_COLORS = 8;\r\nconst hexToRGB = (hex: string): [number, number, number] => {\r\n  const c = hex.replace('#', '').padEnd(6, '0');\r\n  const r = parseInt(c.slice(0, 2), 16) / 255;\r\n  const g = parseInt(c.slice(2, 4), 16) / 255;\r\n  const b = parseInt(c.slice(4, 6), 16) / 255;\r\n  return [r, g, b];\r\n};\r\nconst prepStops = (stops?: string[]) => {\r\n  const base = (stops && stops.length ? stops : ['#FF9FFC', '#5227FF']).slice(0, MAX_COLORS);\r\n  if (base.length === 1) base.push(base[0]);\r\n  while (base.length < MAX_COLORS) base.push(base[base.length - 1]);\r\n  const arr: [number, number, number][] = [];\r\n  for (let i = 0; i < MAX_COLORS; i++) arr.push(hexToRGB(base[i]));\r\n  const count = Math.max(2, Math.min(MAX_COLORS, stops?.length ?? 2));\r\n  return { arr, count };\r\n};\r\n\r\nconst GradientBlinds: React.FC<GradientBlindsProps> = ({\r\n  className,\r\n  dpr,\r\n  paused = false,\r\n  gradientColors,\r\n  angle = 0,\r\n  noise = 0.3,\r\n  blindCount = 16,\r\n  blindMinWidth = 60,\r\n  mouseDampening = 0.15,\r\n  mirrorGradient = false,\r\n  spotlightRadius = 0.5,\r\n  spotlightSoftness = 1,\r\n  spotlightOpacity = 1,\r\n  distortAmount = 0,\r\n  shineDirection = 'left',\r\n  mixBlendMode = 'lighten'\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const rafRef = useRef<number | null>(null);\r\n  const programRef = useRef<Program | null>(null);\r\n  const meshRef = useRef<Mesh<Triangle> | null>(null);\r\n  const geometryRef = useRef<Triangle | null>(null);\r\n  const rendererRef = useRef<Renderer | null>(null);\r\n  const mouseTargetRef = useRef<[number, number]>([0, 0]);\r\n  const lastTimeRef = useRef<number>(0);\r\n  const firstResizeRef = useRef<boolean>(true);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const renderer = new Renderer({\r\n      dpr: dpr ?? (typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1),\r\n      alpha: true,\r\n      antialias: true\r\n    });\r\n    rendererRef.current = renderer;\r\n    const gl = renderer.gl;\r\n    const canvas = gl.canvas as HTMLCanvasElement;\r\n\r\n    canvas.style.width = '100%';\r\n    canvas.style.height = '100%';\r\n    canvas.style.display = 'block';\r\n    container.appendChild(canvas);\r\n\r\n    const vertex = `\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n`;\r\n\r\n    const fragment = `\r\n#ifdef GL_ES\r\nprecision mediump float;\r\n#endif\r\n\r\nuniform vec3  iResolution;\r\nuniform vec2  iMouse;\r\nuniform float iTime;\r\n\r\nuniform float uAngle;\r\nuniform float uNoise;\r\nuniform float uBlindCount;\r\nuniform float uSpotlightRadius;\r\nuniform float uSpotlightSoftness;\r\nuniform float uSpotlightOpacity;\r\nuniform float uMirror;\r\nuniform float uDistort;\r\nuniform float uShineFlip;\r\nuniform vec3  uColor0;\r\nuniform vec3  uColor1;\r\nuniform vec3  uColor2;\r\nuniform vec3  uColor3;\r\nuniform vec3  uColor4;\r\nuniform vec3  uColor5;\r\nuniform vec3  uColor6;\r\nuniform vec3  uColor7;\r\nuniform int   uColorCount;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat rand(vec2 co){\r\n  return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);\r\n}\r\n\r\nvec2 rotate2D(vec2 p, float a){\r\n  float c = cos(a);\r\n  float s = sin(a);\r\n  return mat2(c, -s, s, c) * p;\r\n}\r\n\r\nvec3 getGradientColor(float t){\r\n  float tt = clamp(t, 0.0, 1.0);\r\n  int count = uColorCount;\r\n  if (count < 2) count = 2;\r\n  float scaled = tt * float(count - 1);\r\n  float seg = floor(scaled);\r\n  float f = fract(scaled);\r\n\r\n  if (seg < 1.0) return mix(uColor0, uColor1, f);\r\n  if (seg < 2.0 && count > 2) return mix(uColor1, uColor2, f);\r\n  if (seg < 3.0 && count > 3) return mix(uColor2, uColor3, f);\r\n  if (seg < 4.0 && count > 4) return mix(uColor3, uColor4, f);\r\n  if (seg < 5.0 && count > 5) return mix(uColor4, uColor5, f);\r\n  if (seg < 6.0 && count > 6) return mix(uColor5, uColor6, f);\r\n  if (seg < 7.0 && count > 7) return mix(uColor6, uColor7, f);\r\n  if (count > 7) return uColor7;\r\n  if (count > 6) return uColor6;\r\n  if (count > 5) return uColor5;\r\n  if (count > 4) return uColor4;\r\n  if (count > 3) return uColor3;\r\n  if (count > 2) return uColor2;\r\n  return uColor1;\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n    vec2 uv0 = fragCoord.xy / iResolution.xy;\r\n\r\n    float aspect = iResolution.x / iResolution.y;\r\n    vec2 p = uv0 * 2.0 - 1.0;\r\n    p.x *= aspect;\r\n    vec2 pr = rotate2D(p, uAngle);\r\n    pr.x /= aspect;\r\n    vec2 uv = pr * 0.5 + 0.5;\r\n\r\n    vec2 uvMod = uv;\r\n    if (uDistort > 0.0) {\r\n      float a = uvMod.y * 6.0;\r\n      float b = uvMod.x * 6.0;\r\n      float w = 0.01 * uDistort;\r\n      uvMod.x += sin(a) * w;\r\n      uvMod.y += cos(b) * w;\r\n    }\r\n    float t = uvMod.x;\r\n    if (uMirror > 0.5) {\r\n      t = 1.0 - abs(1.0 - 2.0 * fract(t));\r\n    }\r\n    vec3 base = getGradientColor(t);\r\n\r\n    vec2 offset = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\r\n  float d = length(uv0 - offset);\r\n  float r = max(uSpotlightRadius, 1e-4);\r\n  float dn = d / r;\r\n  float spot = (1.0 - 2.0 * pow(dn, uSpotlightSoftness)) * uSpotlightOpacity;\r\n  vec3 cir = vec3(spot);\r\n  float stripe = fract(uvMod.x * max(uBlindCount, 1.0));\r\n  if (uShineFlip > 0.5) stripe = 1.0 - stripe;\r\n    vec3 ran = vec3(stripe);\r\n\r\n    vec3 col = cir + base - ran;\r\n    col += (rand(gl_FragCoord.xy + iTime) - 0.5) * uNoise;\r\n\r\n    fragColor = vec4(col, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    vec4 color;\r\n    mainImage(color, vUv * iResolution.xy);\r\n    gl_FragColor = color;\r\n}\r\n`;\r\n\r\n    const { arr: colorArr, count: colorCount } = prepStops(gradientColors);\r\n    const uniforms: {\r\n      iResolution: { value: [number, number, number] };\r\n      iMouse: { value: [number, number] };\r\n      iTime: { value: number };\r\n      uAngle: { value: number };\r\n      uNoise: { value: number };\r\n      uBlindCount: { value: number };\r\n      uSpotlightRadius: { value: number };\r\n      uSpotlightSoftness: { value: number };\r\n      uSpotlightOpacity: { value: number };\r\n      uMirror: { value: number };\r\n      uDistort: { value: number };\r\n      uShineFlip: { value: number };\r\n      uColor0: { value: [number, number, number] };\r\n      uColor1: { value: [number, number, number] };\r\n      uColor2: { value: [number, number, number] };\r\n      uColor3: { value: [number, number, number] };\r\n      uColor4: { value: [number, number, number] };\r\n      uColor5: { value: [number, number, number] };\r\n      uColor6: { value: [number, number, number] };\r\n      uColor7: { value: [number, number, number] };\r\n      uColorCount: { value: number };\r\n    } = {\r\n      iResolution: {\r\n        value: [gl.drawingBufferWidth, gl.drawingBufferHeight, 1]\r\n      },\r\n      iMouse: { value: [0, 0] },\r\n      iTime: { value: 0 },\r\n      uAngle: { value: (angle * Math.PI) / 180 },\r\n      uNoise: { value: noise },\r\n      uBlindCount: { value: Math.max(1, blindCount) },\r\n      uSpotlightRadius: { value: spotlightRadius },\r\n      uSpotlightSoftness: { value: spotlightSoftness },\r\n      uSpotlightOpacity: { value: spotlightOpacity },\r\n      uMirror: { value: mirrorGradient ? 1 : 0 },\r\n      uDistort: { value: distortAmount },\r\n      uShineFlip: { value: shineDirection === 'right' ? 1 : 0 },\r\n      uColor0: { value: colorArr[0] },\r\n      uColor1: { value: colorArr[1] },\r\n      uColor2: { value: colorArr[2] },\r\n      uColor3: { value: colorArr[3] },\r\n      uColor4: { value: colorArr[4] },\r\n      uColor5: { value: colorArr[5] },\r\n      uColor6: { value: colorArr[6] },\r\n      uColor7: { value: colorArr[7] },\r\n      uColorCount: { value: colorCount }\r\n    };\r\n\r\n    const program = new Program(gl, {\r\n      vertex,\r\n      fragment,\r\n      uniforms\r\n    });\r\n    programRef.current = program;\r\n\r\n    const geometry = new Triangle(gl);\r\n    geometryRef.current = geometry;\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n    meshRef.current = mesh;\r\n\r\n    const resize = () => {\r\n      const rect = container.getBoundingClientRect();\r\n      renderer.setSize(rect.width, rect.height);\r\n      uniforms.iResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight, 1];\r\n\r\n      if (blindMinWidth && blindMinWidth > 0) {\r\n        const maxByMinWidth = Math.max(1, Math.floor(rect.width / blindMinWidth));\r\n\r\n        const effective = blindCount ? Math.min(blindCount, maxByMinWidth) : maxByMinWidth;\r\n        uniforms.uBlindCount.value = Math.max(1, effective);\r\n      } else {\r\n        uniforms.uBlindCount.value = Math.max(1, blindCount);\r\n      }\r\n\r\n      if (firstResizeRef.current) {\r\n        firstResizeRef.current = false;\r\n        const cx = gl.drawingBufferWidth / 2;\r\n        const cy = gl.drawingBufferHeight / 2;\r\n        uniforms.iMouse.value = [cx, cy];\r\n        mouseTargetRef.current = [cx, cy];\r\n      }\r\n    };\r\n\r\n    resize();\r\n    const ro = new ResizeObserver(resize);\r\n    ro.observe(container);\r\n\r\n    const onPointerMove = (e: PointerEvent) => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      const scale = (renderer as unknown as { dpr?: number }).dpr || 1;\r\n      const x = (e.clientX - rect.left) * scale;\r\n      const y = (rect.height - (e.clientY - rect.top)) * scale;\r\n      mouseTargetRef.current = [x, y];\r\n      if (mouseDampening <= 0) {\r\n        uniforms.iMouse.value = [x, y];\r\n      }\r\n    };\r\n    canvas.addEventListener('pointermove', onPointerMove);\r\n\r\n    const loop = (t: number) => {\r\n      rafRef.current = requestAnimationFrame(loop);\r\n      uniforms.iTime.value = t * 0.001;\r\n      if (mouseDampening > 0) {\r\n        if (!lastTimeRef.current) lastTimeRef.current = t;\r\n        const dt = (t - lastTimeRef.current) / 1000;\r\n        lastTimeRef.current = t;\r\n        const tau = Math.max(1e-4, mouseDampening);\r\n        let factor = 1 - Math.exp(-dt / tau);\r\n        if (factor > 1) factor = 1;\r\n        const target = mouseTargetRef.current;\r\n        const cur = uniforms.iMouse.value;\r\n        cur[0] += (target[0] - cur[0]) * factor;\r\n        cur[1] += (target[1] - cur[1]) * factor;\r\n      } else {\r\n        lastTimeRef.current = t;\r\n      }\r\n      if (!paused && programRef.current && meshRef.current) {\r\n        try {\r\n          renderer.render({ scene: meshRef.current });\r\n        } catch (e) {\r\n          console.error(e);\r\n        }\r\n      }\r\n    };\r\n    rafRef.current = requestAnimationFrame(loop);\r\n\r\n    return () => {\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n      canvas.removeEventListener('pointermove', onPointerMove);\r\n      ro.disconnect();\r\n      if (canvas.parentElement === container) {\r\n        container.removeChild(canvas);\r\n      }\r\n      const callIfFn = <T extends object, K extends keyof T>(obj: T | null, key: K) => {\r\n        if (obj && typeof obj[key] === 'function') {\r\n          (obj[key] as unknown as () => void).call(obj);\r\n        }\r\n      };\r\n      callIfFn(programRef.current, 'remove');\r\n      callIfFn(geometryRef.current, 'remove');\r\n      callIfFn(meshRef.current as unknown as { remove?: () => void }, 'remove');\r\n      callIfFn(rendererRef.current as unknown as { destroy?: () => void }, 'destroy');\r\n      programRef.current = null;\r\n      geometryRef.current = null;\r\n      meshRef.current = null;\r\n      rendererRef.current = null;\r\n    };\r\n  }, [\r\n    dpr,\r\n    paused,\r\n    gradientColors,\r\n    angle,\r\n    noise,\r\n    blindCount,\r\n    blindMinWidth,\r\n    mouseDampening,\r\n    mirrorGradient,\r\n    spotlightRadius,\r\n    spotlightSoftness,\r\n    spotlightOpacity,\r\n    distortAmount,\r\n    shineDirection\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`w-full h-full overflow-hidden relative ${className}`}\r\n      style={{\r\n        ...(mixBlendMode && {\r\n          mixBlendMode: mixBlendMode as React.CSSProperties['mixBlendMode']\r\n        })\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport default GradientBlinds;\r\n",
      "type": "registry:component"
    }
  ]
}