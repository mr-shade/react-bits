{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "MetallicPaint-TS-TW",
  "type": "registry:block",
  "title": "MetallicPaint",
  "description": "Liquid metallic paint shader which can be applied to SVG elements.",
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Animations/MetallicPaint/MetallicPaint.tsx",
      "content": "'use client';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\n\r\ntype ShaderParams = {\r\n  patternScale: number;\r\n  refraction: number;\r\n  edge: number;\r\n  patternBlur: number;\r\n  liquid: number;\r\n  speed: number;\r\n};\r\n\r\nconst defaultParams: ShaderParams = {\r\n  patternScale: 2,\r\n  refraction: 0.015,\r\n  edge: 1,\r\n  patternBlur: 0.005,\r\n  liquid: 0.07,\r\n  speed: 0.3\r\n};\r\n\r\nexport function parseLogoImage(file: File): Promise<{ imageData: ImageData; pngBlob: Blob }> {\r\n  const canvas = document.createElement('canvas');\r\n  const ctx = canvas.getContext('2d');\r\n\r\n  return new Promise((resolve, reject) => {\r\n    if (!file || !ctx) {\r\n      reject(new Error('Invalid file or context'));\r\n      return;\r\n    }\r\n\r\n    const img = new Image();\r\n    img.crossOrigin = 'anonymous';\r\n    img.onload = function () {\r\n      if (file.type === 'image/svg+xml') {\r\n        img.width = 1000;\r\n        img.height = 1000;\r\n      }\r\n\r\n      const MAX_SIZE = 1000;\r\n      const MIN_SIZE = 500;\r\n      let width = img.naturalWidth;\r\n      let height = img.naturalHeight;\r\n\r\n      if (width > MAX_SIZE || height > MAX_SIZE || width < MIN_SIZE || height < MIN_SIZE) {\r\n        if (width > height) {\r\n          if (width > MAX_SIZE) {\r\n            height = Math.round((height * MAX_SIZE) / width);\r\n            width = MAX_SIZE;\r\n          } else if (width < MIN_SIZE) {\r\n            height = Math.round((height * MIN_SIZE) / width);\r\n            width = MIN_SIZE;\r\n          }\r\n        } else {\r\n          if (height > MAX_SIZE) {\r\n            width = Math.round((width * MAX_SIZE) / height);\r\n            height = MAX_SIZE;\r\n          } else if (height < MIN_SIZE) {\r\n            width = Math.round((width * MIN_SIZE) / height);\r\n            height = MIN_SIZE;\r\n          }\r\n        }\r\n      }\r\n\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n\r\n      const shapeCanvas = document.createElement('canvas');\r\n      shapeCanvas.width = width;\r\n      shapeCanvas.height = height;\r\n      const shapeCtx = shapeCanvas.getContext('2d')!;\r\n      shapeCtx.drawImage(img, 0, 0, width, height);\r\n\r\n      const shapeImageData = shapeCtx.getImageData(0, 0, width, height);\r\n      const data = shapeImageData.data;\r\n      const shapeMask = new Array(width * height).fill(false);\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx4 = (y * width + x) * 4;\r\n          const r = data[idx4];\r\n          const g = data[idx4 + 1];\r\n          const b = data[idx4 + 2];\r\n          const a = data[idx4 + 3];\r\n          shapeMask[y * width + x] = !((r === 255 && g === 255 && b === 255 && a === 255) || a === 0);\r\n        }\r\n      }\r\n\r\n      function inside(x: number, y: number) {\r\n        if (x < 0 || x >= width || y < 0 || y >= height) return false;\r\n        return shapeMask[y * width + x];\r\n      }\r\n\r\n      const boundaryMask = new Array(width * height).fill(false);\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx = y * width + x;\r\n          if (!shapeMask[idx]) continue;\r\n          let isBoundary = false;\r\n          for (let ny = y - 1; ny <= y + 1 && !isBoundary; ny++) {\r\n            for (let nx = x - 1; nx <= x + 1 && !isBoundary; nx++) {\r\n              if (!inside(nx, ny)) {\r\n                isBoundary = true;\r\n              }\r\n            }\r\n          }\r\n          if (isBoundary) {\r\n            boundaryMask[idx] = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      const interiorMask = new Array(width * height).fill(false);\r\n      for (let y = 1; y < height - 1; y++) {\r\n        for (let x = 1; x < width - 1; x++) {\r\n          const idx = y * width + x;\r\n          if (\r\n            shapeMask[idx] &&\r\n            shapeMask[idx - 1] &&\r\n            shapeMask[idx + 1] &&\r\n            shapeMask[idx - width] &&\r\n            shapeMask[idx + width]\r\n          ) {\r\n            interiorMask[idx] = true;\r\n          }\r\n        }\r\n      }\r\n\r\n      const u = new Float32Array(width * height).fill(0);\r\n      const newU = new Float32Array(width * height).fill(0);\r\n      const C = 0.01;\r\n      const ITERATIONS = 300;\r\n\r\n      function getU(x: number, y: number, arr: Float32Array) {\r\n        if (x < 0 || x >= width || y < 0 || y >= height) return 0;\r\n        if (!shapeMask[y * width + x]) return 0;\r\n        return arr[y * width + x];\r\n      }\r\n\r\n      for (let iter = 0; iter < ITERATIONS; iter++) {\r\n        for (let y = 0; y < height; y++) {\r\n          for (let x = 0; x < width; x++) {\r\n            const idx = y * width + x;\r\n            if (!shapeMask[idx] || boundaryMask[idx]) {\r\n              newU[idx] = 0;\r\n              continue;\r\n            }\r\n            const sumN = getU(x + 1, y, u) + getU(x - 1, y, u) + getU(x, y + 1, u) + getU(x, y - 1, u);\r\n            newU[idx] = (C + sumN) / 4;\r\n          }\r\n        }\r\n        u.set(newU);\r\n      }\r\n\r\n      let maxVal = 0;\r\n      for (let i = 0; i < width * height; i++) {\r\n        if (u[i] > maxVal) maxVal = u[i];\r\n      }\r\n      const alpha = 2.0;\r\n      const outImg = ctx.createImageData(width, height);\r\n\r\n      for (let y = 0; y < height; y++) {\r\n        for (let x = 0; x < width; x++) {\r\n          const idx = y * width + x;\r\n          const px = idx * 4;\r\n          if (!shapeMask[idx]) {\r\n            outImg.data[px] = 255;\r\n            outImg.data[px + 1] = 255;\r\n            outImg.data[px + 2] = 255;\r\n            outImg.data[px + 3] = 255;\r\n          } else {\r\n            const raw = u[idx] / maxVal;\r\n            const remapped = Math.pow(raw, alpha);\r\n            const gray = 255 * (1 - remapped);\r\n            outImg.data[px] = gray;\r\n            outImg.data[px + 1] = gray;\r\n            outImg.data[px + 2] = gray;\r\n            outImg.data[px + 3] = 255;\r\n          }\r\n        }\r\n      }\r\n      ctx.putImageData(outImg, 0, 0);\r\n\r\n      canvas.toBlob(blob => {\r\n        if (!blob) {\r\n          reject(new Error('Failed to create PNG blob'));\r\n          return;\r\n        }\r\n        resolve({\r\n          imageData: outImg,\r\n          pngBlob: blob\r\n        });\r\n      }, 'image/png');\r\n    };\r\n\r\n    img.onerror = () => reject(new Error('Failed to load image'));\r\n    img.src = URL.createObjectURL(file);\r\n  });\r\n}\r\n\r\nconst vertexShaderSource = `#version 300 es\r\nprecision mediump float;\r\n\r\nin vec2 a_position;\r\nout vec2 vUv;\r\n\r\nvoid main() {\r\n    vUv = .5 * (a_position + 1.);\r\n    gl_Position = vec4(a_position, 0.0, 1.0);\r\n}`;\r\n\r\nconst liquidFragSource = `#version 300 es\r\nprecision mediump float;\r\n\r\nin vec2 vUv;\r\nout vec4 fragColor;\r\n\r\nuniform sampler2D u_image_texture;\r\nuniform float u_time;\r\nuniform float u_ratio;\r\nuniform float u_img_ratio;\r\nuniform float u_patternScale;\r\nuniform float u_refraction;\r\nuniform float u_edge;\r\nuniform float u_patternBlur;\r\nuniform float u_liquid;\r\n\r\n#define TWO_PI 6.28318530718\r\n#define PI 3.14159265358979323846\r\n\r\nvec3 mod289(vec3 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec2 mod289(vec2 x) { return x - floor(x * (1. / 289.)) * 289.; }\r\nvec3 permute(vec3 x) { return mod289(((x*34.)+1.)*x); }\r\nfloat snoise(vec2 v) {\r\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\r\n    vec2 i = floor(v + dot(v, C.yy));\r\n    vec2 x0 = v - i + dot(i, C.xx);\r\n    vec2 i1;\r\n    i1 = (x0.x > x0.y) ? vec2(1., 0.) : vec2(0., 1.);\r\n    vec4 x12 = x0.xyxy + C.xxzz;\r\n    x12.xy -= i1;\r\n    i = mod289(i);\r\n    vec3 p = permute(permute(i.y + vec3(0., i1.y, 1.)) + i.x + vec3(0., i1.x, 1.));\r\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.);\r\n    m = m*m;\r\n    m = m*m;\r\n    vec3 x = 2. * fract(p * C.www) - 1.;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\r\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\r\n    vec3 g;\r\n    g.x = a0.x * x0.x + h.x * x0.y;\r\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n    return 130. * dot(m, g);\r\n}\r\n\r\nvec2 get_img_uv() {\r\n    vec2 img_uv = vUv;\r\n    img_uv -= .5;\r\n    if (u_ratio > u_img_ratio) {\r\n        img_uv.x = img_uv.x * u_ratio / u_img_ratio;\r\n    } else {\r\n        img_uv.y = img_uv.y * u_img_ratio / u_ratio;\r\n    }\r\n    float scale_factor = 1.;\r\n    img_uv *= scale_factor;\r\n    img_uv += .5;\r\n    img_uv.y = 1. - img_uv.y;\r\n    return img_uv;\r\n}\r\nvec2 rotate(vec2 uv, float th) {\r\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\r\n}\r\nfloat get_color_channel(float c1, float c2, float stripe_p, vec3 w, float extra_blur, float b) {\r\n    float ch = c2;\r\n    float border = 0.;\r\n    float blur = u_patternBlur + extra_blur;\r\n    ch = mix(ch, c1, smoothstep(.0, blur, stripe_p));\r\n    border = w[0];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n    b = smoothstep(.2, .8, b);\r\n    border = w[0] + .4 * (1. - b) * w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n    border = w[0] + .5 * (1. - b) * w[1];\r\n    ch = mix(ch, c2, smoothstep(border - blur, border + blur, stripe_p));\r\n    border = w[0] + w[1];\r\n    ch = mix(ch, c1, smoothstep(border - blur, border + blur, stripe_p));\r\n    float gradient_t = (stripe_p - w[0] - w[1]) / w[2];\r\n    float gradient = mix(c1, c2, smoothstep(0., 1., gradient_t));\r\n    ch = mix(ch, gradient, smoothstep(border - blur, border + blur, stripe_p));\r\n    return ch;\r\n}\r\nfloat get_img_frame_alpha(vec2 uv, float img_frame_width) {\r\n    float img_frame_alpha = smoothstep(0., img_frame_width, uv.x) * smoothstep(1., 1. - img_frame_width, uv.x);\r\n    img_frame_alpha *= smoothstep(0., img_frame_width, uv.y) * smoothstep(1., 1. - img_frame_width, uv.y);\r\n    return img_frame_alpha;\r\n}\r\nvoid main() {\r\n    vec2 uv = vUv;\r\n    uv.y = 1. - uv.y;\r\n    uv.x *= u_ratio;\r\n    float diagonal = uv.x - uv.y;\r\n    float t = .001 * u_time;\r\n    vec2 img_uv = get_img_uv();\r\n    vec4 img = texture(u_image_texture, img_uv);\r\n    vec3 color = vec3(0.);\r\n    float opacity = 1.;\r\n    vec3 color1 = vec3(.98, 0.98, 1.);\r\n    vec3 color2 = vec3(.1, .1, .1 + .1 * smoothstep(.7, 1.3, uv.x + uv.y));\r\n    float edge = img.r;\r\n    vec2 grad_uv = uv;\r\n    grad_uv -= .5;\r\n    float dist = length(grad_uv + vec2(0., .2 * diagonal));\r\n    grad_uv = rotate(grad_uv, (.25 - .2 * diagonal) * PI);\r\n    float bulge = pow(1.8 * dist, 1.2);\r\n    bulge = 1. - bulge;\r\n    bulge *= pow(uv.y, .3);\r\n    float cycle_width = u_patternScale;\r\n    float thin_strip_1_ratio = .12 / cycle_width * (1. - .4 * bulge);\r\n    float thin_strip_2_ratio = .07 / cycle_width * (1. + .4 * bulge);\r\n    float wide_strip_ratio = (1. - thin_strip_1_ratio - thin_strip_2_ratio);\r\n    float thin_strip_1_width = cycle_width * thin_strip_1_ratio;\r\n    float thin_strip_2_width = cycle_width * thin_strip_2_ratio;\r\n    opacity = 1. - smoothstep(.9 - .5 * u_edge, 1. - .5 * u_edge, edge);\r\n    opacity *= get_img_frame_alpha(img_uv, 0.01);\r\n    float noise = snoise(uv - t);\r\n    edge += (1. - edge) * u_liquid * noise;\r\n    float refr = 0.;\r\n    refr += (1. - bulge);\r\n    refr = clamp(refr, 0., 1.);\r\n    float dir = grad_uv.x;\r\n    dir += diagonal;\r\n    dir -= 2. * noise * diagonal * (smoothstep(0., 1., edge) * smoothstep(1., 0., edge));\r\n    bulge *= clamp(pow(uv.y, .1), .3, 1.);\r\n    dir *= (.1 + (1.1 - edge) * bulge);\r\n    dir *= smoothstep(1., .7, edge);\r\n    dir += .18 * (smoothstep(.1, .2, uv.y) * smoothstep(.4, .2, uv.y));\r\n    dir += .03 * (smoothstep(.1, .2, 1. - uv.y) * smoothstep(.4, .2, 1. - uv.y));\r\n    dir *= (.5 + .5 * pow(uv.y, 2.));\r\n    dir *= cycle_width;\r\n    dir -= t;\r\n    float refr_r = refr;\r\n    refr_r += .03 * bulge * noise;\r\n    float refr_b = 1.3 * refr;\r\n    refr_r += 5. * (smoothstep(-.1, .2, uv.y) * smoothstep(.5, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(1., .4, bulge));\r\n    refr_r -= diagonal;\r\n    refr_b += (smoothstep(0., .4, uv.y) * smoothstep(.8, .1, uv.y)) * (smoothstep(.4, .6, bulge) * smoothstep(.8, .4, bulge));\r\n    refr_b -= .2 * edge;\r\n    refr_r *= u_refraction;\r\n    refr_b *= u_refraction;\r\n    vec3 w = vec3(thin_strip_1_width, thin_strip_2_width, wide_strip_ratio);\r\n    w[1] -= .02 * smoothstep(.0, 1., edge + bulge);\r\n    float stripe_r = mod(dir + refr_r, 1.);\r\n    float r = get_color_channel(color1.r, color2.r, stripe_r, w, 0.02 + .03 * u_refraction * bulge, bulge);\r\n    float stripe_g = mod(dir, 1.);\r\n    float g = get_color_channel(color1.g, color2.g, stripe_g, w, 0.01 / (1. - diagonal), bulge);\r\n    float stripe_b = mod(dir - refr_b, 1.);\r\n    float b = get_color_channel(color1.b, color2.b, stripe_b, w, .01, bulge);\r\n    color = vec3(r, g, b);\r\n    color *= opacity;\r\n    fragColor = vec4(color, opacity);\r\n}\r\n`;\r\n\r\nexport default function MetallicPaint({\r\n  imageData,\r\n  params = defaultParams\r\n}: {\r\n  imageData: ImageData;\r\n  params: ShaderParams;\r\n}) {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const [gl, setGl] = useState<WebGL2RenderingContext | null>(null);\r\n  const [uniforms, setUniforms] = useState<Record<string, WebGLUniformLocation>>({});\r\n  const totalAnimationTime = useRef(0);\r\n  const lastRenderTime = useRef(0);\r\n\r\n  function updateUniforms() {\r\n    if (!gl || !uniforms) return;\r\n    gl.uniform1f(uniforms.u_edge, params.edge);\r\n    gl.uniform1f(uniforms.u_patternBlur, params.patternBlur);\r\n    gl.uniform1f(uniforms.u_time, 0);\r\n    gl.uniform1f(uniforms.u_patternScale, params.patternScale);\r\n    gl.uniform1f(uniforms.u_refraction, params.refraction);\r\n    gl.uniform1f(uniforms.u_liquid, params.liquid);\r\n  }\r\n\r\n  useEffect(() => {\r\n    function initShader() {\r\n      const canvas = canvasRef.current;\r\n      const gl = canvas?.getContext('webgl2', {\r\n        antialias: true,\r\n        alpha: true\r\n      });\r\n      if (!canvas || !gl) {\r\n        return;\r\n      }\r\n\r\n      function createShader(gl: WebGL2RenderingContext, sourceCode: string, type: number) {\r\n        const shader = gl.createShader(type);\r\n        if (!shader) {\r\n          return null;\r\n        }\r\n\r\n        gl.shaderSource(shader, sourceCode);\r\n        gl.compileShader(shader);\r\n\r\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));\r\n          gl.deleteShader(shader);\r\n          return null;\r\n        }\r\n\r\n        return shader;\r\n      }\r\n\r\n      const vertexShader = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\r\n      const fragmentShader = createShader(gl, liquidFragSource, gl.FRAGMENT_SHADER);\r\n      const program = gl.createProgram();\r\n      if (!program || !vertexShader || !fragmentShader) {\r\n        return;\r\n      }\r\n\r\n      gl.attachShader(program, vertexShader);\r\n      gl.attachShader(program, fragmentShader);\r\n      gl.linkProgram(program);\r\n\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n        console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));\r\n        return null;\r\n      }\r\n\r\n      function getUniforms(program: WebGLProgram, gl: WebGL2RenderingContext) {\r\n        let uniforms: Record<string, WebGLUniformLocation> = {};\r\n        let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\r\n        for (let i = 0; i < uniformCount; i++) {\r\n          let uniformName = gl.getActiveUniform(program, i)?.name;\r\n          if (!uniformName) continue;\r\n          uniforms[uniformName] = gl.getUniformLocation(program, uniformName) as WebGLUniformLocation;\r\n        }\r\n        return uniforms;\r\n      }\r\n      const uniforms = getUniforms(program, gl);\r\n      setUniforms(uniforms);\r\n\r\n      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\r\n      const vertexBuffer = gl.createBuffer();\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n\r\n      gl.useProgram(program);\r\n\r\n      const positionLocation = gl.getAttribLocation(program, 'a_position');\r\n      gl.enableVertexAttribArray(positionLocation);\r\n\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n      setGl(gl);\r\n    }\r\n\r\n    initShader();\r\n    updateUniforms();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n    updateUniforms();\r\n  }, [gl, params, uniforms]);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n\r\n    let renderId: number;\r\n\r\n    function render(currentTime: number) {\r\n      const deltaTime = currentTime - lastRenderTime.current;\r\n      lastRenderTime.current = currentTime;\r\n\r\n      totalAnimationTime.current += deltaTime * params.speed;\r\n      gl!.uniform1f(uniforms.u_time, totalAnimationTime.current);\r\n      gl!.drawArrays(gl!.TRIANGLE_STRIP, 0, 4);\r\n      renderId = requestAnimationFrame(render);\r\n    }\r\n\r\n    lastRenderTime.current = performance.now();\r\n    renderId = requestAnimationFrame(render);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(renderId);\r\n    };\r\n  }, [gl, params.speed]);\r\n\r\n  useEffect(() => {\r\n    const canvasEl = canvasRef.current;\r\n    if (!canvasEl || !gl || !uniforms) return;\r\n\r\n    function resizeCanvas() {\r\n      if (!canvasEl || !gl || !uniforms || !imageData) return;\r\n      const imgRatio = imageData.width / imageData.height;\r\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\r\n\r\n      const side = 1000;\r\n      canvasEl.width = side * devicePixelRatio;\r\n      canvasEl.height = side * devicePixelRatio;\r\n      gl.viewport(0, 0, canvasEl.height, canvasEl.height);\r\n      gl.uniform1f(uniforms.u_ratio, 1);\r\n      gl.uniform1f(uniforms.u_img_ratio, imgRatio);\r\n    }\r\n\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas);\r\n    };\r\n  }, [gl, uniforms, imageData]);\r\n\r\n  useEffect(() => {\r\n    if (!gl || !uniforms) return;\r\n\r\n    const existingTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n    if (existingTexture) {\r\n      gl.deleteTexture(existingTexture);\r\n    }\r\n\r\n    const imageTexture = gl.createTexture();\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, imageTexture);\r\n\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\r\n\r\n    try {\r\n      gl.texImage2D(\r\n        gl.TEXTURE_2D,\r\n        0,\r\n        gl.RGBA,\r\n        imageData?.width,\r\n        imageData?.height,\r\n        0,\r\n        gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        imageData?.data\r\n      );\r\n\r\n      gl.uniform1i(uniforms.u_image_texture, 0);\r\n    } catch (e) {\r\n      console.error('Error uploading texture:', e);\r\n    }\r\n\r\n    return () => {\r\n      if (imageTexture) {\r\n        gl.deleteTexture(imageTexture);\r\n      }\r\n    };\r\n  }, [gl, uniforms, imageData]);\r\n\r\n  return <canvas ref={canvasRef} className=\"block w-full h-full object-contain\" />;\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}