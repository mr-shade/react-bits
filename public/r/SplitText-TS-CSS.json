{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "SplitText-TS-CSS",
  "type": "registry:block",
  "title": "SplitText",
  "description": "Splits text into characters / words for staggered entrance animation.",
  "dependencies": [
    "@gsap/react",
    "gsap"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/SplitText/SplitText.tsx",
      "content": "import React, { useRef, useEffect, useState } from 'react';\r\nimport { gsap } from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\nimport { SplitText as GSAPSplitText } from 'gsap/SplitText';\r\nimport { useGSAP } from '@gsap/react';\r\n\r\ngsap.registerPlugin(ScrollTrigger, GSAPSplitText, useGSAP);\r\n\r\nexport interface SplitTextProps {\r\n  text: string;\r\n  className?: string;\r\n  delay?: number;\r\n  duration?: number;\r\n  ease?: string | ((t: number) => number);\r\n  splitType?: 'chars' | 'words' | 'lines' | 'words, chars';\r\n  from?: gsap.TweenVars;\r\n  to?: gsap.TweenVars;\r\n  threshold?: number;\r\n  rootMargin?: string;\r\n  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span';\r\n  textAlign?: React.CSSProperties['textAlign'];\r\n  onLetterAnimationComplete?: () => void;\r\n}\r\n\r\nconst SplitText: React.FC<SplitTextProps> = ({\r\n  text,\r\n  className = '',\r\n  delay = 100,\r\n  duration = 0.6,\r\n  ease = 'power3.out',\r\n  splitType = 'chars',\r\n  from = { opacity: 0, y: 40 },\r\n  to = { opacity: 1, y: 0 },\r\n  threshold = 0.1,\r\n  rootMargin = '-100px',\r\n  textAlign = 'center',\r\n  tag = 'p',\r\n  onLetterAnimationComplete\r\n}) => {\r\n  const ref = useRef<HTMLParagraphElement>(null);\r\n  const animationCompletedRef = useRef(false);\r\n  const [fontsLoaded, setFontsLoaded] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    if (document.fonts.status === 'loaded') {\r\n      setFontsLoaded(true);\r\n    } else {\r\n      document.fonts.ready.then(() => {\r\n        setFontsLoaded(true);\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  useGSAP(\r\n    () => {\r\n      if (!ref.current || !text || !fontsLoaded) return;\r\n\r\n      const el = ref.current as HTMLElement & {\r\n        _rbsplitInstance?: GSAPSplitText;\r\n      };\r\n\r\n      if (el._rbsplitInstance) {\r\n        try {\r\n          el._rbsplitInstance.revert();\r\n        } catch (_) {}\r\n        el._rbsplitInstance = undefined;\r\n      }\r\n\r\n      const startPct = (1 - threshold) * 100;\r\n      const marginMatch = /^(-?\\d+(?:\\.\\d+)?)(px|em|rem|%)?$/.exec(rootMargin);\r\n      const marginValue = marginMatch ? parseFloat(marginMatch[1]) : 0;\r\n      const marginUnit = marginMatch ? marginMatch[2] || 'px' : 'px';\r\n      const sign =\r\n        marginValue === 0\r\n          ? ''\r\n          : marginValue < 0\r\n            ? `-=${Math.abs(marginValue)}${marginUnit}`\r\n            : `+=${marginValue}${marginUnit}`;\r\n      const start = `top ${startPct}%${sign}`;\r\n      let targets: Element[] = [];\r\n      const assignTargets = (self: GSAPSplitText) => {\r\n        if (splitType.includes('chars') && self.chars.length) targets = self.chars;\r\n        if (!targets.length && splitType.includes('words') && self.words.length) targets = self.words;\r\n        if (!targets.length && splitType.includes('lines') && self.lines.length) targets = self.lines;\r\n        if (!targets.length) targets = self.chars || self.words || self.lines;\r\n      };\r\n      const splitInstance = new GSAPSplitText(el, {\r\n        type: splitType,\r\n        smartWrap: true,\r\n        autoSplit: splitType === 'lines',\r\n        linesClass: 'split-line',\r\n        wordsClass: 'split-word',\r\n        charsClass: 'split-char',\r\n        reduceWhiteSpace: false,\r\n        onSplit: (self: GSAPSplitText) => {\r\n          assignTargets(self);\r\n          return gsap.fromTo(\r\n            targets,\r\n            { ...from },\r\n            {\r\n              ...to,\r\n              duration,\r\n              ease,\r\n              stagger: delay / 1000,\r\n              scrollTrigger: {\r\n                trigger: el,\r\n                start,\r\n                once: true,\r\n                fastScrollEnd: true,\r\n                anticipatePin: 0.4\r\n              },\r\n              onComplete: () => {\r\n                animationCompletedRef.current = true;\r\n                onLetterAnimationComplete?.();\r\n              },\r\n              willChange: 'transform, opacity',\r\n              force3D: true\r\n            }\r\n          );\r\n        }\r\n      });\r\n      el._rbsplitInstance = splitInstance;\r\n      return () => {\r\n        ScrollTrigger.getAll().forEach(st => {\r\n          if (st.trigger === el) st.kill();\r\n        });\r\n        try {\r\n          splitInstance.revert();\r\n        } catch (_) {}\r\n        el._rbsplitInstance = undefined;\r\n      };\r\n    },\r\n    {\r\n      dependencies: [\r\n        text,\r\n        delay,\r\n        duration,\r\n        ease,\r\n        splitType,\r\n        JSON.stringify(from),\r\n        JSON.stringify(to),\r\n        threshold,\r\n        rootMargin,\r\n        fontsLoaded,\r\n        onLetterAnimationComplete\r\n      ],\r\n      scope: ref\r\n    }\r\n  );\r\n\r\n  const renderTag = () => {\r\n    const style: React.CSSProperties = {\r\n      textAlign,\r\n      overflow: 'hidden',\r\n      display: 'inline-block',\r\n      whiteSpace: 'normal',\r\n      wordWrap: 'break-word',\r\n      willChange: 'transform, opacity'\r\n    };\r\n    const classes = `split-parent ${className}`;\r\n    switch (tag) {\r\n      case 'h1':\r\n        return (\r\n          <h1 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h1>\r\n        );\r\n      case 'h2':\r\n        return (\r\n          <h2 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h2>\r\n        );\r\n      case 'h3':\r\n        return (\r\n          <h3 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h3>\r\n        );\r\n      case 'h4':\r\n        return (\r\n          <h4 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h4>\r\n        );\r\n      case 'h5':\r\n        return (\r\n          <h5 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h5>\r\n        );\r\n      case 'h6':\r\n        return (\r\n          <h6 ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </h6>\r\n        );\r\n      default:\r\n        return (\r\n          <p ref={ref} style={style} className={classes}>\r\n            {text}\r\n          </p>\r\n        );\r\n    }\r\n  };\r\n  return renderTag();\r\n};\r\n\r\nexport default SplitText;\r\n",
      "type": "registry:component"
    }
  ]
}