{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "TextTrail-TS-TW",
  "type": "registry:block",
  "title": "TextTrail",
  "description": "3D trail effect that follows the cursor and changes the text's appearance.",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/TextAnimations/TextTrail/TextTrail.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\nimport {\r\n  CanvasTexture,\r\n  Clock,\r\n  Color,\r\n  LinearFilter,\r\n  LinearMipmapLinearFilter,\r\n  Mesh,\r\n  OrthographicCamera,\r\n  PlaneGeometry,\r\n  Scene,\r\n  ShaderMaterial,\r\n  Vector2,\r\n  Vector3,\r\n  WebGLRenderer,\r\n  WebGLRenderTarget\r\n} from 'three';\r\n\r\nconst hexToRgb = (hex: string): [number, number, number] => {\r\n  let h = hex.replace('#', '');\r\n  if (h.length === 3)\r\n    h = h\r\n      .split('')\r\n      .map(c => c + c)\r\n      .join('');\r\n  const n = parseInt(h, 16);\r\n  return [(n >> 16) & 255, (n >> 8) & 255, n & 255];\r\n};\r\nconst loadFont = async (fam: string) => {\r\n  if ('fonts' in document) await document.fonts.load(`64px \"${fam}\"`);\r\n};\r\n\r\nconst BASE_VERT = `\r\nvarying vec2 v_uv;\r\nvoid main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);v_uv=uv;}`;\r\n\r\nconst SIMPLEX = `\r\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\r\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\r\nvec4 permute(vec4 x){return mod289(((x*34.)+1.)*x);}\r\nfloat snoise3(vec3 v){\r\n  const vec2 C=vec2(1./6.,1./3.);\r\n  const vec4 D=vec4(0.,.5,1.,2.);\r\n  vec3 i=floor(v+dot(v,C.yyy));\r\n  vec3 x0=v-i+dot(i,C.xxx);\r\n  vec3 g=step(x0.yzx,x0.xyz);\r\n  vec3 l=1.-g;\r\n  vec3 i1=min(g.xyz,l.zxy);\r\n  vec3 i2=max(g.xyz,l.zxy);\r\n  vec3 x1=x0-i1+C.xxx;\r\n  vec3 x2=x0-i2+C.yyy;\r\n  vec3 x3=x0-D.yyy;\r\n  i=mod289(i);\r\n  vec4 p=permute(permute(permute(i.z+vec4(0.,i1.z,i2.z,1.))+i.y+vec4(0.,i1.y,i2.y,1.))+i.x+vec4(0.,i1.x,i2.x,1.));\r\n  float n_=1./7.; vec3 ns=n_*D.wyz-D.xzx;\r\n  vec4 j=p-49.*floor(p*ns.z*ns.z);\r\n  vec4 x_=floor(j*ns.z);\r\n  vec4 y_=floor(j-7.*x_);\r\n  vec4 x=x_*ns.x+ns.yyyy;\r\n  vec4 y=y_*ns.x+ns.yyyy;\r\n  vec4 h=1.-abs(x)-abs(y);\r\n  vec4 b0=vec4(x.xy,y.xy);\r\n  vec4 b1=vec4(x.zw,y.zw);\r\n  vec4 s0=floor(b0)*2.+1.;\r\n  vec4 s1=floor(b1)*2.+1.;\r\n  vec4 sh=-step(h,vec4(0.));\r\n  vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;\r\n  vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;\r\n  vec3 p0=vec3(a0.xy,h.x);\r\n  vec3 p1=vec3(a0.zw,h.y);\r\n  vec3 p2=vec3(a1.xy,h.z);\r\n  vec3 p3=vec3(a1.zw,h.w);\r\n  vec4 norm=inversesqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));\r\n  p0*=norm.x; p1*=norm.y; p2*=norm.z; p3*=norm.w;\r\n  vec4 m=max(.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.);\r\n  m*=m;\r\n  return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));\r\n}`;\r\n\r\nconst PERSIST_FRAG = `\r\nuniform sampler2D sampler;\r\nuniform float time;\r\nuniform vec2 mousePos;\r\nuniform float noiseFactor,noiseScale,rgbPersistFactor,alphaPersistFactor;\r\nvarying vec2 v_uv;\r\n${SIMPLEX}\r\nvoid main(){\r\n  float a=snoise3(vec3(v_uv*noiseFactor,time*.1))*noiseScale;\r\n  float b=snoise3(vec3(v_uv*noiseFactor,time*.1+100.))*noiseScale;\r\n  vec4 t=texture2D(sampler,v_uv+vec2(a,b)+mousePos*.005);\r\n  gl_FragColor=vec4(t.xyz*rgbPersistFactor,alphaPersistFactor);\r\n}`;\r\n\r\nconst TEXT_FRAG = `\r\nuniform sampler2D sampler;uniform vec3 color;varying vec2 v_uv;\r\nvoid main(){\r\n  vec4 t=texture2D(sampler,v_uv);\r\n  float alpha=smoothstep(0.1,0.9,t.a);\r\n  if(alpha<0.01)discard;\r\n  gl_FragColor=vec4(color,alpha);\r\n}`;\r\n\r\nexport interface TextTrailProps {\r\n  text?: string;\r\n  fontFamily?: string;\r\n  fontWeight?: string | number;\r\n  noiseFactor?: number;\r\n  noiseScale?: number;\r\n  rgbPersistFactor?: number;\r\n  alphaPersistFactor?: number;\r\n  animateColor?: boolean;\r\n  startColor?: string;\r\n  textColor?: string;\r\n  backgroundColor?: number | string;\r\n  colorCycleInterval?: number;\r\n  supersample?: number;\r\n}\r\n\r\nconst TextTrail: React.FC<TextTrailProps> = ({\r\n  text = 'Trail',\r\n  fontFamily = 'Figtree',\r\n  fontWeight = '900',\r\n  noiseFactor = 1,\r\n  noiseScale = 0.0005,\r\n  rgbPersistFactor = 0.98,\r\n  alphaPersistFactor = 0.95,\r\n  animateColor = false,\r\n  startColor = '#ffffff',\r\n  textColor = '#ffffff',\r\n  backgroundColor = 0x271e37,\r\n  colorCycleInterval = 3000,\r\n  supersample = 2\r\n}) => {\r\n  const ref = useRef<HTMLDivElement>(null);\r\n\r\n  const persistColor = useRef<[number, number, number]>(\r\n    hexToRgb(textColor || startColor).map(c => c / 255) as [number, number, number]\r\n  );\r\n  const targetColor = useRef<[number, number, number]>([...persistColor.current]);\r\n\r\n  useEffect(() => {\r\n    if (!ref.current) return;\r\n\r\n    const size = () => ({\r\n      w: ref.current!.clientWidth,\r\n      h: ref.current!.clientHeight\r\n    });\r\n    let { w, h } = size();\r\n\r\n    const renderer = new WebGLRenderer({ antialias: true });\r\n    renderer.setClearColor(new Color(backgroundColor as any), 1);\r\n    renderer.setPixelRatio(window.devicePixelRatio || 1);\r\n    renderer.setSize(w, h);\r\n    ref.current.appendChild(renderer.domElement);\r\n\r\n    const scene = new Scene();\r\n    const fluidScene = new Scene();\r\n    const clock = new Clock();\r\n    const cam = new OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 0.1, 10);\r\n    cam.position.z = 1;\r\n\r\n    let rt0 = new WebGLRenderTarget(w, h);\r\n    let rt1 = rt0.clone();\r\n\r\n    const quadMat = new ShaderMaterial({\r\n      uniforms: {\r\n        sampler: { value: null },\r\n        time: { value: 0 },\r\n        mousePos: { value: new Vector2(-1, 1) },\r\n        noiseFactor: { value: noiseFactor },\r\n        noiseScale: { value: noiseScale },\r\n        rgbPersistFactor: { value: rgbPersistFactor },\r\n        alphaPersistFactor: { value: alphaPersistFactor }\r\n      },\r\n      vertexShader: BASE_VERT,\r\n      fragmentShader: PERSIST_FRAG,\r\n      transparent: true\r\n    });\r\n    const quad = new Mesh(new PlaneGeometry(w, h), quadMat);\r\n    fluidScene.add(quad);\r\n\r\n    const labelMat = new ShaderMaterial({\r\n      uniforms: {\r\n        sampler: { value: null },\r\n        color: { value: new Vector3(...persistColor.current) }\r\n      },\r\n      vertexShader: BASE_VERT,\r\n      fragmentShader: TEXT_FRAG,\r\n      transparent: true\r\n    });\r\n    const label = new Mesh(new PlaneGeometry(Math.min(w, h), Math.min(w, h)), labelMat);\r\n    scene.add(label);\r\n\r\n    const texCanvas = document.createElement('canvas');\r\n    const ctx = texCanvas.getContext('2d', {\r\n      alpha: true,\r\n      colorSpace: 'srgb'\r\n    })!;\r\n    const drawText = () => {\r\n      const max = Math.min(renderer.capabilities.maxTextureSize, 4096);\r\n      const pixelRatio = (window.devicePixelRatio || 1) * supersample;\r\n      const canvasSize = max * pixelRatio;\r\n      texCanvas.width = canvasSize;\r\n      texCanvas.height = canvasSize;\r\n      texCanvas.style.width = `${max}px`;\r\n      texCanvas.style.height = `${max}px`;\r\n\r\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n      ctx.scale(pixelRatio, pixelRatio);\r\n      ctx.clearRect(0, 0, max, max);\r\n      ctx.imageSmoothingEnabled = true;\r\n      ctx.imageSmoothingQuality = 'high';\r\n      ctx.shadowColor = 'rgba(255,255,255,0.3)';\r\n      ctx.shadowBlur = 2;\r\n      ctx.fillStyle = '#fff';\r\n      ctx.textAlign = 'center';\r\n      ctx.textBaseline = 'middle';\r\n\r\n      const refSize = 250;\r\n      ctx.font = `${fontWeight} ${refSize}px ${fontFamily}`;\r\n      const width = ctx.measureText(text).width;\r\n      ctx.font = `${fontWeight} ${(refSize * max) / width}px ${fontFamily}`;\r\n\r\n      const cx = max / 2,\r\n        cy = max / 2;\r\n      const offs = [\r\n        [0, 0],\r\n        [0.1, 0],\r\n        [-0.1, 0],\r\n        [0, 0.1],\r\n        [0, -0.1],\r\n        [0.1, 0.1],\r\n        [-0.1, -0.1],\r\n        [0.1, -0.1],\r\n        [-0.1, 0.1]\r\n      ];\r\n      ctx.globalAlpha = 1 / offs.length;\r\n      offs.forEach(([dx, dy]) => ctx.fillText(text, cx + dx, cy + dy));\r\n      ctx.globalAlpha = 1;\r\n\r\n      const tex = new CanvasTexture(texCanvas);\r\n      tex.generateMipmaps = true;\r\n      tex.minFilter = LinearMipmapLinearFilter;\r\n      tex.magFilter = LinearFilter;\r\n      labelMat.uniforms.sampler.value = tex;\r\n    };\r\n    loadFont(fontFamily).finally(drawText);\r\n\r\n    const mouse = [0, 0],\r\n      target = [0, 0];\r\n    const onMove = (e: PointerEvent) => {\r\n      const r = ref.current!.getBoundingClientRect();\r\n      target[0] = ((e.clientX - r.left) / r.width) * 2 - 1;\r\n      target[1] = ((r.top + r.height - e.clientY) / r.height) * 2 - 1;\r\n    };\r\n    ref.current.addEventListener('pointermove', onMove);\r\n\r\n    const ro = new ResizeObserver(() => {\r\n      ({ w, h } = size());\r\n      renderer.setSize(w, h);\r\n      cam.left = -w / 2;\r\n      cam.right = w / 2;\r\n      cam.top = h / 2;\r\n      cam.bottom = -h / 2;\r\n      cam.updateProjectionMatrix();\r\n      quad.geometry.dispose();\r\n      quad.geometry = new PlaneGeometry(w, h);\r\n      rt0.setSize(w, h);\r\n      rt1.setSize(w, h);\r\n      label.geometry.dispose();\r\n      label.geometry = new PlaneGeometry(Math.min(w, h), Math.min(w, h));\r\n    });\r\n    ro.observe(ref.current);\r\n\r\n    const timer = setInterval(() => {\r\n      if (!textColor) {\r\n        targetColor.current = [Math.random(), Math.random(), Math.random()];\r\n      }\r\n    }, colorCycleInterval);\r\n\r\n    renderer.setAnimationLoop(() => {\r\n      const dt = clock.getDelta();\r\n      if (animateColor && !textColor) {\r\n        for (let i = 0; i < 3; i++) persistColor.current[i] += (targetColor.current[i] - persistColor.current[i]) * dt;\r\n      }\r\n      const speed = dt * 5;\r\n      mouse[0] += (target[0] - mouse[0]) * speed;\r\n      mouse[1] += (target[1] - mouse[1]) * speed;\r\n\r\n      quadMat.uniforms.mousePos.value.set(mouse[0], mouse[1]);\r\n      quadMat.uniforms.sampler.value = rt1.texture;\r\n      quadMat.uniforms.time.value = clock.getElapsedTime();\r\n      labelMat.uniforms.color.value.set(...persistColor.current);\r\n\r\n      renderer.autoClearColor = false;\r\n      renderer.setRenderTarget(rt0);\r\n      renderer.clearColor();\r\n      renderer.render(fluidScene, cam);\r\n      renderer.render(scene, cam);\r\n      renderer.setRenderTarget(null);\r\n      renderer.render(fluidScene, cam);\r\n      renderer.render(scene, cam);\r\n      [rt0, rt1] = [rt1, rt0];\r\n    });\r\n\r\n    return () => {\r\n      renderer.setAnimationLoop(null);\r\n      clearInterval(timer);\r\n      ref.current?.removeEventListener('pointermove', onMove);\r\n      ro.disconnect();\r\n      ref.current?.removeChild(renderer.domElement);\r\n      renderer.dispose();\r\n      rt0.dispose();\r\n      rt1.dispose();\r\n      quadMat.dispose();\r\n      quad.geometry.dispose();\r\n      labelMat.dispose();\r\n      label.geometry.dispose();\r\n    };\r\n  }, [\r\n    text,\r\n    fontFamily,\r\n    fontWeight,\r\n    noiseFactor,\r\n    noiseScale,\r\n    rgbPersistFactor,\r\n    alphaPersistFactor,\r\n    animateColor,\r\n    startColor,\r\n    textColor,\r\n    backgroundColor,\r\n    colorCycleInterval,\r\n    supersample\r\n  ]);\r\n\r\n  return <div ref={ref} className=\"w-full h-full\" />;\r\n};\r\n\r\nexport default TextTrail;\r\n",
      "type": "registry:component"
    }
  ]
}