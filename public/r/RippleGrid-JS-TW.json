{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "RippleGrid-JS-TW",
  "type": "registry:block",
  "title": "RippleGrid",
  "description": "A grid that continously animates with a ripple effect.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/Backgrounds/RippleGrid/RippleGrid.jsx",
      "content": "import { useRef, useEffect } from 'react';\r\nimport { Renderer, Program, Triangle, Mesh } from 'ogl';\r\n\r\nconst RippleGrid = ({\r\n  enableRainbow = false,\r\n  gridColor = '#ffffff',\r\n  rippleIntensity = 0.05,\r\n  gridSize = 10.0,\r\n  gridThickness = 15.0,\r\n  fadeDistance = 1.5,\r\n  vignetteStrength = 2.0,\r\n  glowIntensity = 0.1,\r\n  opacity = 1.0,\r\n  gridRotation = 0,\r\n  mouseInteraction = true,\r\n  mouseInteractionRadius = 1\r\n}) => {\r\n  const containerRef = useRef(null);\r\n  const mousePositionRef = useRef({ x: 0.5, y: 0.5 });\r\n  const targetMouseRef = useRef({ x: 0.5, y: 0.5 });\r\n  const mouseInfluenceRef = useRef(0);\r\n  const uniformsRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const hexToRgb = hex => {\r\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n      return result\r\n        ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]\r\n        : [1, 1, 1];\r\n    };\r\n\r\n    const renderer = new Renderer({\r\n      dpr: Math.min(window.devicePixelRatio, 2),\r\n      alpha: true\r\n    });\r\n    const gl = renderer.gl;\r\n    gl.enable(gl.BLEND);\r\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n    gl.canvas.style.width = '100%';\r\n    gl.canvas.style.height = '100%';\r\n    containerRef.current.appendChild(gl.canvas);\r\n\r\n    const vert = `\r\nattribute vec2 position;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n    vUv = position * 0.5 + 0.5;\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n}`;\r\n\r\n    const frag = `precision highp float;\r\nuniform float iTime;\r\nuniform vec2 iResolution;\r\nuniform bool enableRainbow;\r\nuniform vec3 gridColor;\r\nuniform float rippleIntensity;\r\nuniform float gridSize;\r\nuniform float gridThickness;\r\nuniform float fadeDistance;\r\nuniform float vignetteStrength;\r\nuniform float glowIntensity;\r\nuniform float opacity;\r\nuniform float gridRotation;\r\nuniform bool mouseInteraction;\r\nuniform vec2 mousePosition;\r\nuniform float mouseInfluence;\r\nuniform float mouseInteractionRadius;\r\nvarying vec2 vUv;\r\n\r\nfloat pi = 3.141592;\r\n\r\nmat2 rotate(float angle) {\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    return mat2(c, -s, s, c);\r\n}\r\n\r\nvoid main() {\r\n    vec2 uv = vUv * 2.0 - 1.0;\r\n    uv.x *= iResolution.x / iResolution.y;\r\n\r\n    if (gridRotation != 0.0) {\r\n        uv = rotate(gridRotation * pi / 180.0) * uv;\r\n    }\r\n\r\n    float dist = length(uv);\r\n    float func = sin(pi * (iTime - dist));\r\n    vec2 rippleUv = uv + uv * func * rippleIntensity;\r\n\r\n    if (mouseInteraction && mouseInfluence > 0.0) {\r\n        vec2 mouseUv = (mousePosition * 2.0 - 1.0);\r\n        mouseUv.x *= iResolution.x / iResolution.y;\r\n        float mouseDist = length(uv - mouseUv);\r\n        \r\n        float influence = mouseInfluence * exp(-mouseDist * mouseDist / (mouseInteractionRadius * mouseInteractionRadius));\r\n        \r\n        float mouseWave = sin(pi * (iTime * 2.0 - mouseDist * 3.0)) * influence;\r\n        rippleUv += normalize(uv - mouseUv) * mouseWave * rippleIntensity * 0.3;\r\n    }\r\n\r\n    vec2 a = sin(gridSize * 0.5 * pi * rippleUv - pi / 2.0);\r\n    vec2 b = abs(a);\r\n\r\n    float aaWidth = 0.5;\r\n    vec2 smoothB = vec2(\r\n        smoothstep(0.0, aaWidth, b.x),\r\n        smoothstep(0.0, aaWidth, b.y)\r\n    );\r\n\r\n    vec3 color = vec3(0.0);\r\n    color += exp(-gridThickness * smoothB.x * (0.8 + 0.5 * sin(pi * iTime)));\r\n    color += exp(-gridThickness * smoothB.y);\r\n    color += 0.5 * exp(-(gridThickness / 4.0) * sin(smoothB.x));\r\n    color += 0.5 * exp(-(gridThickness / 3.0) * smoothB.y);\r\n\r\n    if (glowIntensity > 0.0) {\r\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.x);\r\n        color += glowIntensity * exp(-gridThickness * 0.5 * smoothB.y);\r\n    }\r\n\r\n    float ddd = exp(-2.0 * clamp(pow(dist, fadeDistance), 0.0, 1.0));\r\n    \r\n    vec2 vignetteCoords = vUv - 0.5;\r\n    float vignetteDistance = length(vignetteCoords);\r\n    float vignette = 1.0 - pow(vignetteDistance * 2.0, vignetteStrength);\r\n    vignette = clamp(vignette, 0.0, 1.0);\r\n    \r\n    vec3 t;\r\n    if (enableRainbow) {\r\n        t = vec3(\r\n            uv.x * 0.5 + 0.5 * sin(iTime),\r\n            uv.y * 0.5 + 0.5 * cos(iTime),\r\n            pow(cos(iTime), 4.0)\r\n        ) + 0.5;\r\n    } else {\r\n        t = gridColor;\r\n    }\r\n\r\n    float finalFade = ddd * vignette;\r\n    float alpha = length(color) * finalFade * opacity;\r\n    gl_FragColor = vec4(color * t * finalFade * opacity, alpha);\r\n}`;\r\n\r\n    const uniforms = {\r\n      iTime: { value: 0 },\r\n      iResolution: { value: [1, 1] },\r\n      enableRainbow: { value: enableRainbow },\r\n      gridColor: { value: hexToRgb(gridColor) },\r\n      rippleIntensity: { value: rippleIntensity },\r\n      gridSize: { value: gridSize },\r\n      gridThickness: { value: gridThickness },\r\n      fadeDistance: { value: fadeDistance },\r\n      vignetteStrength: { value: vignetteStrength },\r\n      glowIntensity: { value: glowIntensity },\r\n      opacity: { value: opacity },\r\n      gridRotation: { value: gridRotation },\r\n      mouseInteraction: { value: mouseInteraction },\r\n      mousePosition: { value: [0.5, 0.5] },\r\n      mouseInfluence: { value: 0 },\r\n      mouseInteractionRadius: { value: mouseInteractionRadius }\r\n    };\r\n\r\n    uniformsRef.current = uniforms;\r\n\r\n    const geometry = new Triangle(gl);\r\n    const program = new Program(gl, { vertex: vert, fragment: frag, uniforms });\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n\r\n    const resize = () => {\r\n      const { clientWidth: w, clientHeight: h } = containerRef.current;\r\n      renderer.setSize(w, h);\r\n      uniforms.iResolution.value = [w, h];\r\n    };\r\n\r\n    const handleMouseMove = e => {\r\n      if (!mouseInteraction || !containerRef.current) return;\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      const x = (e.clientX - rect.left) / rect.width;\r\n      const y = 1.0 - (e.clientY - rect.top) / rect.height; // Flip Y coordinate\r\n      targetMouseRef.current = { x, y };\r\n    };\r\n\r\n    const handleMouseEnter = () => {\r\n      if (!mouseInteraction) return;\r\n      mouseInfluenceRef.current = 1.0;\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      if (!mouseInteraction) return;\r\n      mouseInfluenceRef.current = 0.0;\r\n    };\r\n\r\n    window.addEventListener('resize', resize);\r\n    if (mouseInteraction) {\r\n      containerRef.current.addEventListener('mousemove', handleMouseMove);\r\n      containerRef.current.addEventListener('mouseenter', handleMouseEnter);\r\n      containerRef.current.addEventListener('mouseleave', handleMouseLeave);\r\n    }\r\n    resize();\r\n\r\n    const render = t => {\r\n      uniforms.iTime.value = t * 0.001;\r\n\r\n      const lerpFactor = 0.1;\r\n      mousePositionRef.current.x += (targetMouseRef.current.x - mousePositionRef.current.x) * lerpFactor;\r\n      mousePositionRef.current.y += (targetMouseRef.current.y - mousePositionRef.current.y) * lerpFactor;\r\n\r\n      const currentInfluence = uniforms.mouseInfluence.value;\r\n      const targetInfluence = mouseInfluenceRef.current;\r\n      uniforms.mouseInfluence.value += (targetInfluence - currentInfluence) * 0.05;\r\n\r\n      uniforms.mousePosition.value = [mousePositionRef.current.x, mousePositionRef.current.y];\r\n\r\n      renderer.render({ scene: mesh });\r\n      requestAnimationFrame(render);\r\n    };\r\n\r\n    requestAnimationFrame(render);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resize);\r\n      if (mouseInteraction && containerRef.current) {\r\n        containerRef.current.removeEventListener('mousemove', handleMouseMove);\r\n        containerRef.current.removeEventListener('mouseenter', handleMouseEnter);\r\n        containerRef.current.removeEventListener('mouseleave', handleMouseLeave);\r\n      }\r\n      renderer.gl.getExtension('WEBGL_lose_context')?.loseContext();\r\n      containerRef.current?.removeChild(gl.canvas);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!uniformsRef.current) return;\r\n\r\n    const hexToRgb = hex => {\r\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n      return result\r\n        ? [parseInt(result[1], 16) / 255, parseInt(result[2], 16) / 255, parseInt(result[3], 16) / 255]\r\n        : [1, 1, 1];\r\n    };\r\n\r\n    uniformsRef.current.enableRainbow.value = enableRainbow;\r\n    uniformsRef.current.gridColor.value = hexToRgb(gridColor);\r\n    uniformsRef.current.rippleIntensity.value = rippleIntensity;\r\n    uniformsRef.current.gridSize.value = gridSize;\r\n    uniformsRef.current.gridThickness.value = gridThickness;\r\n    uniformsRef.current.fadeDistance.value = fadeDistance;\r\n    uniformsRef.current.vignetteStrength.value = vignetteStrength;\r\n    uniformsRef.current.glowIntensity.value = glowIntensity;\r\n    uniformsRef.current.opacity.value = opacity;\r\n    uniformsRef.current.gridRotation.value = gridRotation;\r\n    uniformsRef.current.mouseInteraction.value = mouseInteraction;\r\n    uniformsRef.current.mouseInteractionRadius.value = mouseInteractionRadius;\r\n  }, [\r\n    enableRainbow,\r\n    gridColor,\r\n    rippleIntensity,\r\n    gridSize,\r\n    gridThickness,\r\n    fadeDistance,\r\n    vignetteStrength,\r\n    glowIntensity,\r\n    opacity,\r\n    gridRotation,\r\n    mouseInteraction,\r\n    mouseInteractionRadius\r\n  ]);\r\n\r\n  return <div ref={containerRef} className=\"w-full h-full relative overflow-hidden [&_canvas]:block\" />;\r\n};\r\n\r\nexport default RippleGrid;\r\n",
      "type": "registry:component"
    }
  ]
}