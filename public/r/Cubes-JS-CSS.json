{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Cubes-JS-CSS",
  "type": "registry:block",
  "title": "Cubes",
  "description": "3D rotating cube cluster. Supports auto-rotation or hover interaction.",
  "dependencies": [
    "gsap"
  ],
  "files": [
    {
      "path": "public/default/src/content/Animations/Cubes/Cubes.jsx",
      "content": "import { useCallback, useEffect, useRef } from 'react';\r\nimport gsap from 'gsap';\r\nimport './Cubes.css';\r\n\r\nconst Cubes = ({\r\n  gridSize = 10,\r\n  cubeSize,\r\n  maxAngle = 45,\r\n  radius = 3,\r\n  easing = 'power3.out',\r\n  duration = { enter: 0.3, leave: 0.6 },\r\n  cellGap,\r\n  borderStyle = '1px solid #fff',\r\n  faceColor = '#060010',\r\n  shadow = false,\r\n  autoAnimate = true,\r\n  rippleOnClick = true,\r\n  rippleColor = '#fff',\r\n  rippleSpeed = 2\r\n}) => {\r\n  const sceneRef = useRef(null);\r\n  const rafRef = useRef(null);\r\n  const idleTimerRef = useRef(null);\r\n  const userActiveRef = useRef(false);\r\n  const simPosRef = useRef({ x: 0, y: 0 });\r\n  const simTargetRef = useRef({ x: 0, y: 0 });\r\n  const simRAFRef = useRef(null);\r\n\r\n  const colGap = typeof cellGap === 'number' ? `${cellGap}px` : cellGap?.col !== undefined ? `${cellGap.col}px` : '5%';\r\n  const rowGap = typeof cellGap === 'number' ? `${cellGap}px` : cellGap?.row !== undefined ? `${cellGap.row}px` : '5%';\r\n\r\n  const enterDur = duration.enter;\r\n  const leaveDur = duration.leave;\r\n\r\n  const tiltAt = useCallback(\r\n    (rowCenter, colCenter) => {\r\n      if (!sceneRef.current) return;\r\n      sceneRef.current.querySelectorAll('.cube').forEach(cube => {\r\n        const r = +cube.dataset.row;\r\n        const c = +cube.dataset.col;\r\n        const dist = Math.hypot(r - rowCenter, c - colCenter);\r\n        if (dist <= radius) {\r\n          const pct = 1 - dist / radius;\r\n          const angle = pct * maxAngle;\r\n          gsap.to(cube, {\r\n            duration: enterDur,\r\n            ease: easing,\r\n            overwrite: true,\r\n            rotateX: -angle,\r\n            rotateY: angle\r\n          });\r\n        } else {\r\n          gsap.to(cube, {\r\n            duration: leaveDur,\r\n            ease: 'power3.out',\r\n            overwrite: true,\r\n            rotateX: 0,\r\n            rotateY: 0\r\n          });\r\n        }\r\n      });\r\n    },\r\n    [radius, maxAngle, enterDur, leaveDur, easing]\r\n  );\r\n\r\n  const onPointerMove = useCallback(\r\n    e => {\r\n      userActiveRef.current = true;\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n\r\n      const rect = sceneRef.current.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n      const colCenter = (e.clientX - rect.left) / cellW;\r\n      const rowCenter = (e.clientY - rect.top) / cellH;\r\n\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\r\n\r\n      idleTimerRef.current = setTimeout(() => {\r\n        userActiveRef.current = false;\r\n      }, 3000);\r\n    },\r\n    [gridSize, tiltAt]\r\n  );\r\n\r\n  const resetAll = useCallback(() => {\r\n    if (!sceneRef.current) return;\r\n    sceneRef.current.querySelectorAll('.cube').forEach(cube =>\r\n      gsap.to(cube, {\r\n        duration: leaveDur,\r\n        rotateX: 0,\r\n        rotateY: 0,\r\n        ease: 'power3.out'\r\n      })\r\n    );\r\n  }, [leaveDur]);\r\n\r\n  const onTouchMove = useCallback(\r\n    e => {\r\n      e.preventDefault();\r\n      userActiveRef.current = true;\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n\r\n      const rect = sceneRef.current.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n\r\n      const touch = e.touches[0];\r\n      const colCenter = (touch.clientX - rect.left) / cellW;\r\n      const rowCenter = (touch.clientY - rect.top) / cellH;\r\n\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\r\n\r\n      idleTimerRef.current = setTimeout(() => {\r\n        userActiveRef.current = false;\r\n      }, 3000);\r\n    },\r\n    [gridSize, tiltAt]\r\n  );\r\n\r\n  const onTouchStart = useCallback(() => {\r\n    userActiveRef.current = true;\r\n  }, []);\r\n\r\n  const onTouchEnd = useCallback(() => {\r\n    if (!sceneRef.current) return;\r\n    resetAll();\r\n  }, [resetAll]);\r\n\r\n  const onClick = useCallback(\r\n    e => {\r\n      if (!rippleOnClick || !sceneRef.current) return;\r\n      const rect = sceneRef.current.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n\r\n      const clientX = e.clientX || (e.touches && e.touches[0].clientX);\r\n      const clientY = e.clientY || (e.touches && e.touches[0].clientY);\r\n\r\n      const colHit = Math.floor((clientX - rect.left) / cellW);\r\n      const rowHit = Math.floor((clientY - rect.top) / cellH);\r\n\r\n      const baseRingDelay = 0.15;\r\n      const baseAnimDur = 0.3;\r\n      const baseHold = 0.6;\r\n\r\n      const spreadDelay = baseRingDelay / rippleSpeed;\r\n      const animDuration = baseAnimDur / rippleSpeed;\r\n      const holdTime = baseHold / rippleSpeed;\r\n\r\n      const rings = {};\r\n      sceneRef.current.querySelectorAll('.cube').forEach(cube => {\r\n        const r = +cube.dataset.row;\r\n        const c = +cube.dataset.col;\r\n        const dist = Math.hypot(r - rowHit, c - colHit);\r\n        const ring = Math.round(dist);\r\n        if (!rings[ring]) rings[ring] = [];\r\n        rings[ring].push(cube);\r\n      });\r\n\r\n      Object.keys(rings)\r\n        .map(Number)\r\n        .sort((a, b) => a - b)\r\n        .forEach(ring => {\r\n          const delay = ring * spreadDelay;\r\n          const faces = rings[ring].flatMap(cube => Array.from(cube.querySelectorAll('.cube-face')));\r\n\r\n          gsap.to(faces, {\r\n            backgroundColor: rippleColor,\r\n            duration: animDuration,\r\n            delay,\r\n            ease: 'power3.out'\r\n          });\r\n          gsap.to(faces, {\r\n            backgroundColor: faceColor,\r\n            duration: animDuration,\r\n            delay: delay + animDuration + holdTime,\r\n            ease: 'power3.out'\r\n          });\r\n        });\r\n    },\r\n    [rippleOnClick, gridSize, faceColor, rippleColor, rippleSpeed]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!autoAnimate || !sceneRef.current) return;\r\n    simPosRef.current = {\r\n      x: Math.random() * gridSize,\r\n      y: Math.random() * gridSize\r\n    };\r\n    simTargetRef.current = {\r\n      x: Math.random() * gridSize,\r\n      y: Math.random() * gridSize\r\n    };\r\n    const speed = 0.02;\r\n    const loop = () => {\r\n      if (!userActiveRef.current) {\r\n        const pos = simPosRef.current;\r\n        const tgt = simTargetRef.current;\r\n        pos.x += (tgt.x - pos.x) * speed;\r\n        pos.y += (tgt.y - pos.y) * speed;\r\n        tiltAt(pos.y, pos.x);\r\n        if (Math.hypot(pos.x - tgt.x, pos.y - tgt.y) < 0.1) {\r\n          simTargetRef.current = {\r\n            x: Math.random() * gridSize,\r\n            y: Math.random() * gridSize\r\n          };\r\n        }\r\n      }\r\n      simRAFRef.current = requestAnimationFrame(loop);\r\n    };\r\n    simRAFRef.current = requestAnimationFrame(loop);\r\n    return () => {\r\n      if (simRAFRef.current != null) {\r\n        cancelAnimationFrame(simRAFRef.current);\r\n      }\r\n    };\r\n  }, [autoAnimate, gridSize, tiltAt]);\r\n\r\n  useEffect(() => {\r\n    const el = sceneRef.current;\r\n    if (!el) return;\r\n\r\n    el.addEventListener('pointermove', onPointerMove);\r\n    el.addEventListener('pointerleave', resetAll);\r\n    el.addEventListener('click', onClick);\r\n\r\n    el.addEventListener('touchmove', onTouchMove, { passive: false });\r\n    el.addEventListener('touchstart', onTouchStart, { passive: true });\r\n    el.addEventListener('touchend', onTouchEnd, { passive: true });\r\n\r\n    return () => {\r\n      el.removeEventListener('pointermove', onPointerMove);\r\n      el.removeEventListener('pointerleave', resetAll);\r\n      el.removeEventListener('click', onClick);\r\n\r\n      el.removeEventListener('touchmove', onTouchMove);\r\n      el.removeEventListener('touchstart', onTouchStart);\r\n      el.removeEventListener('touchend', onTouchEnd);\r\n\r\n      rafRef.current != null && cancelAnimationFrame(rafRef.current);\r\n      idleTimerRef.current && clearTimeout(idleTimerRef.current);\r\n    };\r\n  }, [onPointerMove, resetAll, onClick, onTouchMove, onTouchStart, onTouchEnd]);\r\n\r\n  const cells = Array.from({ length: gridSize });\r\n  const sceneStyle = {\r\n    gridTemplateColumns: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\r\n    gridTemplateRows: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\r\n    columnGap: colGap,\r\n    rowGap: rowGap\r\n  };\r\n  const wrapperStyle = {\r\n    '--cube-face-border': borderStyle,\r\n    '--cube-face-bg': faceColor,\r\n    '--cube-face-shadow': shadow === true ? '0 0 6px rgba(0,0,0,.5)' : shadow || 'none',\r\n    ...(cubeSize\r\n      ? {\r\n          width: `${gridSize * cubeSize}px`,\r\n          height: `${gridSize * cubeSize}px`\r\n        }\r\n      : {})\r\n  };\r\n\r\n  return (\r\n    <div className=\"default-animation\" style={wrapperStyle}>\r\n      <div ref={sceneRef} className=\"default-animation--scene\" style={sceneStyle}>\r\n        {cells.map((_, r) =>\r\n          cells.map((__, c) => (\r\n            <div key={`${r}-${c}`} className=\"cube\" data-row={r} data-col={c}>\r\n              <div className=\"cube-face cube-face--top\" />\r\n              <div className=\"cube-face cube-face--bottom\" />\r\n              <div className=\"cube-face cube-face--left\" />\r\n              <div className=\"cube-face cube-face--right\" />\r\n              <div className=\"cube-face cube-face--front\" />\r\n              <div className=\"cube-face cube-face--back\" />\r\n            </div>\r\n          ))\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cubes;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Animations/Cubes/Cubes.css",
      "content": ":root {\r\n  --col-gap: 5%;\r\n  --row-gap: 5%;\r\n  --cube-perspective: 99999999px;\r\n  --cube-face-border: 1px solid #fff;\r\n  --cube-face-bg: #060010;\r\n}\r\n\r\n.default-animation {\r\n  position: relative;\r\n  width: 50%;\r\n  aspect-ratio: 1 / 1;\r\n  height: auto;\r\n}\r\n\r\n.default-animation--scene {\r\n  display: grid;\r\n  width: 100%;\r\n  height: 100%;\r\n  column-gap: var(--col-gap);\r\n  row-gap: var(--row-gap);\r\n  perspective: var(--cube-perspective);\r\n  grid-auto-rows: 1fr;\r\n}\r\n\r\n.cube {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n  aspect-ratio: 1 / 1;\r\n  transform-style: preserve-3d;\r\n}\r\n\r\n.cube::before {\r\n  content: '';\r\n  position: absolute;\r\n  top: -36px;\r\n  right: -36px;\r\n  bottom: -36px;\r\n  left: -36px;\r\n}\r\n\r\n.default-animation .cube-face {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  background: var(--cube-face-bg);\r\n  border: var(--cube-face-border);\r\n  opacity: 1;\r\n}\r\n\r\n.default-animation .cube-face--top {\r\n  transform: translateY(-50%) rotateX(90deg);\r\n}\r\n\r\n.default-animation .cube-face--bottom {\r\n  transform: translateY(50%) rotateX(-90deg);\r\n}\r\n\r\n.default-animation .cube-face--left {\r\n  transform: translateX(-50%) rotateY(-90deg);\r\n}\r\n\r\n.default-animation .cube-face--right {\r\n  transform: translateX(50%) rotateY(90deg);\r\n}\r\n\r\n.default-animation .cube-face--back,\r\n.default-animation .cube-face--front {\r\n  transform: rotateY(-90deg) translateX(50%) rotateY(90deg);\r\n}\r\n\r\n@media (max-width: 768px) {\r\n  .default-animation {\r\n    width: 90%;\r\n  }\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}