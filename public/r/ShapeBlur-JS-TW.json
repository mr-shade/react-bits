{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ShapeBlur-JS-TW",
  "type": "registry:block",
  "title": "ShapeBlur",
  "description": "Morphing blurred geometric shape. The effect occurs on hover.",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/Animations/ShapeBlur/ShapeBlur.jsx",
      "content": "import { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\n\r\nconst vertexShader = /* glsl */ `\r\nvarying vec2 v_texcoord;\r\nvoid main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    v_texcoord = uv;\r\n}\r\n`;\r\n\r\nconst fragmentShader = /* glsl */ `\r\nvarying vec2 v_texcoord;\r\n\r\nuniform vec2 u_mouse;\r\nuniform vec2 u_resolution;\r\nuniform float u_pixelRatio;\r\n\r\nuniform float u_shapeSize;\r\nuniform float u_roundness;\r\nuniform float u_borderSize;\r\nuniform float u_circleSize;\r\nuniform float u_circleEdge;\r\n\r\n#ifndef PI\r\n#define PI 3.1415926535897932384626433832795\r\n#endif\r\n#ifndef TWO_PI\r\n#define TWO_PI 6.2831853071795864769252867665590\r\n#endif\r\n\r\n#ifndef VAR\r\n#define VAR 0\r\n#endif\r\n\r\n#ifndef FNC_COORD\r\n#define FNC_COORD\r\nvec2 coord(in vec2 p) {\r\n    p = p / u_resolution.xy;\r\n    if (u_resolution.x > u_resolution.y) {\r\n        p.x *= u_resolution.x / u_resolution.y;\r\n        p.x += (u_resolution.y - u_resolution.x) / u_resolution.y / 2.0;\r\n    } else {\r\n        p.y *= u_resolution.y / u_resolution.x;\r\n        p.y += (u_resolution.x - u_resolution.y) / u_resolution.x / 2.0;\r\n    }\r\n    p -= 0.5;\r\n    p *= vec2(-1.0, 1.0);\r\n    return p;\r\n}\r\n#endif\r\n\r\n#define st0 coord(gl_FragCoord.xy)\r\n#define mx coord(u_mouse * u_pixelRatio)\r\n\r\nfloat sdRoundRect(vec2 p, vec2 b, float r) {\r\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\r\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;\r\n}\r\nfloat sdCircle(in vec2 st, in vec2 center) {\r\n    return length(st - center) * 2.0;\r\n}\r\nfloat sdPoly(in vec2 p, in float w, in int sides) {\r\n    float a = atan(p.x, p.y) + PI;\r\n    float r = TWO_PI / float(sides);\r\n    float d = cos(floor(0.5 + a / r) * r - a) * length(max(abs(p) * 1.0, 0.0));\r\n    return d * 2.0 - w;\r\n}\r\n\r\nfloat aastep(float threshold, float value) {\r\n    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;\r\n    return smoothstep(threshold - afwidth, threshold + afwidth, value);\r\n}\r\nfloat fill(in float x) { return 1.0 - aastep(0.0, x); }\r\nfloat fill(float x, float size, float edge) {\r\n    return 1.0 - smoothstep(size - edge, size + edge, x);\r\n}\r\nfloat stroke(in float d, in float t) { return (1.0 - aastep(t, abs(d))); }\r\nfloat stroke(float x, float size, float w, float edge) {\r\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\r\n    return clamp(d, 0.0, 1.0);\r\n}\r\n\r\nfloat strokeAA(float x, float size, float w, float edge) {\r\n    float afwidth = length(vec2(dFdx(x), dFdy(x))) * 0.70710678;\r\n    float d = smoothstep(size - edge - afwidth, size + edge + afwidth, x + w * 0.5)\r\n            - smoothstep(size - edge - afwidth, size + edge + afwidth, x - w * 0.5);\r\n    return clamp(d, 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n    vec2 st = st0 + 0.5;\r\n    vec2 posMouse = mx * vec2(1., -1.) + 0.5;\r\n\r\n    float size = u_shapeSize;\r\n    float roundness = u_roundness;\r\n    float borderSize = u_borderSize;\r\n    float circleSize = u_circleSize;\r\n    float circleEdge = u_circleEdge;\r\n\r\n    float sdfCircle = fill(\r\n        sdCircle(st, posMouse),\r\n        circleSize,\r\n        circleEdge\r\n    );\r\n\r\n    float sdf;\r\n    if (VAR == 0) {\r\n        sdf = sdRoundRect(st, vec2(size), roundness);\r\n        sdf = strokeAA(sdf, 0.0, borderSize, sdfCircle) * 4.0;\r\n    } else if (VAR == 1) {\r\n        sdf = sdCircle(st, vec2(0.5));\r\n        sdf = fill(sdf, 0.6, sdfCircle) * 1.2;\r\n    } else if (VAR == 2) {\r\n        sdf = sdCircle(st, vec2(0.5));\r\n        sdf = strokeAA(sdf, 0.58, 0.02, sdfCircle) * 4.0;\r\n    } else if (VAR == 3) {\r\n        sdf = sdPoly(st - vec2(0.5, 0.45), 0.3, 3);\r\n        sdf = fill(sdf, 0.05, sdfCircle) * 1.4;\r\n    }\r\n\r\n    vec3 color = vec3(1.0);\r\n    float alpha = sdf;\r\n    gl_FragColor = vec4(color.rgb, alpha);\r\n}\r\n`;\r\n\r\nconst ShapeBlur = ({\r\n  className = '',\r\n  variation = 0,\r\n  pixelRatioProp = 2,\r\n  shapeSize = 1.2,\r\n  roundness = 0.4,\r\n  borderSize = 0.05,\r\n  circleSize = 0.3,\r\n  circleEdge = 0.5\r\n}) => {\r\n  const mountRef = useRef();\r\n\r\n  useEffect(() => {\r\n    const mount = mountRef.current;\r\n    let animationFrameId;\r\n    let time = 0,\r\n      lastTime = 0;\r\n\r\n    const vMouse = new THREE.Vector2();\r\n    const vMouseDamp = new THREE.Vector2();\r\n    const vResolution = new THREE.Vector2();\r\n\r\n    let w = 1,\r\n      h = 1;\r\n\r\n    const scene = new THREE.Scene();\r\n    const camera = new THREE.OrthographicCamera();\r\n    camera.position.z = 1;\r\n\r\n    const renderer = new THREE.WebGLRenderer({ alpha: true });\r\n    renderer.setClearColor(0x000000, 0);\r\n    mount.appendChild(renderer.domElement);\r\n\r\n    const geo = new THREE.PlaneGeometry(1, 1);\r\n    const material = new THREE.ShaderMaterial({\r\n      vertexShader,\r\n      fragmentShader,\r\n      uniforms: {\r\n        u_mouse: { value: vMouseDamp },\r\n        u_resolution: { value: vResolution },\r\n        u_pixelRatio: { value: pixelRatioProp },\r\n        u_shapeSize: { value: shapeSize },\r\n        u_roundness: { value: roundness },\r\n        u_borderSize: { value: borderSize },\r\n        u_circleSize: { value: circleSize },\r\n        u_circleEdge: { value: circleEdge }\r\n      },\r\n      defines: { VAR: variation },\r\n      transparent: true\r\n    });\r\n\r\n    const quad = new THREE.Mesh(geo, material);\r\n    scene.add(quad);\r\n\r\n    const onPointerMove = e => {\r\n      const rect = mount.getBoundingClientRect();\r\n      vMouse.set(e.clientX - rect.left, e.clientY - rect.top);\r\n    };\r\n\r\n    document.addEventListener('mousemove', onPointerMove);\r\n    document.addEventListener('pointermove', onPointerMove);\r\n\r\n    const resize = () => {\r\n      const container = mountRef.current;\r\n      w = container.clientWidth;\r\n      h = container.clientHeight;\r\n      const dpr = Math.min(window.devicePixelRatio, 2);\r\n\r\n      renderer.setSize(w, h);\r\n      renderer.setPixelRatio(dpr);\r\n\r\n      camera.left = -w / 2;\r\n      camera.right = w / 2;\r\n      camera.top = h / 2;\r\n      camera.bottom = -h / 2;\r\n      camera.updateProjectionMatrix();\r\n\r\n      quad.scale.set(w, h, 1);\r\n      vResolution.set(w, h).multiplyScalar(dpr);\r\n      material.uniforms.u_pixelRatio.value = dpr;\r\n    };\r\n\r\n    resize();\r\n    window.addEventListener('resize', resize);\r\n\r\n    const ro = new ResizeObserver(() => resize());\r\n    if (mountRef.current) ro.observe(mountRef.current);\r\n\r\n    const update = () => {\r\n      time = performance.now() * 0.001;\r\n      const dt = time - lastTime;\r\n      lastTime = time;\r\n\r\n      ['x', 'y'].forEach(k => {\r\n        vMouseDamp[k] = THREE.MathUtils.damp(vMouseDamp[k], vMouse[k], 8, dt);\r\n      });\r\n\r\n      renderer.render(scene, camera);\r\n      animationFrameId = requestAnimationFrame(update);\r\n    };\r\n    update();\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationFrameId);\r\n      window.removeEventListener('resize', resize);\r\n      if (ro) ro.disconnect();\r\n      document.removeEventListener('mousemove', onPointerMove);\r\n      document.removeEventListener('pointermove', onPointerMove);\r\n      mount.removeChild(renderer.domElement);\r\n      renderer.dispose();\r\n    };\r\n  }, [variation, pixelRatioProp, shapeSize, roundness, borderSize, circleSize, circleEdge]);\r\n\r\n  return <div ref={mountRef} className={`w-full h-full ${className}`} />;\r\n};\r\n\r\nexport default ShapeBlur;\r\n",
      "type": "registry:component"
    }
  ]
}