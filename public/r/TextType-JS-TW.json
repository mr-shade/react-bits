{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "TextType-JS-TW",
  "type": "registry:block",
  "title": "TextType",
  "description": "Typewriter effect with blinking cursor and adjustable typing cadence.",
  "dependencies": [
    "gsap"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/TextAnimations/TextType/TextType.jsx",
      "content": "'use client';\r\n\r\nimport { useEffect, useRef, useState, createElement, useMemo, useCallback } from 'react';\r\nimport { gsap } from 'gsap';\r\n\r\nconst TextType = ({\r\n  text,\r\n  as: Component = 'div',\r\n  typingSpeed = 50,\r\n  initialDelay = 0,\r\n  pauseDuration = 2000,\r\n  deletingSpeed = 30,\r\n  loop = true,\r\n  className = '',\r\n  showCursor = true,\r\n  hideCursorWhileTyping = false,\r\n  cursorCharacter = '|',\r\n  cursorClassName = '',\r\n  cursorBlinkDuration = 0.5,\r\n  textColors = [],\r\n  variableSpeed,\r\n  onSentenceComplete,\r\n  startOnVisible = false,\r\n  reverseMode = false,\r\n  ...props\r\n}) => {\r\n  const [displayedText, setDisplayedText] = useState('');\r\n  const [currentCharIndex, setCurrentCharIndex] = useState(0);\r\n  const [isDeleting, setIsDeleting] = useState(false);\r\n  const [currentTextIndex, setCurrentTextIndex] = useState(0);\r\n  const [isVisible, setIsVisible] = useState(!startOnVisible);\r\n  const cursorRef = useRef(null);\r\n  const containerRef = useRef(null);\r\n\r\n  const textArray = useMemo(() => (Array.isArray(text) ? text : [text]), [text]);\r\n\r\n  const getRandomSpeed = useCallback(() => {\r\n    if (!variableSpeed) return typingSpeed;\r\n    const { min, max } = variableSpeed;\r\n    return Math.random() * (max - min) + min;\r\n  }, [variableSpeed, typingSpeed]);\r\n\r\n  const getCurrentTextColor = () => {\r\n    if (textColors.length === 0) return '#ffffff';\r\n    return textColors[currentTextIndex % textColors.length];\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!startOnVisible || !containerRef.current) return;\r\n\r\n    const observer = new IntersectionObserver(\r\n      entries => {\r\n        entries.forEach(entry => {\r\n          if (entry.isIntersecting) {\r\n            setIsVisible(true);\r\n          }\r\n        });\r\n      },\r\n      { threshold: 0.1 }\r\n    );\r\n\r\n    observer.observe(containerRef.current);\r\n    return () => observer.disconnect();\r\n  }, [startOnVisible]);\r\n\r\n  useEffect(() => {\r\n    if (showCursor && cursorRef.current) {\r\n      gsap.set(cursorRef.current, { opacity: 1 });\r\n      gsap.to(cursorRef.current, {\r\n        opacity: 0,\r\n        duration: cursorBlinkDuration,\r\n        repeat: -1,\r\n        yoyo: true,\r\n        ease: 'power2.inOut'\r\n      });\r\n    }\r\n  }, [showCursor, cursorBlinkDuration]);\r\n\r\n  useEffect(() => {\r\n    if (!isVisible) return;\r\n\r\n    let timeout;\r\n\r\n    const currentText = textArray[currentTextIndex];\r\n    const processedText = reverseMode ? currentText.split('').reverse().join('') : currentText;\r\n\r\n    const executeTypingAnimation = () => {\r\n      if (isDeleting) {\r\n        if (displayedText === '') {\r\n          setIsDeleting(false);\r\n          if (currentTextIndex === textArray.length - 1 && !loop) {\r\n            return;\r\n          }\r\n\r\n          if (onSentenceComplete) {\r\n            onSentenceComplete(textArray[currentTextIndex], currentTextIndex);\r\n          }\r\n\r\n          setCurrentTextIndex(prev => (prev + 1) % textArray.length);\r\n          setCurrentCharIndex(0);\r\n          timeout = setTimeout(() => {}, pauseDuration);\r\n        } else {\r\n          timeout = setTimeout(() => {\r\n            setDisplayedText(prev => prev.slice(0, -1));\r\n          }, deletingSpeed);\r\n        }\r\n      } else {\r\n        if (currentCharIndex < processedText.length) {\r\n          timeout = setTimeout(\r\n            () => {\r\n              setDisplayedText(prev => prev + processedText[currentCharIndex]);\r\n              setCurrentCharIndex(prev => prev + 1);\r\n            },\r\n            variableSpeed ? getRandomSpeed() : typingSpeed\r\n          );\r\n        } else if (textArray.length > 1) {\r\n          timeout = setTimeout(() => {\r\n            setIsDeleting(true);\r\n          }, pauseDuration);\r\n        }\r\n      }\r\n    };\r\n\r\n    if (currentCharIndex === 0 && !isDeleting && displayedText === '') {\r\n      timeout = setTimeout(executeTypingAnimation, initialDelay);\r\n    } else {\r\n      executeTypingAnimation();\r\n    }\r\n\r\n    return () => clearTimeout(timeout);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [\r\n    currentCharIndex,\r\n    displayedText,\r\n    isDeleting,\r\n    typingSpeed,\r\n    deletingSpeed,\r\n    pauseDuration,\r\n    textArray,\r\n    currentTextIndex,\r\n    loop,\r\n    initialDelay,\r\n    isVisible,\r\n    reverseMode,\r\n    variableSpeed,\r\n    onSentenceComplete\r\n  ]);\r\n\r\n  const shouldHideCursor =\r\n    hideCursorWhileTyping && (currentCharIndex < textArray[currentTextIndex].length || isDeleting);\r\n\r\n  return createElement(\r\n    Component,\r\n    {\r\n      ref: containerRef,\r\n      className: `inline-block whitespace-pre-wrap tracking-tight ${className}`,\r\n      ...props\r\n    },\r\n    <span className=\"inline\" style={{ color: getCurrentTextColor() }}>\r\n      {displayedText}\r\n    </span>,\r\n    showCursor && (\r\n      <span\r\n        ref={cursorRef}\r\n        className={`ml-1 inline-block opacity-100 ${shouldHideCursor ? 'hidden' : ''} ${cursorClassName}`}\r\n      >\r\n        {cursorCharacter}\r\n      </span>\r\n    )\r\n  );\r\n};\r\n\r\nexport default TextType;\r\n",
      "type": "registry:component"
    }
  ]
}