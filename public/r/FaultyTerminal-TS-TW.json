{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "FaultyTerminal-TS-TW",
  "type": "registry:block",
  "title": "FaultyTerminal",
  "description": "Terminal CRT scanline squares effect with flicker + noise.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/FaultyTerminal/FaultyTerminal.tsx",
      "content": "import { Renderer, Program, Mesh, Color, Triangle } from 'ogl';\r\nimport React, { useEffect, useRef, useMemo, useCallback } from 'react';\r\n\r\ntype Vec2 = [number, number];\r\n\r\nexport interface FaultyTerminalProps extends React.HTMLAttributes<HTMLDivElement> {\r\n  scale?: number;\r\n  gridMul?: Vec2;\r\n  digitSize?: number;\r\n  timeScale?: number;\r\n  pause?: boolean;\r\n  scanlineIntensity?: number;\r\n  glitchAmount?: number;\r\n  flickerAmount?: number;\r\n  noiseAmp?: number;\r\n  chromaticAberration?: number;\r\n  dither?: number | boolean;\r\n  curvature?: number;\r\n  tint?: string;\r\n  mouseReact?: boolean;\r\n  mouseStrength?: number;\r\n  dpr?: number;\r\n  pageLoadAnimation?: boolean;\r\n  brightness?: number;\r\n}\r\n\r\nconst vertexShader = `\r\nattribute vec2 position;\r\nattribute vec2 uv;\r\nvarying vec2 vUv;\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `\r\nprecision mediump float;\r\n\r\nvarying vec2 vUv;\r\n\r\nuniform float iTime;\r\nuniform vec3  iResolution;\r\nuniform float uScale;\r\n\r\nuniform vec2  uGridMul;\r\nuniform float uDigitSize;\r\nuniform float uScanlineIntensity;\r\nuniform float uGlitchAmount;\r\nuniform float uFlickerAmount;\r\nuniform float uNoiseAmp;\r\nuniform float uChromaticAberration;\r\nuniform float uDither;\r\nuniform float uCurvature;\r\nuniform vec3  uTint;\r\nuniform vec2  uMouse;\r\nuniform float uMouseStrength;\r\nuniform float uUseMouse;\r\nuniform float uPageLoadProgress;\r\nuniform float uUsePageLoadAnimation;\r\nuniform float uBrightness;\r\n\r\nfloat time;\r\n\r\nfloat hash21(vec2 p){\r\n  p = fract(p * 234.56);\r\n  p += dot(p, p + 34.56);\r\n  return fract(p.x * p.y);\r\n}\r\n\r\nfloat noise(vec2 p)\r\n{\r\n  return sin(p.x * 10.0) * sin(p.y * (3.0 + sin(time * 0.090909))) + 0.2; \r\n}\r\n\r\nmat2 rotate(float angle)\r\n{\r\n  float c = cos(angle);\r\n  float s = sin(angle);\r\n  return mat2(c, -s, s, c);\r\n}\r\n\r\nfloat fbm(vec2 p)\r\n{\r\n  p *= 1.1;\r\n  float f = 0.0;\r\n  float amp = 0.5 * uNoiseAmp;\r\n  \r\n  mat2 modify0 = rotate(time * 0.02);\r\n  f += amp * noise(p);\r\n  p = modify0 * p * 2.0;\r\n  amp *= 0.454545;\r\n  \r\n  mat2 modify1 = rotate(time * 0.02);\r\n  f += amp * noise(p);\r\n  p = modify1 * p * 2.0;\r\n  amp *= 0.454545;\r\n  \r\n  mat2 modify2 = rotate(time * 0.08);\r\n  f += amp * noise(p);\r\n  \r\n  return f;\r\n}\r\n\r\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\r\n  vec2 offset1 = vec2(1.0);\r\n  vec2 offset0 = vec2(0.0);\r\n  mat2 rot01 = rotate(0.1 * time);\r\n  mat2 rot1 = rotate(0.1);\r\n  \r\n  q = vec2(fbm(p + offset1), fbm(rot01 * p + offset1));\r\n  r = vec2(fbm(rot1 * q + offset0), fbm(q + offset0));\r\n  return fbm(p + r);\r\n}\r\n\r\nfloat digit(vec2 p){\r\n    vec2 grid = uGridMul * 15.0;\r\n    vec2 s = floor(p * grid) / grid;\r\n    p = p * grid;\r\n    vec2 q, r;\r\n    float intensity = pattern(s * 0.1, q, r) * 1.3 - 0.03;\r\n    \r\n    if(uUseMouse > 0.5){\r\n        vec2 mouseWorld = uMouse * uScale;\r\n        float distToMouse = distance(s, mouseWorld);\r\n        float mouseInfluence = exp(-distToMouse * 8.0) * uMouseStrength * 10.0;\r\n        intensity += mouseInfluence;\r\n        \r\n        float ripple = sin(distToMouse * 20.0 - iTime * 5.0) * 0.1 * mouseInfluence;\r\n        intensity += ripple;\r\n    }\r\n    \r\n    if(uUsePageLoadAnimation > 0.5){\r\n        float cellRandom = fract(sin(dot(s, vec2(12.9898, 78.233))) * 43758.5453);\r\n        float cellDelay = cellRandom * 0.8;\r\n        float cellProgress = clamp((uPageLoadProgress - cellDelay) / 0.2, 0.0, 1.0);\r\n        \r\n        float fadeAlpha = smoothstep(0.0, 1.0, cellProgress);\r\n        intensity *= fadeAlpha;\r\n    }\r\n    \r\n    p = fract(p);\r\n    p *= uDigitSize;\r\n    \r\n    float px5 = p.x * 5.0;\r\n    float py5 = (1.0 - p.y) * 5.0;\r\n    float x = fract(px5);\r\n    float y = fract(py5);\r\n    \r\n    float i = floor(py5) - 2.0;\r\n    float j = floor(px5) - 2.0;\r\n    float n = i * i + j * j;\r\n    float f = n * 0.0625;\r\n    \r\n    float isOn = step(0.1, intensity - f);\r\n    float brightness = isOn * (0.2 + y * 0.8) * (0.75 + x * 0.25);\r\n    \r\n    return step(0.0, p.x) * step(p.x, 1.0) * step(0.0, p.y) * step(p.y, 1.0) * brightness;\r\n}\r\n\r\nfloat onOff(float a, float b, float c)\r\n{\r\n  return step(c, sin(iTime + a * cos(iTime * b))) * uFlickerAmount;\r\n}\r\n\r\nfloat displace(vec2 look)\r\n{\r\n    float y = look.y - mod(iTime * 0.25, 1.0);\r\n    float window = 1.0 / (1.0 + 50.0 * y * y);\r\n    return sin(look.y * 20.0 + iTime) * 0.0125 * onOff(4.0, 2.0, 0.8) * (1.0 + cos(iTime * 60.0)) * window;\r\n}\r\n\r\nvec3 getColor(vec2 p){\r\n    \r\n    float bar = step(mod(p.y + time * 20.0, 1.0), 0.2) * 0.4 + 1.0;\r\n    bar *= uScanlineIntensity;\r\n    \r\n    float displacement = displace(p);\r\n    p.x += displacement;\r\n\r\n    if (uGlitchAmount != 1.0) {\r\n      float extra = displacement * (uGlitchAmount - 1.0);\r\n      p.x += extra;\r\n    }\r\n\r\n    float middle = digit(p);\r\n    \r\n    const float off = 0.002;\r\n    float sum = digit(p + vec2(-off, -off)) + digit(p + vec2(0.0, -off)) + digit(p + vec2(off, -off)) +\r\n                digit(p + vec2(-off, 0.0)) + digit(p + vec2(0.0, 0.0)) + digit(p + vec2(off, 0.0)) +\r\n                digit(p + vec2(-off, off)) + digit(p + vec2(0.0, off)) + digit(p + vec2(off, off));\r\n    \r\n    vec3 baseColor = vec3(0.9) * middle + sum * 0.1 * vec3(1.0) * bar;\r\n    return baseColor;\r\n}\r\n\r\nvec2 barrel(vec2 uv){\r\n  vec2 c = uv * 2.0 - 1.0;\r\n  float r2 = dot(c, c);\r\n  c *= 1.0 + uCurvature * r2;\r\n  return c * 0.5 + 0.5;\r\n}\r\n\r\nvoid main() {\r\n    time = iTime * 0.333333;\r\n    vec2 uv = vUv;\r\n\r\n    if(uCurvature != 0.0){\r\n      uv = barrel(uv);\r\n    }\r\n    \r\n    vec2 p = uv * uScale;\r\n    vec3 col = getColor(p);\r\n\r\n    if(uChromaticAberration != 0.0){\r\n      vec2 ca = vec2(uChromaticAberration) / iResolution.xy;\r\n      col.r = getColor(p + ca).r;\r\n      col.b = getColor(p - ca).b;\r\n    }\r\n\r\n    col *= uTint;\r\n    col *= uBrightness;\r\n\r\n    if(uDither > 0.0){\r\n      float rnd = hash21(gl_FragCoord.xy);\r\n      col += (rnd - 0.5) * (uDither * 0.003922);\r\n    }\r\n\r\n    gl_FragColor = vec4(col, 1.0);\r\n}\r\n`;\r\n\r\nfunction hexToRgb(hex: string): [number, number, number] {\r\n  let h = hex.replace('#', '').trim();\r\n  if (h.length === 3)\r\n    h = h\r\n      .split('')\r\n      .map(c => c + c)\r\n      .join('');\r\n  const num = parseInt(h, 16);\r\n  return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\r\n}\r\n\r\nexport default function FaultyTerminal({\r\n  scale = 1,\r\n  gridMul = [2, 1],\r\n  digitSize = 1.5,\r\n  timeScale = 0.3,\r\n  pause = false,\r\n  scanlineIntensity = 0.3,\r\n  glitchAmount = 1,\r\n  flickerAmount = 1,\r\n  noiseAmp = 1,\r\n  chromaticAberration = 0,\r\n  dither = 0,\r\n  curvature = 0.2,\r\n  tint = '#ffffff',\r\n  mouseReact = true,\r\n  mouseStrength = 0.2,\r\n  dpr = Math.min(window.devicePixelRatio || 1, 2),\r\n  pageLoadAnimation = true,\r\n  brightness = 1,\r\n  className,\r\n  style,\r\n  ...rest\r\n}: FaultyTerminalProps) {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const programRef = useRef<Program>(null);\r\n  const rendererRef = useRef<Renderer>(null);\r\n  const mouseRef = useRef({ x: 0.5, y: 0.5 });\r\n  const smoothMouseRef = useRef({ x: 0.5, y: 0.5 });\r\n  const frozenTimeRef = useRef(0);\r\n  const rafRef = useRef<number>(0);\r\n  const loadAnimationStartRef = useRef<number>(0);\r\n  const timeOffsetRef = useRef<number>(Math.random() * 100);\r\n\r\n  const tintVec = useMemo(() => hexToRgb(tint), [tint]);\r\n\r\n  const ditherValue = useMemo(() => (typeof dither === 'boolean' ? (dither ? 1 : 0) : dither), [dither]);\r\n\r\n  const handleMouseMove = useCallback((e: MouseEvent) => {\r\n    const ctn = containerRef.current;\r\n    if (!ctn) return;\r\n    const rect = ctn.getBoundingClientRect();\r\n    const x = (e.clientX - rect.left) / rect.width;\r\n    const y = 1 - (e.clientY - rect.top) / rect.height;\r\n    mouseRef.current = { x, y };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const ctn = containerRef.current;\r\n    if (!ctn) return;\r\n\r\n    const renderer = new Renderer({ dpr });\r\n    rendererRef.current = renderer;\r\n    const gl = renderer.gl;\r\n    gl.clearColor(0, 0, 0, 1);\r\n\r\n    const geometry = new Triangle(gl);\r\n\r\n    const program = new Program(gl, {\r\n      vertex: vertexShader,\r\n      fragment: fragmentShader,\r\n      uniforms: {\r\n        iTime: { value: 0 },\r\n        iResolution: {\r\n          value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height)\r\n        },\r\n        uScale: { value: scale },\r\n\r\n        uGridMul: { value: new Float32Array(gridMul) },\r\n        uDigitSize: { value: digitSize },\r\n        uScanlineIntensity: { value: scanlineIntensity },\r\n        uGlitchAmount: { value: glitchAmount },\r\n        uFlickerAmount: { value: flickerAmount },\r\n        uNoiseAmp: { value: noiseAmp },\r\n        uChromaticAberration: { value: chromaticAberration },\r\n        uDither: { value: ditherValue },\r\n        uCurvature: { value: curvature },\r\n        uTint: { value: new Color(tintVec[0], tintVec[1], tintVec[2]) },\r\n        uMouse: {\r\n          value: new Float32Array([smoothMouseRef.current.x, smoothMouseRef.current.y])\r\n        },\r\n        uMouseStrength: { value: mouseStrength },\r\n        uUseMouse: { value: mouseReact ? 1 : 0 },\r\n        uPageLoadProgress: { value: pageLoadAnimation ? 0 : 1 },\r\n        uUsePageLoadAnimation: { value: pageLoadAnimation ? 1 : 0 },\r\n        uBrightness: { value: brightness }\r\n      }\r\n    });\r\n    programRef.current = program;\r\n\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n\r\n    function resize() {\r\n      if (!ctn || !renderer) return;\r\n      renderer.setSize(ctn.offsetWidth, ctn.offsetHeight);\r\n      program.uniforms.iResolution.value = new Color(\r\n        gl.canvas.width,\r\n        gl.canvas.height,\r\n        gl.canvas.width / gl.canvas.height\r\n      );\r\n    }\r\n\r\n    const resizeObserver = new ResizeObserver(() => resize());\r\n    resizeObserver.observe(ctn);\r\n    resize();\r\n\r\n    const update = (t: number) => {\r\n      rafRef.current = requestAnimationFrame(update);\r\n\r\n      if (pageLoadAnimation && loadAnimationStartRef.current === 0) {\r\n        loadAnimationStartRef.current = t;\r\n      }\r\n\r\n      if (!pause) {\r\n        const elapsed = (t * 0.001 + timeOffsetRef.current) * timeScale;\r\n        program.uniforms.iTime.value = elapsed;\r\n        frozenTimeRef.current = elapsed;\r\n      } else {\r\n        program.uniforms.iTime.value = frozenTimeRef.current;\r\n      }\r\n\r\n      if (pageLoadAnimation && loadAnimationStartRef.current > 0) {\r\n        const animationDuration = 2000;\r\n        const animationElapsed = t - loadAnimationStartRef.current;\r\n        const progress = Math.min(animationElapsed / animationDuration, 1);\r\n        program.uniforms.uPageLoadProgress.value = progress;\r\n      }\r\n\r\n      if (mouseReact) {\r\n        const dampingFactor = 0.08;\r\n        const smoothMouse = smoothMouseRef.current;\r\n        const mouse = mouseRef.current;\r\n        smoothMouse.x += (mouse.x - smoothMouse.x) * dampingFactor;\r\n        smoothMouse.y += (mouse.y - smoothMouse.y) * dampingFactor;\r\n\r\n        const mouseUniform = program.uniforms.uMouse.value as Float32Array;\r\n        mouseUniform[0] = smoothMouse.x;\r\n        mouseUniform[1] = smoothMouse.y;\r\n      }\r\n\r\n      renderer.render({ scene: mesh });\r\n    };\r\n    rafRef.current = requestAnimationFrame(update);\r\n    ctn.appendChild(gl.canvas);\r\n\r\n    if (mouseReact) ctn.addEventListener('mousemove', handleMouseMove);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(rafRef.current);\r\n      resizeObserver.disconnect();\r\n      if (mouseReact) ctn.removeEventListener('mousemove', handleMouseMove);\r\n      if (gl.canvas.parentElement === ctn) ctn.removeChild(gl.canvas);\r\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\r\n      loadAnimationStartRef.current = 0;\r\n      timeOffsetRef.current = Math.random() * 100;\r\n    };\r\n  }, [\r\n    dpr,\r\n    pause,\r\n    timeScale,\r\n    scale,\r\n    gridMul,\r\n    digitSize,\r\n    scanlineIntensity,\r\n    glitchAmount,\r\n    flickerAmount,\r\n    noiseAmp,\r\n    chromaticAberration,\r\n    ditherValue,\r\n    curvature,\r\n    tintVec,\r\n    mouseReact,\r\n    mouseStrength,\r\n    pageLoadAnimation,\r\n    brightness,\r\n    handleMouseMove\r\n  ]);\r\n\r\n  return (\r\n    <div ref={containerRef} className={`w-full h-full relative overflow-hidden ${className}`} style={style} {...rest} />\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}