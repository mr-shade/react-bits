{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "DecryptedText-TS-TW",
  "type": "registry:block",
  "title": "DecryptedText",
  "description": "Hacker-style decryption cycling random glyphs until resolving to real text.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/TextAnimations/DecryptedText/DecryptedText.tsx",
      "content": "import { useEffect, useState, useRef } from 'react';\r\nimport { motion, HTMLMotionProps } from 'motion/react';\r\n\r\ninterface DecryptedTextProps extends HTMLMotionProps<'span'> {\r\n  text: string;\r\n  speed?: number;\r\n  maxIterations?: number;\r\n  sequential?: boolean;\r\n  revealDirection?: 'start' | 'end' | 'center';\r\n  useOriginalCharsOnly?: boolean;\r\n  characters?: string;\r\n  className?: string;\r\n  encryptedClassName?: string;\r\n  parentClassName?: string;\r\n  animateOn?: 'view' | 'hover' | 'both';\r\n}\r\n\r\nexport default function DecryptedText({\r\n  text,\r\n  speed = 50,\r\n  maxIterations = 10,\r\n  sequential = false,\r\n  revealDirection = 'start',\r\n  useOriginalCharsOnly = false,\r\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',\r\n  className = '',\r\n  parentClassName = '',\r\n  encryptedClassName = '',\r\n  animateOn = 'hover',\r\n  ...props\r\n}: DecryptedTextProps) {\r\n  const [displayText, setDisplayText] = useState<string>(text);\r\n  const [isHovering, setIsHovering] = useState<boolean>(false);\r\n  const [isScrambling, setIsScrambling] = useState<boolean>(false);\r\n  const [revealedIndices, setRevealedIndices] = useState<Set<number>>(new Set());\r\n  const [hasAnimated, setHasAnimated] = useState<boolean>(false);\r\n  const containerRef = useRef<HTMLSpanElement>(null);\r\n\r\n  useEffect(() => {\r\n    let interval: NodeJS.Timeout;\r\n    let currentIteration = 0;\r\n\r\n    const getNextIndex = (revealedSet: Set<number>): number => {\r\n      const textLength = text.length;\r\n      switch (revealDirection) {\r\n        case 'start':\r\n          return revealedSet.size;\r\n        case 'end':\r\n          return textLength - 1 - revealedSet.size;\r\n        case 'center': {\r\n          const middle = Math.floor(textLength / 2);\r\n          const offset = Math.floor(revealedSet.size / 2);\r\n          const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\r\n\r\n          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\r\n            return nextIndex;\r\n          }\r\n          for (let i = 0; i < textLength; i++) {\r\n            if (!revealedSet.has(i)) return i;\r\n          }\r\n          return 0;\r\n        }\r\n        default:\r\n          return revealedSet.size;\r\n      }\r\n    };\r\n\r\n    const availableChars = useOriginalCharsOnly\r\n      ? Array.from(new Set(text.split(''))).filter(char => char !== ' ')\r\n      : characters.split('');\r\n\r\n    const shuffleText = (originalText: string, currentRevealed: Set<number>): string => {\r\n      if (useOriginalCharsOnly) {\r\n        const positions = originalText.split('').map((char, i) => ({\r\n          char,\r\n          isSpace: char === ' ',\r\n          index: i,\r\n          isRevealed: currentRevealed.has(i)\r\n        }));\r\n\r\n        const nonSpaceChars = positions.filter(p => !p.isSpace && !p.isRevealed).map(p => p.char);\r\n\r\n        for (let i = nonSpaceChars.length - 1; i > 0; i--) {\r\n          const j = Math.floor(Math.random() * (i + 1));\r\n          [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\r\n        }\r\n\r\n        let charIndex = 0;\r\n        return positions\r\n          .map(p => {\r\n            if (p.isSpace) return ' ';\r\n            if (p.isRevealed) return originalText[p.index];\r\n            return nonSpaceChars[charIndex++];\r\n          })\r\n          .join('');\r\n      } else {\r\n        return originalText\r\n          .split('')\r\n          .map((char, i) => {\r\n            if (char === ' ') return ' ';\r\n            if (currentRevealed.has(i)) return originalText[i];\r\n            return availableChars[Math.floor(Math.random() * availableChars.length)];\r\n          })\r\n          .join('');\r\n      }\r\n    };\r\n\r\n    if (isHovering) {\r\n      setIsScrambling(true);\r\n      interval = setInterval(() => {\r\n        setRevealedIndices(prevRevealed => {\r\n          if (sequential) {\r\n            if (prevRevealed.size < text.length) {\r\n              const nextIndex = getNextIndex(prevRevealed);\r\n              const newRevealed = new Set(prevRevealed);\r\n              newRevealed.add(nextIndex);\r\n              setDisplayText(shuffleText(text, newRevealed));\r\n              return newRevealed;\r\n            } else {\r\n              clearInterval(interval);\r\n              setIsScrambling(false);\r\n              return prevRevealed;\r\n            }\r\n          } else {\r\n            setDisplayText(shuffleText(text, prevRevealed));\r\n            currentIteration++;\r\n            if (currentIteration >= maxIterations) {\r\n              clearInterval(interval);\r\n              setIsScrambling(false);\r\n              setDisplayText(text);\r\n            }\r\n            return prevRevealed;\r\n          }\r\n        });\r\n      }, speed);\r\n    } else {\r\n      setDisplayText(text);\r\n      setRevealedIndices(new Set());\r\n      setIsScrambling(false);\r\n    }\r\n\r\n    return () => {\r\n      if (interval) clearInterval(interval);\r\n    };\r\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\r\n\r\n  useEffect(() => {\r\n    if (animateOn !== 'view' && animateOn !== 'both') return;\r\n\r\n    const observerCallback = (entries: IntersectionObserverEntry[]) => {\r\n      entries.forEach(entry => {\r\n        if (entry.isIntersecting && !hasAnimated) {\r\n          setIsHovering(true);\r\n          setHasAnimated(true);\r\n        }\r\n      });\r\n    };\r\n\r\n    const observerOptions = {\r\n      root: null,\r\n      rootMargin: '0px',\r\n      threshold: 0.1\r\n    };\r\n\r\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\r\n    const currentRef = containerRef.current;\r\n    if (currentRef) {\r\n      observer.observe(currentRef);\r\n    }\r\n\r\n    return () => {\r\n      if (currentRef) observer.unobserve(currentRef);\r\n    };\r\n  }, [animateOn, hasAnimated]);\r\n\r\n  const hoverProps =\r\n    animateOn === 'hover' || animateOn === 'both'\r\n      ? {\r\n          onMouseEnter: () => setIsHovering(true),\r\n          onMouseLeave: () => setIsHovering(false)\r\n        }\r\n      : {};\r\n\r\n  return (\r\n    <motion.span\r\n      ref={containerRef}\r\n      className={`inline-block whitespace-pre-wrap ${parentClassName}`}\r\n      {...hoverProps}\r\n      {...props}\r\n    >\r\n      <span className=\"sr-only\">{displayText}</span>\r\n\r\n      <span aria-hidden=\"true\">\r\n        {displayText.split('').map((char, index) => {\r\n          const isRevealedOrDone = revealedIndices.has(index) || !isScrambling || !isHovering;\r\n\r\n          return (\r\n            <span key={index} className={isRevealedOrDone ? className : encryptedClassName}>\r\n              {char}\r\n            </span>\r\n          );\r\n        })}\r\n      </span>\r\n    </motion.span>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}