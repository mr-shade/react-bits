{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "InfiniteMenu-TS-TW",
  "type": "registry:block",
  "title": "InfiniteMenu",
  "description": "Horizontally looping menu effect that scrolls endlessly with seamless wrap.",
  "dependencies": [
    "gl-matrix"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Components/InfiniteMenu/InfiniteMenu.tsx",
      "content": "import { FC, useRef, useState, useEffect, MutableRefObject } from 'react';\r\nimport { mat4, quat, vec2, vec3 } from 'gl-matrix';\r\n\r\nconst discVertShaderSource = `#version 300 es\r\n\r\nuniform mat4 uWorldMatrix;\r\nuniform mat4 uViewMatrix;\r\nuniform mat4 uProjectionMatrix;\r\nuniform vec3 uCameraPosition;\r\nuniform vec4 uRotationAxisVelocity;\r\n\r\nin vec3 aModelPosition;\r\nin vec3 aModelNormal;\r\nin vec2 aModelUvs;\r\nin mat4 aInstanceMatrix;\r\n\r\nout vec2 vUvs;\r\nout float vAlpha;\r\nflat out int vInstanceId;\r\n\r\n#define PI 3.141593\r\n\r\nvoid main() {\r\n    vec4 worldPosition = uWorldMatrix * aInstanceMatrix * vec4(aModelPosition, 1.);\r\n\r\n    vec3 centerPos = (uWorldMatrix * aInstanceMatrix * vec4(0., 0., 0., 1.)).xyz;\r\n    float radius = length(centerPos.xyz);\r\n\r\n    if (gl_VertexID > 0) {\r\n        vec3 rotationAxis = uRotationAxisVelocity.xyz;\r\n        float rotationVelocity = min(.15, uRotationAxisVelocity.w * 15.);\r\n        vec3 stretchDir = normalize(cross(centerPos, rotationAxis));\r\n        vec3 relativeVertexPos = normalize(worldPosition.xyz - centerPos);\r\n        float strength = dot(stretchDir, relativeVertexPos);\r\n        float invAbsStrength = min(0., abs(strength) - 1.);\r\n        strength = rotationVelocity * sign(strength) * abs(invAbsStrength * invAbsStrength * invAbsStrength + 1.);\r\n        worldPosition.xyz += stretchDir * strength;\r\n    }\r\n\r\n    worldPosition.xyz = radius * normalize(worldPosition.xyz);\r\n\r\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\r\n\r\n    vAlpha = smoothstep(0.5, 1., normalize(worldPosition.xyz).z) * .9 + .1;\r\n    vUvs = aModelUvs;\r\n    vInstanceId = gl_InstanceID;\r\n}\r\n`;\r\n\r\nconst discFragShaderSource = `#version 300 es\r\nprecision highp float;\r\n\r\nuniform sampler2D uTex;\r\nuniform int uItemCount;\r\nuniform int uAtlasSize;\r\n\r\nout vec4 outColor;\r\n\r\nin vec2 vUvs;\r\nin float vAlpha;\r\nflat in int vInstanceId;\r\n\r\nvoid main() {\r\n    int itemIndex = vInstanceId % uItemCount;\r\n    int cellsPerRow = uAtlasSize;\r\n    int cellX = itemIndex % cellsPerRow;\r\n    int cellY = itemIndex / cellsPerRow;\r\n    vec2 cellSize = vec2(1.0) / vec2(float(cellsPerRow));\r\n    vec2 cellOffset = vec2(float(cellX), float(cellY)) * cellSize;\r\n\r\n    ivec2 texSize = textureSize(uTex, 0);\r\n    float imageAspect = float(texSize.x) / float(texSize.y);\r\n    float containerAspect = 1.0;\r\n    \r\n    float scale = max(imageAspect / containerAspect, \r\n                     containerAspect / imageAspect);\r\n    \r\n    vec2 st = vec2(vUvs.x, 1.0 - vUvs.y);\r\n    st = (st - 0.5) * scale + 0.5;\r\n    \r\n    st = clamp(st, 0.0, 1.0);\r\n    st = st * cellSize + cellOffset;\r\n    \r\n    outColor = texture(uTex, st);\r\n    outColor.a *= vAlpha;\r\n}\r\n`;\r\n\r\nclass Face {\r\n  public a: number;\r\n  public b: number;\r\n  public c: number;\r\n\r\n  constructor(a: number, b: number, c: number) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n  }\r\n}\r\n\r\nclass Vertex {\r\n  public position: vec3;\r\n  public normal: vec3;\r\n  public uv: vec2;\r\n\r\n  constructor(x: number, y: number, z: number) {\r\n    this.position = vec3.fromValues(x, y, z);\r\n    this.normal = vec3.create();\r\n    this.uv = vec2.create();\r\n  }\r\n}\r\n\r\nclass Geometry {\r\n  public vertices: Vertex[];\r\n  public faces: Face[];\r\n\r\n  constructor() {\r\n    this.vertices = [];\r\n    this.faces = [];\r\n  }\r\n\r\n  public addVertex(...args: number[]): this {\r\n    for (let i = 0; i < args.length; i += 3) {\r\n      this.vertices.push(new Vertex(args[i], args[i + 1], args[i + 2]));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public addFace(...args: number[]): this {\r\n    for (let i = 0; i < args.length; i += 3) {\r\n      this.faces.push(new Face(args[i], args[i + 1], args[i + 2]));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  public get lastVertex(): Vertex {\r\n    return this.vertices[this.vertices.length - 1];\r\n  }\r\n\r\n  public subdivide(divisions = 1): this {\r\n    const midPointCache: Record<string, number> = {};\r\n    let f = this.faces;\r\n\r\n    for (let div = 0; div < divisions; ++div) {\r\n      const newFaces = new Array<Face>(f.length * 4);\r\n\r\n      f.forEach((face, ndx) => {\r\n        const mAB = this.getMidPoint(face.a, face.b, midPointCache);\r\n        const mBC = this.getMidPoint(face.b, face.c, midPointCache);\r\n        const mCA = this.getMidPoint(face.c, face.a, midPointCache);\r\n\r\n        const i = ndx * 4;\r\n        newFaces[i + 0] = new Face(face.a, mAB, mCA);\r\n        newFaces[i + 1] = new Face(face.b, mBC, mAB);\r\n        newFaces[i + 2] = new Face(face.c, mCA, mBC);\r\n        newFaces[i + 3] = new Face(mAB, mBC, mCA);\r\n      });\r\n\r\n      f = newFaces;\r\n    }\r\n\r\n    this.faces = f;\r\n    return this;\r\n  }\r\n\r\n  public spherize(radius = 1): this {\r\n    this.vertices.forEach(vertex => {\r\n      vec3.normalize(vertex.normal, vertex.position);\r\n      vec3.scale(vertex.position, vertex.normal, radius);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  public get data(): {\r\n    vertices: Float32Array;\r\n    indices: Uint16Array;\r\n    normals: Float32Array;\r\n    uvs: Float32Array;\r\n  } {\r\n    return {\r\n      vertices: this.vertexData,\r\n      indices: this.indexData,\r\n      normals: this.normalData,\r\n      uvs: this.uvData\r\n    };\r\n  }\r\n\r\n  public get vertexData(): Float32Array {\r\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.position)));\r\n  }\r\n\r\n  public get normalData(): Float32Array {\r\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.normal)));\r\n  }\r\n\r\n  public get uvData(): Float32Array {\r\n    return new Float32Array(this.vertices.flatMap(v => Array.from(v.uv)));\r\n  }\r\n\r\n  public get indexData(): Uint16Array {\r\n    return new Uint16Array(this.faces.flatMap(f => [f.a, f.b, f.c]));\r\n  }\r\n\r\n  public getMidPoint(ndxA: number, ndxB: number, cache: Record<string, number>): number {\r\n    const cacheKey = ndxA < ndxB ? `k_${ndxB}_${ndxA}` : `k_${ndxA}_${ndxB}`;\r\n    if (Object.prototype.hasOwnProperty.call(cache, cacheKey)) {\r\n      return cache[cacheKey];\r\n    }\r\n    const a = this.vertices[ndxA].position;\r\n    const b = this.vertices[ndxB].position;\r\n    const ndx = this.vertices.length;\r\n    cache[cacheKey] = ndx;\r\n    this.addVertex((a[0] + b[0]) * 0.5, (a[1] + b[1]) * 0.5, (a[2] + b[2]) * 0.5);\r\n    return ndx;\r\n  }\r\n}\r\n\r\nclass IcosahedronGeometry extends Geometry {\r\n  constructor() {\r\n    super();\r\n    const t = Math.sqrt(5) * 0.5 + 0.5;\r\n    this.addVertex(\r\n      -1,\r\n      t,\r\n      0,\r\n      1,\r\n      t,\r\n      0,\r\n      -1,\r\n      -t,\r\n      0,\r\n      1,\r\n      -t,\r\n      0,\r\n      0,\r\n      -1,\r\n      t,\r\n      0,\r\n      1,\r\n      t,\r\n      0,\r\n      -1,\r\n      -t,\r\n      0,\r\n      1,\r\n      -t,\r\n      t,\r\n      0,\r\n      -1,\r\n      t,\r\n      0,\r\n      1,\r\n      -t,\r\n      0,\r\n      -1,\r\n      -t,\r\n      0,\r\n      1\r\n    ).addFace(\r\n      0,\r\n      11,\r\n      5,\r\n      0,\r\n      5,\r\n      1,\r\n      0,\r\n      1,\r\n      7,\r\n      0,\r\n      7,\r\n      10,\r\n      0,\r\n      10,\r\n      11,\r\n      1,\r\n      5,\r\n      9,\r\n      5,\r\n      11,\r\n      4,\r\n      11,\r\n      10,\r\n      2,\r\n      10,\r\n      7,\r\n      6,\r\n      7,\r\n      1,\r\n      8,\r\n      3,\r\n      9,\r\n      4,\r\n      3,\r\n      4,\r\n      2,\r\n      3,\r\n      2,\r\n      6,\r\n      3,\r\n      6,\r\n      8,\r\n      3,\r\n      8,\r\n      9,\r\n      4,\r\n      9,\r\n      5,\r\n      2,\r\n      4,\r\n      11,\r\n      6,\r\n      2,\r\n      10,\r\n      8,\r\n      6,\r\n      7,\r\n      9,\r\n      8,\r\n      1\r\n    );\r\n  }\r\n}\r\n\r\nclass DiscGeometry extends Geometry {\r\n  constructor(steps = 4, radius = 1) {\r\n    super();\r\n    const safeSteps = Math.max(4, steps);\r\n    const alpha = (2 * Math.PI) / safeSteps;\r\n\r\n    this.addVertex(0, 0, 0);\r\n    this.lastVertex.uv[0] = 0.5;\r\n    this.lastVertex.uv[1] = 0.5;\r\n\r\n    for (let i = 0; i < safeSteps; ++i) {\r\n      const x = Math.cos(alpha * i);\r\n      const y = Math.sin(alpha * i);\r\n      this.addVertex(radius * x, radius * y, 0);\r\n      this.lastVertex.uv[0] = x * 0.5 + 0.5;\r\n      this.lastVertex.uv[1] = y * 0.5 + 0.5;\r\n\r\n      if (i > 0) {\r\n        this.addFace(0, i, i + 1);\r\n      }\r\n    }\r\n    this.addFace(0, safeSteps, 1);\r\n  }\r\n}\r\n\r\nfunction createShader(gl: WebGL2RenderingContext, type: number, source: string): WebGLShader | null {\r\n  const shader = gl.createShader(type);\r\n  if (!shader) return null;\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n\r\n  if (success) {\r\n    return shader;\r\n  }\r\n\r\n  console.error(gl.getShaderInfoLog(shader));\r\n  gl.deleteShader(shader);\r\n  return null;\r\n}\r\n\r\nfunction createProgram(\r\n  gl: WebGL2RenderingContext,\r\n  shaderSources: [string, string],\r\n  transformFeedbackVaryings?: string[] | null,\r\n  attribLocations?: Record<string, number>\r\n): WebGLProgram | null {\r\n  const program = gl.createProgram();\r\n  if (!program) return null;\r\n\r\n  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {\r\n    const shader = createShader(gl, type, shaderSources[ndx]);\r\n    if (shader) {\r\n      gl.attachShader(program, shader);\r\n    }\r\n  });\r\n\r\n  if (transformFeedbackVaryings) {\r\n    gl.transformFeedbackVaryings(program, transformFeedbackVaryings, gl.SEPARATE_ATTRIBS);\r\n  }\r\n\r\n  if (attribLocations) {\r\n    for (const attrib in attribLocations) {\r\n      if (Object.prototype.hasOwnProperty.call(attribLocations, attrib)) {\r\n        gl.bindAttribLocation(program, attribLocations[attrib], attrib);\r\n      }\r\n    }\r\n  }\r\n\r\n  gl.linkProgram(program);\r\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n\r\n  if (success) {\r\n    return program;\r\n  }\r\n\r\n  console.error(gl.getProgramInfoLog(program));\r\n  gl.deleteProgram(program);\r\n  return null;\r\n}\r\n\r\nfunction makeVertexArray(\r\n  gl: WebGL2RenderingContext,\r\n  bufLocNumElmPairs: Array<[WebGLBuffer, number, number]>,\r\n  indices?: Uint16Array\r\n): WebGLVertexArrayObject | null {\r\n  const va = gl.createVertexArray();\r\n  if (!va) return null;\r\n\r\n  gl.bindVertexArray(va);\r\n\r\n  for (const [buffer, loc, numElem] of bufLocNumElmPairs) {\r\n    if (loc === -1) continue;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.enableVertexAttribArray(loc);\r\n    gl.vertexAttribPointer(loc, numElem, gl.FLOAT, false, 0, 0);\r\n  }\r\n\r\n  if (indices) {\r\n    const indexBuffer = gl.createBuffer();\r\n    if (indexBuffer) {\r\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\r\n    }\r\n  }\r\n\r\n  gl.bindVertexArray(null);\r\n  return va;\r\n}\r\n\r\nfunction resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {\r\n  const dpr = Math.min(2, window.devicePixelRatio || 1);\r\n  const displayWidth = Math.round(canvas.clientWidth * dpr);\r\n  const displayHeight = Math.round(canvas.clientHeight * dpr);\r\n  const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\r\n  if (needResize) {\r\n    canvas.width = displayWidth;\r\n    canvas.height = displayHeight;\r\n  }\r\n  return needResize;\r\n}\r\n\r\nfunction makeBuffer(gl: WebGL2RenderingContext, sizeOrData: number | ArrayBufferView, usage: number): WebGLBuffer {\r\n  const buf = gl.createBuffer();\r\n  if (!buf) {\r\n    throw new Error('Failed to create WebGL buffer.');\r\n  }\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buf);\r\n\r\n  if (typeof sizeOrData === 'number') {\r\n    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);\r\n  } else {\r\n    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);\r\n  }\r\n\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n  return buf;\r\n}\r\n\r\nfunction createAndSetupTexture(\r\n  gl: WebGL2RenderingContext,\r\n  minFilter: number,\r\n  magFilter: number,\r\n  wrapS: number,\r\n  wrapT: number\r\n): WebGLTexture {\r\n  const texture = gl.createTexture();\r\n  if (!texture) {\r\n    throw new Error('Failed to create WebGL texture.');\r\n  }\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n  return texture;\r\n}\r\n\r\ntype UpdateCallback = (deltaTime: number) => void;\r\n\r\nclass ArcballControl {\r\n  private canvas: HTMLCanvasElement;\r\n  private updateCallback: UpdateCallback;\r\n\r\n  public isPointerDown = false;\r\n  public orientation = quat.create();\r\n  public pointerRotation = quat.create();\r\n  public rotationVelocity = 0;\r\n  public rotationAxis = vec3.fromValues(1, 0, 0);\r\n\r\n  public snapDirection = vec3.fromValues(0, 0, -1);\r\n  public snapTargetDirection: vec3 | null = null;\r\n\r\n  private pointerPos = vec2.create();\r\n  private previousPointerPos = vec2.create();\r\n  private _rotationVelocity = 0;\r\n  private _combinedQuat = quat.create();\r\n\r\n  private readonly EPSILON = 0.1;\r\n  private readonly IDENTITY_QUAT = quat.create();\r\n\r\n  constructor(canvas: HTMLCanvasElement, updateCallback?: UpdateCallback) {\r\n    this.canvas = canvas;\r\n    this.updateCallback = updateCallback || (() => undefined);\r\n\r\n    canvas.addEventListener('pointerdown', (e: PointerEvent) => {\r\n      vec2.set(this.pointerPos, e.clientX, e.clientY);\r\n      vec2.copy(this.previousPointerPos, this.pointerPos);\r\n      this.isPointerDown = true;\r\n    });\r\n    canvas.addEventListener('pointerup', () => {\r\n      this.isPointerDown = false;\r\n    });\r\n    canvas.addEventListener('pointerleave', () => {\r\n      this.isPointerDown = false;\r\n    });\r\n    canvas.addEventListener('pointermove', (e: PointerEvent) => {\r\n      if (this.isPointerDown) {\r\n        vec2.set(this.pointerPos, e.clientX, e.clientY);\r\n      }\r\n    });\r\n    canvas.style.touchAction = 'none';\r\n  }\r\n\r\n  public update(deltaTime: number, targetFrameDuration = 16): void {\r\n    const timeScale = deltaTime / targetFrameDuration + 0.00001;\r\n    let angleFactor = timeScale;\r\n    const snapRotation = quat.create();\r\n\r\n    if (this.isPointerDown) {\r\n      const INTENSITY = 0.3 * timeScale;\r\n      const ANGLE_AMPLIFICATION = 5 / timeScale;\r\n      const midPointerPos = vec2.sub(vec2.create(), this.pointerPos, this.previousPointerPos);\r\n      vec2.scale(midPointerPos, midPointerPos, INTENSITY);\r\n\r\n      if (vec2.sqrLen(midPointerPos) > this.EPSILON) {\r\n        vec2.add(midPointerPos, this.previousPointerPos, midPointerPos);\r\n\r\n        const p = this.project(midPointerPos);\r\n        const q = this.project(this.previousPointerPos);\r\n        const a = vec3.normalize(vec3.create(), p);\r\n        const b = vec3.normalize(vec3.create(), q);\r\n\r\n        vec2.copy(this.previousPointerPos, midPointerPos);\r\n\r\n        angleFactor *= ANGLE_AMPLIFICATION;\r\n\r\n        this.quatFromVectors(a, b, this.pointerRotation, angleFactor);\r\n      } else {\r\n        quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);\r\n      }\r\n    } else {\r\n      const INTENSITY = 0.1 * timeScale;\r\n      quat.slerp(this.pointerRotation, this.pointerRotation, this.IDENTITY_QUAT, INTENSITY);\r\n\r\n      if (this.snapTargetDirection) {\r\n        const SNAPPING_INTENSITY = 0.2;\r\n        const a = this.snapTargetDirection;\r\n        const b = this.snapDirection;\r\n        const sqrDist = vec3.squaredDistance(a, b);\r\n        const distanceFactor = Math.max(0.1, 1 - sqrDist * 10);\r\n        angleFactor *= SNAPPING_INTENSITY * distanceFactor;\r\n        this.quatFromVectors(a, b, snapRotation, angleFactor);\r\n      }\r\n    }\r\n\r\n    const combinedQuat = quat.multiply(quat.create(), snapRotation, this.pointerRotation);\r\n    this.orientation = quat.multiply(quat.create(), combinedQuat, this.orientation);\r\n    quat.normalize(this.orientation, this.orientation);\r\n\r\n    const RA_INTENSITY = 0.8 * timeScale;\r\n    quat.slerp(this._combinedQuat, this._combinedQuat, combinedQuat, RA_INTENSITY);\r\n    quat.normalize(this._combinedQuat, this._combinedQuat);\r\n\r\n    const rad = Math.acos(this._combinedQuat[3]) * 2.0;\r\n    const s = Math.sin(rad / 2.0);\r\n    let rv = 0;\r\n    if (s > 0.000001) {\r\n      rv = rad / (2 * Math.PI);\r\n      this.rotationAxis[0] = this._combinedQuat[0] / s;\r\n      this.rotationAxis[1] = this._combinedQuat[1] / s;\r\n      this.rotationAxis[2] = this._combinedQuat[2] / s;\r\n    }\r\n\r\n    const RV_INTENSITY = 0.5 * timeScale;\r\n    this._rotationVelocity += (rv - this._rotationVelocity) * RV_INTENSITY;\r\n    this.rotationVelocity = this._rotationVelocity / timeScale;\r\n\r\n    this.updateCallback(deltaTime);\r\n  }\r\n\r\n  private quatFromVectors(a: vec3, b: vec3, out: quat, angleFactor = 1): { q: quat; axis: vec3; angle: number } {\r\n    const axis = vec3.cross(vec3.create(), a, b);\r\n    vec3.normalize(axis, axis);\r\n    const d = Math.max(-1, Math.min(1, vec3.dot(a, b)));\r\n    const angle = Math.acos(d) * angleFactor;\r\n    quat.setAxisAngle(out, axis, angle);\r\n    return { q: out, axis, angle };\r\n  }\r\n\r\n  private project(pos: vec2): vec3 {\r\n    const r = 2;\r\n    const w = this.canvas.clientWidth;\r\n    const h = this.canvas.clientHeight;\r\n    const s = Math.max(w, h) - 1;\r\n\r\n    const x = (2 * pos[0] - w - 1) / s;\r\n    const y = (2 * pos[1] - h - 1) / s;\r\n    let z = 0;\r\n    const xySq = x * x + y * y;\r\n    const rSq = r * r;\r\n\r\n    if (xySq <= rSq / 2.0) {\r\n      z = Math.sqrt(rSq - xySq);\r\n    } else {\r\n      z = rSq / Math.sqrt(xySq);\r\n    }\r\n    return vec3.fromValues(-x, y, z);\r\n  }\r\n}\r\n\r\ninterface MenuItem {\r\n  image: string;\r\n  link: string;\r\n  title: string;\r\n  description: string;\r\n}\r\n\r\ntype ActiveItemCallback = (index: number) => void;\r\ntype MovementChangeCallback = (isMoving: boolean) => void;\r\ntype InitCallback = (instance: InfiniteGridMenu) => void;\r\n\r\ninterface Camera {\r\n  matrix: mat4;\r\n  near: number;\r\n  far: number;\r\n  fov: number;\r\n  aspect: number;\r\n  position: vec3;\r\n  up: vec3;\r\n  matrices: {\r\n    view: mat4;\r\n    projection: mat4;\r\n    inversProjection: mat4;\r\n  };\r\n}\r\n\r\nclass InfiniteGridMenu {\r\n  private gl: WebGL2RenderingContext | null = null;\r\n  private discProgram: WebGLProgram | null = null;\r\n  private discVAO: WebGLVertexArrayObject | null = null;\r\n  private discBuffers!: {\r\n    vertices: Float32Array;\r\n    indices: Uint16Array;\r\n    normals: Float32Array;\r\n    uvs: Float32Array;\r\n  };\r\n  private icoGeo!: IcosahedronGeometry;\r\n  private discGeo!: DiscGeometry;\r\n  private worldMatrix = mat4.create();\r\n  private tex: WebGLTexture | null = null;\r\n  private control!: ArcballControl;\r\n\r\n  private discLocations!: {\r\n    aModelPosition: number;\r\n    aModelUvs: number;\r\n    aInstanceMatrix: number;\r\n    uWorldMatrix: WebGLUniformLocation | null;\r\n    uViewMatrix: WebGLUniformLocation | null;\r\n    uProjectionMatrix: WebGLUniformLocation | null;\r\n    uCameraPosition: WebGLUniformLocation | null;\r\n    uScaleFactor: WebGLUniformLocation | null;\r\n    uRotationAxisVelocity: WebGLUniformLocation | null;\r\n    uTex: WebGLUniformLocation | null;\r\n    uFrames: WebGLUniformLocation | null;\r\n    uItemCount: WebGLUniformLocation | null;\r\n    uAtlasSize: WebGLUniformLocation | null;\r\n  };\r\n\r\n  private viewportSize = vec2.create();\r\n  private drawBufferSize = vec2.create();\r\n\r\n  private discInstances!: {\r\n    matricesArray: Float32Array;\r\n    matrices: Float32Array[];\r\n    buffer: WebGLBuffer | null;\r\n  };\r\n\r\n  private instancePositions: vec3[] = [];\r\n  private DISC_INSTANCE_COUNT = 0;\r\n  private atlasSize = 1;\r\n\r\n  private _time = 0;\r\n  private _deltaTime = 0;\r\n  private _deltaFrames = 0;\r\n  private _frames = 0;\r\n\r\n  private movementActive = false;\r\n\r\n  private TARGET_FRAME_DURATION = 1000 / 60;\r\n  private SPHERE_RADIUS = 2;\r\n\r\n  public camera: Camera = {\r\n    matrix: mat4.create(),\r\n    near: 0.1,\r\n    far: 40,\r\n    fov: Math.PI / 4,\r\n    aspect: 1,\r\n    position: vec3.fromValues(0, 0, 3),\r\n    up: vec3.fromValues(0, 1, 0),\r\n    matrices: {\r\n      view: mat4.create(),\r\n      projection: mat4.create(),\r\n      inversProjection: mat4.create()\r\n    }\r\n  };\r\n\r\n  public smoothRotationVelocity = 0;\r\n  public scaleFactor = 1.0;\r\n\r\n  constructor(\r\n    private canvas: HTMLCanvasElement,\r\n    private items: MenuItem[],\r\n    private onActiveItemChange: ActiveItemCallback,\r\n    private onMovementChange: MovementChangeCallback,\r\n    onInit?: InitCallback\r\n  ) {\r\n    this.init(onInit);\r\n  }\r\n\r\n  public resize(): void {\r\n    const needsResize = resizeCanvasToDisplaySize(this.canvas);\r\n    if (!this.gl) return;\r\n    if (needsResize) {\r\n      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\r\n    }\r\n    this.updateProjectionMatrix();\r\n  }\r\n\r\n  public run(time = 0): void {\r\n    this._deltaTime = Math.min(32, time - this._time);\r\n    this._time = time;\r\n    this._deltaFrames = this._deltaTime / this.TARGET_FRAME_DURATION;\r\n    this._frames += this._deltaFrames;\r\n\r\n    this.animate(this._deltaTime);\r\n    this.render();\r\n\r\n    requestAnimationFrame(t => this.run(t));\r\n  }\r\n\r\n  private init(onInit?: InitCallback): void {\r\n    const gl = this.canvas.getContext('webgl2', {\r\n      antialias: true,\r\n      alpha: false\r\n    });\r\n    if (!gl) {\r\n      throw new Error('No WebGL 2 context!');\r\n    }\r\n    this.gl = gl;\r\n\r\n    vec2.set(this.viewportSize, this.canvas.clientWidth, this.canvas.clientHeight);\r\n    vec2.clone(this.drawBufferSize);\r\n\r\n    this.discProgram = createProgram(gl, [discVertShaderSource, discFragShaderSource], null, {\r\n      aModelPosition: 0,\r\n      aModelNormal: 1,\r\n      aModelUvs: 2,\r\n      aInstanceMatrix: 3\r\n    });\r\n\r\n    this.discLocations = {\r\n      aModelPosition: gl.getAttribLocation(this.discProgram!, 'aModelPosition'),\r\n      aModelUvs: gl.getAttribLocation(this.discProgram!, 'aModelUvs'),\r\n      aInstanceMatrix: gl.getAttribLocation(this.discProgram!, 'aInstanceMatrix'),\r\n      uWorldMatrix: gl.getUniformLocation(this.discProgram!, 'uWorldMatrix'),\r\n      uViewMatrix: gl.getUniformLocation(this.discProgram!, 'uViewMatrix'),\r\n      uProjectionMatrix: gl.getUniformLocation(this.discProgram!, 'uProjectionMatrix'),\r\n      uCameraPosition: gl.getUniformLocation(this.discProgram!, 'uCameraPosition'),\r\n      uScaleFactor: gl.getUniformLocation(this.discProgram!, 'uScaleFactor'),\r\n      uRotationAxisVelocity: gl.getUniformLocation(this.discProgram!, 'uRotationAxisVelocity'),\r\n      uTex: gl.getUniformLocation(this.discProgram!, 'uTex'),\r\n      uFrames: gl.getUniformLocation(this.discProgram!, 'uFrames'),\r\n      uItemCount: gl.getUniformLocation(this.discProgram!, 'uItemCount'),\r\n      uAtlasSize: gl.getUniformLocation(this.discProgram!, 'uAtlasSize')\r\n    };\r\n\r\n    this.discGeo = new DiscGeometry(56, 1);\r\n    this.discBuffers = this.discGeo.data;\r\n    this.discVAO = makeVertexArray(\r\n      gl,\r\n      [\r\n        [makeBuffer(gl, this.discBuffers.vertices, gl.STATIC_DRAW), this.discLocations.aModelPosition, 3],\r\n        [makeBuffer(gl, this.discBuffers.uvs, gl.STATIC_DRAW), this.discLocations.aModelUvs, 2]\r\n      ],\r\n      this.discBuffers.indices\r\n    );\r\n\r\n    this.icoGeo = new IcosahedronGeometry();\r\n    this.icoGeo.subdivide(1).spherize(this.SPHERE_RADIUS);\r\n    this.instancePositions = this.icoGeo.vertices.map(v => v.position);\r\n    this.DISC_INSTANCE_COUNT = this.icoGeo.vertices.length;\r\n    this.initDiscInstances(this.DISC_INSTANCE_COUNT);\r\n    this.initTexture();\r\n    this.control = new ArcballControl(this.canvas, deltaTime => this.onControlUpdate(deltaTime));\r\n\r\n    this.updateCameraMatrix();\r\n    this.updateProjectionMatrix();\r\n\r\n    this.resize();\r\n\r\n    if (onInit) {\r\n      onInit(this);\r\n    }\r\n  }\r\n\r\n  private initTexture(): void {\r\n    if (!this.gl) return;\r\n    const gl = this.gl;\r\n    this.tex = createAndSetupTexture(gl, gl.LINEAR, gl.LINEAR, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE);\r\n\r\n    const itemCount = Math.max(1, this.items.length);\r\n    this.atlasSize = Math.ceil(Math.sqrt(itemCount));\r\n    const cellSize = 512;\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d')!;\r\n    canvas.width = this.atlasSize * cellSize;\r\n    canvas.height = this.atlasSize * cellSize;\r\n\r\n    Promise.all(\r\n      this.items.map(\r\n        item =>\r\n          new Promise<HTMLImageElement>(resolve => {\r\n            const img = new Image();\r\n            img.crossOrigin = 'anonymous';\r\n            img.onload = () => resolve(img);\r\n            img.src = item.image;\r\n          })\r\n      )\r\n    ).then(images => {\r\n      images.forEach((img, i) => {\r\n        const x = (i % this.atlasSize) * cellSize;\r\n        const y = Math.floor(i / this.atlasSize) * cellSize;\r\n        ctx.drawImage(img, x, y, cellSize, cellSize);\r\n      });\r\n\r\n      gl.bindTexture(gl.TEXTURE_2D, this.tex);\r\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\r\n      gl.generateMipmap(gl.TEXTURE_2D);\r\n    });\r\n  }\r\n\r\n  private initDiscInstances(count: number): void {\r\n    if (!this.gl || !this.discVAO) return;\r\n    const gl = this.gl;\r\n\r\n    const matricesArray = new Float32Array(count * 16);\r\n    const matrices: Float32Array[] = [];\r\n    for (let i = 0; i < count; ++i) {\r\n      const instanceMatrixArray = new Float32Array(matricesArray.buffer, i * 16 * 4, 16);\r\n      mat4.identity(instanceMatrixArray as unknown as mat4);\r\n      matrices.push(instanceMatrixArray);\r\n    }\r\n\r\n    this.discInstances = {\r\n      matricesArray,\r\n      matrices,\r\n      buffer: gl.createBuffer()\r\n    };\r\n\r\n    gl.bindVertexArray(this.discVAO);\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.discInstances.buffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.discInstances.matricesArray.byteLength, gl.DYNAMIC_DRAW);\r\n\r\n    const mat4AttribSlotCount = 4;\r\n    const bytesPerMatrix = 16 * 4;\r\n    for (let j = 0; j < mat4AttribSlotCount; ++j) {\r\n      const loc = this.discLocations.aInstanceMatrix + j;\r\n      gl.enableVertexAttribArray(loc);\r\n      gl.vertexAttribPointer(loc, 4, gl.FLOAT, false, bytesPerMatrix, j * 4 * 4);\r\n      gl.vertexAttribDivisor(loc, 1);\r\n    }\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n    gl.bindVertexArray(null);\r\n  }\r\n\r\n  private animate(deltaTime: number): void {\r\n    if (!this.gl) return;\r\n    this.control.update(deltaTime, this.TARGET_FRAME_DURATION);\r\n\r\n    const positions = this.instancePositions.map(p => vec3.transformQuat(vec3.create(), p, this.control.orientation));\r\n    const scale = 0.25;\r\n    const SCALE_INTENSITY = 0.6;\r\n\r\n    positions.forEach((p, ndx) => {\r\n      const s = (Math.abs(p[2]) / this.SPHERE_RADIUS) * SCALE_INTENSITY + (1 - SCALE_INTENSITY);\r\n      const finalScale = s * scale;\r\n      const matrix = mat4.create();\r\n\r\n      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), vec3.negate(vec3.create(), p)));\r\n      mat4.multiply(matrix, matrix, mat4.targetTo(mat4.create(), [0, 0, 0], p, [0, 1, 0]));\r\n      mat4.multiply(matrix, matrix, mat4.fromScaling(mat4.create(), [finalScale, finalScale, finalScale]));\r\n      mat4.multiply(matrix, matrix, mat4.fromTranslation(mat4.create(), [0, 0, -this.SPHERE_RADIUS]));\r\n\r\n      mat4.copy(this.discInstances.matrices[ndx], matrix);\r\n    });\r\n\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.discInstances.buffer);\r\n    this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.discInstances.matricesArray);\r\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\r\n\r\n    this.smoothRotationVelocity = this.control.rotationVelocity;\r\n  }\r\n\r\n  private render(): void {\r\n    if (!this.gl || !this.discProgram) return;\r\n    const gl = this.gl;\r\n\r\n    gl.useProgram(this.discProgram);\r\n    gl.enable(gl.CULL_FACE);\r\n    gl.enable(gl.DEPTH_TEST);\r\n\r\n    gl.clearColor(0, 0, 0, 0);\r\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n    gl.uniformMatrix4fv(this.discLocations.uWorldMatrix, false, this.worldMatrix);\r\n    gl.uniformMatrix4fv(this.discLocations.uViewMatrix, false, this.camera.matrices.view);\r\n    gl.uniformMatrix4fv(this.discLocations.uProjectionMatrix, false, this.camera.matrices.projection);\r\n    gl.uniform3f(\r\n      this.discLocations.uCameraPosition,\r\n      this.camera.position[0],\r\n      this.camera.position[1],\r\n      this.camera.position[2]\r\n    );\r\n    gl.uniform4f(\r\n      this.discLocations.uRotationAxisVelocity,\r\n      this.control.rotationAxis[0],\r\n      this.control.rotationAxis[1],\r\n      this.control.rotationAxis[2],\r\n      this.smoothRotationVelocity * 1.1\r\n    );\r\n\r\n    gl.uniform1i(this.discLocations.uItemCount, this.items.length);\r\n    gl.uniform1i(this.discLocations.uAtlasSize, this.atlasSize);\r\n\r\n    gl.uniform1f(this.discLocations.uFrames, this._frames);\r\n    gl.uniform1f(this.discLocations.uScaleFactor, this.scaleFactor);\r\n\r\n    gl.uniform1i(this.discLocations.uTex, 0);\r\n    gl.activeTexture(gl.TEXTURE0);\r\n    gl.bindTexture(gl.TEXTURE_2D, this.tex);\r\n\r\n    gl.bindVertexArray(this.discVAO);\r\n    gl.drawElementsInstanced(\r\n      gl.TRIANGLES,\r\n      this.discBuffers.indices.length,\r\n      gl.UNSIGNED_SHORT,\r\n      0,\r\n      this.DISC_INSTANCE_COUNT\r\n    );\r\n    gl.bindVertexArray(null);\r\n  }\r\n\r\n  private updateCameraMatrix(): void {\r\n    mat4.targetTo(this.camera.matrix, this.camera.position, [0, 0, 0], this.camera.up);\r\n    mat4.invert(this.camera.matrices.view, this.camera.matrix);\r\n  }\r\n\r\n  private updateProjectionMatrix(): void {\r\n    if (!this.gl) return;\r\n    const canvasEl = this.gl.canvas as HTMLCanvasElement;\r\n    this.camera.aspect = canvasEl.clientWidth / canvasEl.clientHeight;\r\n    const height = this.SPHERE_RADIUS * 0.35;\r\n    const distance = this.camera.position[2];\r\n    if (this.camera.aspect > 1) {\r\n      this.camera.fov = 2 * Math.atan(height / distance);\r\n    } else {\r\n      this.camera.fov = 2 * Math.atan(height / this.camera.aspect / distance);\r\n    }\r\n    mat4.perspective(\r\n      this.camera.matrices.projection,\r\n      this.camera.fov,\r\n      this.camera.aspect,\r\n      this.camera.near,\r\n      this.camera.far\r\n    );\r\n    mat4.invert(this.camera.matrices.inversProjection, this.camera.matrices.projection);\r\n  }\r\n\r\n  private onControlUpdate(deltaTime: number): void {\r\n    const timeScale = deltaTime / this.TARGET_FRAME_DURATION + 0.0001;\r\n    let damping = 5 / timeScale;\r\n    let cameraTargetZ = 3;\r\n\r\n    const isMoving = this.control.isPointerDown || Math.abs(this.smoothRotationVelocity) > 0.01;\r\n\r\n    if (isMoving !== this.movementActive) {\r\n      this.movementActive = isMoving;\r\n      this.onMovementChange(isMoving);\r\n    }\r\n\r\n    if (!this.control.isPointerDown) {\r\n      const nearestVertexIndex = this.findNearestVertexIndex();\r\n      const itemIndex = nearestVertexIndex % Math.max(1, this.items.length);\r\n      this.onActiveItemChange(itemIndex);\r\n      const snapDirection = vec3.normalize(vec3.create(), this.getVertexWorldPosition(nearestVertexIndex));\r\n      this.control.snapTargetDirection = snapDirection;\r\n    } else {\r\n      cameraTargetZ += this.control.rotationVelocity * 80 + 2.5;\r\n      damping = 7 / timeScale;\r\n    }\r\n\r\n    this.camera.position[2] += (cameraTargetZ - this.camera.position[2]) / damping;\r\n    this.updateCameraMatrix();\r\n  }\r\n\r\n  private findNearestVertexIndex(): number {\r\n    const n = this.control.snapDirection;\r\n    const inversOrientation = quat.conjugate(quat.create(), this.control.orientation);\r\n    const nt = vec3.transformQuat(vec3.create(), n, inversOrientation);\r\n\r\n    let maxD = -1;\r\n    let nearestVertexIndex = 0;\r\n    for (let i = 0; i < this.instancePositions.length; ++i) {\r\n      const d = vec3.dot(nt, this.instancePositions[i]);\r\n      if (d > maxD) {\r\n        maxD = d;\r\n        nearestVertexIndex = i;\r\n      }\r\n    }\r\n    return nearestVertexIndex;\r\n  }\r\n\r\n  private getVertexWorldPosition(index: number): vec3 {\r\n    const nearestVertexPos = this.instancePositions[index];\r\n    return vec3.transformQuat(vec3.create(), nearestVertexPos, this.control.orientation);\r\n  }\r\n}\r\n\r\nconst defaultItems: MenuItem[] = [\r\n  {\r\n    image: 'https://picsum.photos/900/900?grayscale',\r\n    link: 'https://google.com/',\r\n    title: '',\r\n    description: ''\r\n  }\r\n];\r\n\r\ninterface InfiniteMenuProps {\r\n  items?: MenuItem[];\r\n}\r\n\r\nconst InfiniteMenu: FC<InfiniteMenuProps> = ({ items = [] }) => {\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null) as MutableRefObject<HTMLCanvasElement | null>;\r\n  const [activeItem, setActiveItem] = useState<MenuItem | null>(null);\r\n  const [isMoving, setIsMoving] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    let sketch: InfiniteGridMenu | null = null;\r\n\r\n    const handleActiveItem = (index: number) => {\r\n      if (!items.length) return;\r\n      const itemIndex = index % items.length;\r\n      setActiveItem(items[itemIndex]);\r\n    };\r\n\r\n    if (canvas) {\r\n      sketch = new InfiniteGridMenu(canvas, items.length ? items : defaultItems, handleActiveItem, setIsMoving, sk =>\r\n        sk.run()\r\n      );\r\n    }\r\n\r\n    const handleResize = () => {\r\n      if (sketch) {\r\n        sketch.resize();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    handleResize();\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, [items]);\r\n\r\n  const handleButtonClick = () => {\r\n    if (!activeItem?.link) return;\r\n    if (activeItem.link.startsWith('http')) {\r\n      window.open(activeItem.link, '_blank');\r\n    } else {\r\n      console.log('Internal route:', activeItem.link);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"relative w-full h-full\">\r\n      <canvas\r\n        id=\"infinite-grid-menu-canvas\"\r\n        ref={canvasRef}\r\n        className=\"cursor-grab w-full h-full overflow-hidden relative outline-none active:cursor-grabbing\"\r\n      />\r\n\r\n      {activeItem && (\r\n        <>\r\n          <h2\r\n            className={`\r\n          select-none\r\n          absolute\r\n          font-black\r\n          [font-size:4rem]\r\n          left-[1.6em]\r\n          top-1/2\r\n          transform\r\n          translate-x-[20%]\r\n          -translate-y-1/2\r\n          transition-all\r\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\r\n          ${\r\n            isMoving\r\n              ? 'opacity-0 pointer-events-none duration-[100ms]'\r\n              : 'opacity-100 pointer-events-auto duration-[500ms]'\r\n          }\r\n        `}\r\n          >\r\n            {activeItem.title}\r\n          </h2>\r\n\r\n          <p\r\n            className={`\r\n          select-none\r\n          absolute\r\n          max-w-[10ch]\r\n          text-[1.5rem]\r\n          top-1/2\r\n          right-[1%]\r\n          transition-all\r\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\r\n          ${\r\n            isMoving\r\n              ? 'opacity-0 pointer-events-none duration-[100ms] translate-x-[-60%] -translate-y-1/2'\r\n              : 'opacity-100 pointer-events-auto duration-[500ms] translate-x-[-90%] -translate-y-1/2'\r\n          }\r\n        `}\r\n          >\r\n            {activeItem.description}\r\n          </p>\r\n\r\n          <div\r\n            onClick={handleButtonClick}\r\n            className={`\r\n          absolute\r\n          left-1/2\r\n          z-10\r\n          w-[60px]\r\n          h-[60px]\r\n          grid\r\n          place-items-center\r\n          bg-[#00ffff]\r\n          border-[5px]\r\n          border-black\r\n          rounded-full\r\n          cursor-pointer\r\n          transition-all\r\n          ease-[cubic-bezier(0.25,0.1,0.25,1.0)]\r\n          ${\r\n            isMoving\r\n              ? 'bottom-[-80px] opacity-0 pointer-events-none duration-[100ms] scale-0 -translate-x-1/2'\r\n              : 'bottom-[3.8em] opacity-100 pointer-events-auto duration-[500ms] scale-100 -translate-x-1/2'\r\n          }\r\n        `}\r\n          >\r\n            <p className=\"select-none relative text-[#060010] top-[2px] text-[26px]\">&#x2197;</p>\r\n          </div>\r\n        </>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default InfiniteMenu;\r\n",
      "type": "registry:component"
    }
  ]
}