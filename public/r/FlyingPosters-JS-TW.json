{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "FlyingPosters-JS-TW",
  "type": "registry:block",
  "title": "FlyingPosters",
  "description": "3D posters rotate on scroll infinitely.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/Components/FlyingPosters/FlyingPosters.jsx",
      "content": "import { useRef, useEffect } from 'react';\r\nimport { Renderer, Camera, Transform, Plane, Program, Mesh, Texture } from 'ogl';\r\n\r\nconst vertexShader = `\r\nprecision highp float;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv;\r\nattribute vec3 normal;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat3 normalMatrix;\r\n\r\nuniform float uPosition;\r\nuniform float uTime;\r\nuniform float uSpeed;\r\nuniform vec3 distortionAxis;\r\nuniform vec3 rotationAxis;\r\nuniform float uDistortion;\r\n\r\nvarying vec2 vUv;\r\nvarying vec3 vNormal;\r\n\r\nfloat PI = 3.141592653589793238;\r\nmat4 rotationMatrix(vec3 axis, float angle) {\r\n    axis = normalize(axis);\r\n    float s = sin(angle);\r\n    float c = cos(angle);\r\n    float oc = 1.0 - c;\r\n    \r\n    return mat4(\r\n      oc * axis.x * axis.x + c,         oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\r\n      oc * axis.x * axis.y + axis.z * s,oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\r\n      oc * axis.z * axis.x - axis.y * s,oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\r\n      0.0,                              0.0,                                0.0,                                1.0\r\n    );\r\n}\r\n\r\nvec3 rotate(vec3 v, vec3 axis, float angle) {\r\n  mat4 m = rotationMatrix(axis, angle);\r\n  return (m * vec4(v, 1.0)).xyz;\r\n}\r\n\r\nfloat qinticInOut(float t) {\r\n  return t < 0.5\r\n    ? 16.0 * pow(t, 5.0)\r\n    : -0.5 * abs(pow(2.0 * t - 2.0, 5.0)) + 1.0;\r\n}\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  \r\n  float norm = 0.5;\r\n  vec3 newpos = position;\r\n  float offset = (dot(distortionAxis, position) + norm / 2.) / norm;\r\n  float localprogress = clamp(\r\n    (fract(uPosition * 5.0 * 0.01) - 0.01 * uDistortion * offset) / (1. - 0.01 * uDistortion),\r\n    0.,\r\n    2.\r\n  );\r\n  localprogress = qinticInOut(localprogress) * PI;\r\n  newpos = rotate(newpos, rotationAxis, localprogress);\r\n\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newpos, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `\r\nprecision highp float;\r\n\r\nuniform vec2 uImageSize;\r\nuniform vec2 uPlaneSize;\r\nuniform sampler2D tMap;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec2 imageSize = uImageSize;\r\n  vec2 planeSize = uPlaneSize;\r\n\r\n  float imageAspect = imageSize.x / imageSize.y;\r\n  float planeAspect = planeSize.x / planeSize.y;\r\n  vec2 scale = vec2(1.0, 1.0);\r\n\r\n  if (planeAspect > imageAspect) {\r\n      scale.x = imageAspect / planeAspect;\r\n  } else {\r\n      scale.y = planeAspect / imageAspect;\r\n  }\r\n\r\n  vec2 uv = vUv * scale + (1.0 - scale) * 0.5;\r\n\r\n  gl_FragColor = texture2D(tMap, uv);\r\n}\r\n`;\r\n\r\nfunction AutoBind(self, { include, exclude } = {}) {\r\n  const getAllProperties = object => {\r\n    const properties = new Set();\r\n    do {\r\n      for (const key of Reflect.ownKeys(object)) {\r\n        properties.add([object, key]);\r\n      }\r\n    } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);\r\n    return properties;\r\n  };\r\n\r\n  const filter = key => {\r\n    const match = pattern => (typeof pattern === 'string' ? key === pattern : pattern.test(key));\r\n\r\n    if (include) return include.some(match);\r\n    if (exclude) return !exclude.some(match);\r\n    return true;\r\n  };\r\n\r\n  for (const [object, key] of getAllProperties(self.constructor.prototype)) {\r\n    if (key === 'constructor' || !filter(key)) continue;\r\n    const descriptor = Reflect.getOwnPropertyDescriptor(object, key);\r\n    if (descriptor && typeof descriptor.value === 'function') {\r\n      self[key] = self[key].bind(self);\r\n    }\r\n  }\r\n  return self;\r\n}\r\n\r\nfunction lerp(p1, p2, t) {\r\n  return p1 + (p2 - p1) * t;\r\n}\r\n\r\nfunction map(num, min1, max1, min2, max2, round = false) {\r\n  const num1 = (num - min1) / (max1 - min1);\r\n  const num2 = num1 * (max2 - min2) + min2;\r\n  return round ? Math.round(num2) : num2;\r\n}\r\n\r\nclass Media {\r\n  constructor({ gl, geometry, scene, screen, viewport, image, length, index, planeWidth, planeHeight, distortion }) {\r\n    this.extra = 0;\r\n    this.gl = gl;\r\n    this.geometry = geometry;\r\n    this.scene = scene;\r\n    this.screen = screen;\r\n    this.viewport = viewport;\r\n    this.image = image;\r\n    this.length = length;\r\n    this.index = index;\r\n    this.planeWidth = planeWidth;\r\n    this.planeHeight = planeHeight;\r\n    this.distortion = distortion;\r\n\r\n    this.createShader();\r\n    this.createMesh();\r\n    this.onResize();\r\n  }\r\n\r\n  createShader() {\r\n    const texture = new Texture(this.gl, {\r\n      generateMipmaps: false\r\n    });\r\n\r\n    this.program = new Program(this.gl, {\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      fragment: fragmentShader,\r\n      vertex: vertexShader,\r\n      uniforms: {\r\n        tMap: { value: texture },\r\n        uPosition: { value: 0 },\r\n        uPlaneSize: { value: [0, 0] },\r\n        uImageSize: { value: [0, 0] },\r\n        uSpeed: { value: 0 },\r\n        rotationAxis: { value: [0, 1, 0] },\r\n        distortionAxis: { value: [1, 1, 0] },\r\n        uDistortion: { value: this.distortion },\r\n        uViewportSize: { value: [this.viewport.width, this.viewport.height] },\r\n        uTime: { value: 0 }\r\n      },\r\n      cullFace: false\r\n    });\r\n\r\n    const img = new Image();\r\n    img.crossOrigin = 'anonymous';\r\n    img.src = this.image;\r\n    img.onload = () => {\r\n      texture.image = img;\r\n      this.program.uniforms.uImageSize.value = [img.naturalWidth, img.naturalHeight];\r\n    };\r\n  }\r\n\r\n  createMesh() {\r\n    this.plane = new Mesh(this.gl, {\r\n      geometry: this.geometry,\r\n      program: this.program\r\n    });\r\n    this.plane.setParent(this.scene);\r\n  }\r\n\r\n  setScale() {\r\n    this.plane.scale.x = (this.viewport.width * this.planeWidth) / this.screen.width;\r\n    this.plane.scale.y = (this.viewport.height * this.planeHeight) / this.screen.height;\r\n\r\n    this.plane.position.x = 0;\r\n    this.plane.program.uniforms.uPlaneSize.value = [this.plane.scale.x, this.plane.scale.y];\r\n  }\r\n\r\n  onResize({ screen, viewport } = {}) {\r\n    if (screen) this.screen = screen;\r\n    if (viewport) {\r\n      this.viewport = viewport;\r\n      this.plane.program.uniforms.uViewportSize.value = [this.viewport.width, this.viewport.height];\r\n    }\r\n    this.setScale();\r\n\r\n    this.padding = 5;\r\n    this.height = this.plane.scale.y + this.padding;\r\n    this.heightTotal = this.height * this.length;\r\n\r\n    this.y = -this.heightTotal / 2 + (this.index + 0.5) * this.height;\r\n  }\r\n\r\n  update(scroll) {\r\n    this.plane.position.y = this.y - scroll.current - this.extra;\r\n\r\n    const position = map(this.plane.position.y, -this.viewport.height, this.viewport.height, 5, 15);\r\n\r\n    this.program.uniforms.uPosition.value = position;\r\n    this.program.uniforms.uTime.value += 0.04;\r\n    this.program.uniforms.uSpeed.value = scroll.current;\r\n\r\n    const planeHeight = this.plane.scale.y;\r\n    const viewportHeight = this.viewport.height;\r\n\r\n    const topEdge = this.plane.position.y + planeHeight / 2;\r\n    const bottomEdge = this.plane.position.y - planeHeight / 2;\r\n\r\n    if (topEdge < -viewportHeight / 2) {\r\n      this.extra -= this.heightTotal;\r\n    } else if (bottomEdge > viewportHeight / 2) {\r\n      this.extra += this.heightTotal;\r\n    }\r\n  }\r\n}\r\n\r\nclass Canvas {\r\n  constructor({ container, canvas, items, planeWidth, planeHeight, distortion, scrollEase, cameraFov, cameraZ }) {\r\n    this.container = container;\r\n    this.canvas = canvas;\r\n    this.items = items;\r\n    this.planeWidth = planeWidth;\r\n    this.planeHeight = planeHeight;\r\n    this.distortion = distortion;\r\n    this.scroll = {\r\n      ease: scrollEase,\r\n      current: 0,\r\n      target: 0,\r\n      last: 0\r\n    };\r\n    this.cameraFov = cameraFov;\r\n    this.cameraZ = cameraZ;\r\n\r\n    AutoBind(this);\r\n\r\n    this.createRenderer();\r\n    this.createCamera();\r\n    this.createScene();\r\n    this.onResize();\r\n\r\n    this.createGeometry();\r\n    this.createMedias();\r\n    this.update();\r\n    this.addEventListeners();\r\n    this.createPreloader();\r\n  }\r\n\r\n  createRenderer() {\r\n    this.renderer = new Renderer({\r\n      canvas: this.canvas,\r\n      alpha: true,\r\n      antialias: true,\r\n      dpr: Math.min(window.devicePixelRatio, 2)\r\n    });\r\n    this.gl = this.renderer.gl;\r\n  }\r\n\r\n  createCamera() {\r\n    this.camera = new Camera(this.gl);\r\n    this.camera.fov = this.cameraFov;\r\n    this.camera.position.z = this.cameraZ;\r\n  }\r\n\r\n  createScene() {\r\n    this.scene = new Transform();\r\n  }\r\n\r\n  createGeometry() {\r\n    this.planeGeometry = new Plane(this.gl, {\r\n      heightSegments: 1,\r\n      widthSegments: 100\r\n    });\r\n  }\r\n\r\n  createMedias() {\r\n    this.medias = this.items.map((image, index) => {\r\n      return new Media({\r\n        gl: this.gl,\r\n        geometry: this.planeGeometry,\r\n        scene: this.scene,\r\n        screen: this.screen,\r\n        viewport: this.viewport,\r\n        image,\r\n        length: this.items.length,\r\n        index,\r\n        planeWidth: this.planeWidth,\r\n        planeHeight: this.planeHeight,\r\n        distortion: this.distortion\r\n      });\r\n    });\r\n  }\r\n\r\n  createPreloader() {\r\n    this.loaded = 0;\r\n    if (!this.items.length) return;\r\n\r\n    this.items.forEach(src => {\r\n      const image = new Image();\r\n      image.crossOrigin = 'anonymous';\r\n      image.src = src;\r\n      image.onload = () => {\r\n        this.loaded += 1;\r\n        if (this.loaded === this.items.length) {\r\n          document.documentElement.classList.remove('loading');\r\n          document.documentElement.classList.add('loaded');\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  onResize() {\r\n    const rect = this.container.getBoundingClientRect();\r\n    this.screen = {\r\n      width: rect.width,\r\n      height: rect.height\r\n    };\r\n\r\n    this.renderer.setSize(this.screen.width, this.screen.height);\r\n\r\n    this.camera.perspective({\r\n      aspect: this.gl.canvas.width / this.gl.canvas.height\r\n    });\r\n\r\n    const fov = (this.camera.fov * Math.PI) / 180;\r\n    const height = 2 * Math.tan(fov / 2) * this.camera.position.z;\r\n    const width = height * this.camera.aspect;\r\n\r\n    this.viewport = { height, width };\r\n\r\n    if (this.medias) {\r\n      this.medias.forEach(media => media.onResize({ screen: this.screen, viewport: this.viewport }));\r\n    }\r\n  }\r\n\r\n  onTouchDown(e) {\r\n    this.isDown = true;\r\n    this.scroll.position = this.scroll.current;\r\n    this.start = e.touches ? e.touches[0].clientY : e.clientY;\r\n  }\r\n\r\n  onTouchMove(e) {\r\n    if (!this.isDown) return;\r\n    const y = e.touches ? e.touches[0].clientY : e.clientY;\r\n    const distance = (this.start - y) * 0.1;\r\n    this.scroll.target = this.scroll.position + distance;\r\n  }\r\n\r\n  onTouchUp() {\r\n    this.isDown = false;\r\n  }\r\n\r\n  onWheel(e) {\r\n    const speed = e.deltaY;\r\n    this.scroll.target += speed * 0.005;\r\n  }\r\n\r\n  update() {\r\n    this.scroll.current = lerp(this.scroll.current, this.scroll.target, this.scroll.ease);\r\n\r\n    if (this.medias) {\r\n      this.medias.forEach(media => media.update(this.scroll));\r\n    }\r\n    this.renderer.render({ scene: this.scene, camera: this.camera });\r\n    this.scroll.last = this.scroll.current;\r\n    requestAnimationFrame(this.update);\r\n  }\r\n\r\n  addEventListeners() {\r\n    window.addEventListener('resize', this.onResize);\r\n    window.addEventListener('wheel', this.onWheel);\r\n    window.addEventListener('mousewheel', this.onWheel);\r\n\r\n    window.addEventListener('mousedown', this.onTouchDown);\r\n    window.addEventListener('mousemove', this.onTouchMove);\r\n    window.addEventListener('mouseup', this.onTouchUp);\r\n\r\n    window.addEventListener('touchstart', this.onTouchDown);\r\n    window.addEventListener('touchmove', this.onTouchMove);\r\n    window.addEventListener('touchend', this.onTouchUp);\r\n  }\r\n\r\n  destroy() {\r\n    window.removeEventListener('resize', this.onResize);\r\n    window.removeEventListener('wheel', this.onWheel);\r\n    window.removeEventListener('mousewheel', this.onWheel);\r\n\r\n    window.removeEventListener('mousedown', this.onTouchDown);\r\n    window.removeEventListener('mousemove', this.onTouchMove);\r\n    window.removeEventListener('mouseup', this.onTouchUp);\r\n\r\n    window.removeEventListener('touchstart', this.onTouchDown);\r\n    window.removeEventListener('touchmove', this.onTouchMove);\r\n    window.removeEventListener('touchend', this.onTouchUp);\r\n  }\r\n}\r\n\r\nexport default function FlyingPosters({\r\n  items = [],\r\n  planeWidth = 320,\r\n  planeHeight = 320,\r\n  distortion = 3,\r\n  scrollEase = 0.1,\r\n  cameraFov = 45,\r\n  cameraZ = 20,\r\n  className,\r\n  ...props\r\n}) {\r\n  const containerRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n  const instanceRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    instanceRef.current = new Canvas({\r\n      container: containerRef.current,\r\n      canvas: canvasRef.current,\r\n      items,\r\n      planeWidth,\r\n      planeHeight,\r\n      distortion,\r\n      scrollEase,\r\n      cameraFov,\r\n      cameraZ\r\n    });\r\n\r\n    return () => {\r\n      if (instanceRef.current) {\r\n        instanceRef.current.destroy();\r\n        instanceRef.current = null;\r\n      }\r\n    };\r\n  }, [items, planeWidth, planeHeight, distortion, scrollEase, cameraFov, cameraZ]);\r\n\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n\r\n    const canvasEl = canvasRef.current;\r\n\r\n    const handleWheel = e => {\r\n      e.preventDefault();\r\n      if (instanceRef.current) {\r\n        instanceRef.current.onWheel(e);\r\n      }\r\n    };\r\n\r\n    const handleTouchMove = e => {\r\n      e.preventDefault();\r\n    };\r\n\r\n    canvasEl.addEventListener('wheel', handleWheel, { passive: false });\r\n    canvasEl.addEventListener('touchmove', handleTouchMove, { passive: false });\r\n\r\n    return () => {\r\n      canvasEl.removeEventListener('wheel', handleWheel);\r\n      canvasEl.removeEventListener('touchmove', handleTouchMove);\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div ref={containerRef} className={`w-full h-full overflow-hidden relative z-2 ${className}`} {...props}>\r\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}