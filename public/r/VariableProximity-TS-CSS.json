{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "VariableProximity-TS-CSS",
  "type": "registry:block",
  "title": "VariableProximity",
  "description": "Letter styling changes continuously with pointer distance mapping.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/VariableProximity/VariableProximity.tsx",
      "content": "import { forwardRef, useMemo, useRef, useEffect, MutableRefObject, RefObject, HTMLAttributes } from 'react';\r\nimport { motion } from 'motion/react';\r\nimport './VariableProximity.css';\r\n\r\ntype Callback = () => void;\r\n\r\nfunction useAnimationFrame(callback: Callback) {\r\n  useEffect(() => {\r\n    let frameId: number;\r\n    const loop = () => {\r\n      callback();\r\n      frameId = requestAnimationFrame(loop);\r\n    };\r\n    frameId = requestAnimationFrame(loop);\r\n    return () => cancelAnimationFrame(frameId);\r\n  }, [callback]);\r\n}\r\n\r\nfunction useMousePositionRef(containerRef: RefObject<HTMLElement>) {\r\n  const positionRef = useRef({ x: 0, y: 0 });\r\n\r\n  useEffect(() => {\r\n    const updatePosition = (x: number, y: number) => {\r\n      if (containerRef?.current) {\r\n        const rect = containerRef.current.getBoundingClientRect();\r\n        positionRef.current = { x: x - rect.left, y: y - rect.top };\r\n      } else {\r\n        positionRef.current = { x, y };\r\n      }\r\n    };\r\n\r\n    const handleMouseMove = (ev: MouseEvent) => updatePosition(ev.clientX, ev.clientY);\r\n    const handleTouchMove = (ev: TouchEvent) => {\r\n      const touch = ev.touches[0];\r\n      updatePosition(touch.clientX, touch.clientY);\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleMouseMove);\r\n    window.addEventListener('touchmove', handleTouchMove);\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleMouseMove);\r\n      window.removeEventListener('touchmove', handleTouchMove);\r\n    };\r\n  }, [containerRef]);\r\n\r\n  return positionRef;\r\n}\r\n\r\ninterface VariableProximityProps extends HTMLAttributes<HTMLSpanElement> {\r\n  label: string;\r\n  fromFontVariationSettings: string;\r\n  toFontVariationSettings: string;\r\n  containerRef: RefObject<HTMLElement>;\r\n  radius?: number;\r\n  falloff?: 'linear' | 'exponential' | 'gaussian';\r\n  className?: string;\r\n  onClick?: () => void;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\nconst VariableProximity = forwardRef<HTMLSpanElement, VariableProximityProps>((props, ref) => {\r\n  const {\r\n    label,\r\n    fromFontVariationSettings,\r\n    toFontVariationSettings,\r\n    containerRef,\r\n    radius = 50,\r\n    falloff = 'linear',\r\n    className = '',\r\n    onClick,\r\n    style,\r\n    ...restProps\r\n  } = props;\r\n\r\n  const letterRefs = useRef<(HTMLSpanElement | null)[]>([]);\r\n  const interpolatedSettingsRef = useRef<string[]>([]);\r\n  const mousePositionRef = useMousePositionRef(containerRef);\r\n  const lastPositionRef = useRef<{ x: number | null; y: number | null }>({ x: null, y: null });\r\n\r\n  const parsedSettings = useMemo(() => {\r\n    const parseSettings = (settingsStr: string) =>\r\n      new Map(\r\n        settingsStr\r\n          .split(',')\r\n          .map(s => s.trim())\r\n          .map(s => {\r\n            const [name, value] = s.split(' ');\r\n            return [name.replace(/['\"]/g, ''), parseFloat(value)];\r\n          })\r\n      );\r\n\r\n    const fromSettings = parseSettings(fromFontVariationSettings);\r\n    const toSettings = parseSettings(toFontVariationSettings);\r\n\r\n    return Array.from(fromSettings.entries()).map(([axis, fromValue]) => ({\r\n      axis,\r\n      fromValue,\r\n      toValue: toSettings.get(axis) ?? fromValue\r\n    }));\r\n  }, [fromFontVariationSettings, toFontVariationSettings]);\r\n\r\n  const calculateDistance = (x1: number, y1: number, x2: number, y2: number) =>\r\n    Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\r\n\r\n  const calculateFalloff = (distance: number) => {\r\n    const norm = Math.min(Math.max(1 - distance / radius, 0), 1);\r\n    switch (falloff) {\r\n      case 'exponential':\r\n        return norm ** 2;\r\n      case 'gaussian':\r\n        return Math.exp(-((distance / (radius / 2)) ** 2) / 2);\r\n      case 'linear':\r\n      default:\r\n        return norm;\r\n    }\r\n  };\r\n\r\n  useAnimationFrame(() => {\r\n    if (!containerRef?.current) return;\r\n    const { x, y } = mousePositionRef.current;\r\n    if (lastPositionRef.current.x === x && lastPositionRef.current.y === y) {\r\n      return;\r\n    }\r\n    lastPositionRef.current = { x, y };\r\n    const containerRect = containerRef.current.getBoundingClientRect();\r\n\r\n    letterRefs.current.forEach((letterRef, index) => {\r\n      if (!letterRef) return;\r\n\r\n      const rect = letterRef.getBoundingClientRect();\r\n      const letterCenterX = rect.left + rect.width / 2 - containerRect.left;\r\n      const letterCenterY = rect.top + rect.height / 2 - containerRect.top;\r\n\r\n      const distance = calculateDistance(\r\n        mousePositionRef.current.x,\r\n        mousePositionRef.current.y,\r\n        letterCenterX,\r\n        letterCenterY\r\n      );\r\n\r\n      if (distance >= radius) {\r\n        letterRef.style.fontVariationSettings = fromFontVariationSettings;\r\n        return;\r\n      }\r\n\r\n      const falloffValue = calculateFalloff(distance);\r\n      const newSettings = parsedSettings\r\n        .map(({ axis, fromValue, toValue }) => {\r\n          const interpolatedValue = fromValue + (toValue - fromValue) * falloffValue;\r\n          return `'${axis}' ${interpolatedValue}`;\r\n        })\r\n        .join(', ');\r\n\r\n      interpolatedSettingsRef.current[index] = newSettings;\r\n      letterRef.style.fontVariationSettings = newSettings;\r\n    });\r\n  });\r\n\r\n  const words = label.split(' ');\r\n  let letterIndex = 0;\r\n\r\n  return (\r\n    <span\r\n      ref={ref}\r\n      className={`${className} variable-proximity`}\r\n      onClick={onClick}\r\n      style={{ display: 'inline', ...style }}\r\n      {...restProps}\r\n    >\r\n      {words.map((word, wordIndex) => (\r\n        <span key={wordIndex} style={{ display: 'inline-block', whiteSpace: 'nowrap' }}>\r\n          {word.split('').map(letter => {\r\n            const currentLetterIndex = letterIndex++;\r\n            return (\r\n              <motion.span\r\n                key={currentLetterIndex}\r\n                ref={el => {\r\n                  letterRefs.current[currentLetterIndex] = el;\r\n                }}\r\n                style={{\r\n                  display: 'inline-block',\r\n                  fontVariationSettings: interpolatedSettingsRef.current[currentLetterIndex]\r\n                }}\r\n                aria-hidden=\"true\"\r\n              >\r\n                {letter}\r\n              </motion.span>\r\n            );\r\n          })}\r\n          {wordIndex < words.length - 1 && <span style={{ display: 'inline-block' }}>&nbsp;</span>}\r\n        </span>\r\n      ))}\r\n      <span className=\"sr-only\">{label}</span>\r\n    </span>\r\n  );\r\n});\r\n\r\nVariableProximity.displayName = 'VariableProximity';\r\nexport default VariableProximity;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/TextAnimations/VariableProximity/VariableProximity.css",
      "content": "@import url('https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap');\r\n\r\n.variable-proximity {\r\n  font-family: 'Roboto Flex', sans-serif;\r\n}\r\n\r\n.sr-only {\r\n  position: absolute;\r\n  width: 1px;\r\n  height: 1px;\r\n  padding: 0;\r\n  margin: -1px;\r\n  overflow: hidden;\r\n  clip: rect(0, 0, 0, 0);\r\n  white-space: nowrap;\r\n  border: 0;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}