{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "RotatingText-JS-TW",
  "type": "registry:block",
  "title": "RotatingText",
  "description": "Cycles through multiple phrases with 3D rotate / flip transitions.",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/TextAnimations/RotatingText/RotatingText.jsx",
      "content": "'use client';\r\n\r\nimport { forwardRef, useCallback, useEffect, useImperativeHandle, useMemo, useState } from 'react';\r\nimport { motion, AnimatePresence } from 'motion/react';\r\n\r\nfunction cn(...classes) {\r\n  return classes.filter(Boolean).join(' ');\r\n}\r\n\r\nconst RotatingText = forwardRef((props, ref) => {\r\n  const {\r\n    texts,\r\n    transition = { type: 'spring', damping: 25, stiffness: 300 },\r\n    initial = { y: '100%', opacity: 0 },\r\n    animate = { y: 0, opacity: 1 },\r\n    exit = { y: '-120%', opacity: 0 },\r\n    animatePresenceMode = 'wait',\r\n    animatePresenceInitial = false,\r\n    rotationInterval = 2000,\r\n    staggerDuration = 0,\r\n    staggerFrom = 'first',\r\n    loop = true,\r\n    auto = true,\r\n    splitBy = 'characters',\r\n    onNext,\r\n    mainClassName,\r\n    splitLevelClassName,\r\n    elementLevelClassName,\r\n    ...rest\r\n  } = props;\r\n\r\n  const [currentTextIndex, setCurrentTextIndex] = useState(0);\r\n\r\n  const splitIntoCharacters = text => {\r\n    if (typeof Intl !== 'undefined' && Intl.Segmenter) {\r\n      const segmenter = new Intl.Segmenter('en', { granularity: 'grapheme' });\r\n      return Array.from(segmenter.segment(text), segment => segment.segment);\r\n    }\r\n    return Array.from(text);\r\n  };\r\n\r\n  const elements = useMemo(() => {\r\n    const currentText = texts[currentTextIndex];\r\n    if (splitBy === 'characters') {\r\n      const words = currentText.split(' ');\r\n      return words.map((word, i) => ({\r\n        characters: splitIntoCharacters(word),\r\n        needsSpace: i !== words.length - 1\r\n      }));\r\n    }\r\n    if (splitBy === 'words') {\r\n      return currentText.split(' ').map((word, i, arr) => ({\r\n        characters: [word],\r\n        needsSpace: i !== arr.length - 1\r\n      }));\r\n    }\r\n    if (splitBy === 'lines') {\r\n      return currentText.split('\\n').map((line, i, arr) => ({\r\n        characters: [line],\r\n        needsSpace: i !== arr.length - 1\r\n      }));\r\n    }\r\n\r\n    return currentText.split(splitBy).map((part, i, arr) => ({\r\n      characters: [part],\r\n      needsSpace: i !== arr.length - 1\r\n    }));\r\n  }, [texts, currentTextIndex, splitBy]);\r\n\r\n  const getStaggerDelay = useCallback(\r\n    (index, totalChars) => {\r\n      const total = totalChars;\r\n      if (staggerFrom === 'first') return index * staggerDuration;\r\n      if (staggerFrom === 'last') return (total - 1 - index) * staggerDuration;\r\n      if (staggerFrom === 'center') {\r\n        const center = Math.floor(total / 2);\r\n        return Math.abs(center - index) * staggerDuration;\r\n      }\r\n      if (staggerFrom === 'random') {\r\n        const randomIndex = Math.floor(Math.random() * total);\r\n        return Math.abs(randomIndex - index) * staggerDuration;\r\n      }\r\n      return Math.abs(staggerFrom - index) * staggerDuration;\r\n    },\r\n    [staggerFrom, staggerDuration]\r\n  );\r\n\r\n  const handleIndexChange = useCallback(\r\n    newIndex => {\r\n      setCurrentTextIndex(newIndex);\r\n      if (onNext) onNext(newIndex);\r\n    },\r\n    [onNext]\r\n  );\r\n\r\n  const next = useCallback(() => {\r\n    const nextIndex = currentTextIndex === texts.length - 1 ? (loop ? 0 : currentTextIndex) : currentTextIndex + 1;\r\n    if (nextIndex !== currentTextIndex) {\r\n      handleIndexChange(nextIndex);\r\n    }\r\n  }, [currentTextIndex, texts.length, loop, handleIndexChange]);\r\n\r\n  const previous = useCallback(() => {\r\n    const prevIndex = currentTextIndex === 0 ? (loop ? texts.length - 1 : currentTextIndex) : currentTextIndex - 1;\r\n    if (prevIndex !== currentTextIndex) {\r\n      handleIndexChange(prevIndex);\r\n    }\r\n  }, [currentTextIndex, texts.length, loop, handleIndexChange]);\r\n\r\n  const jumpTo = useCallback(\r\n    index => {\r\n      const validIndex = Math.max(0, Math.min(index, texts.length - 1));\r\n      if (validIndex !== currentTextIndex) {\r\n        handleIndexChange(validIndex);\r\n      }\r\n    },\r\n    [texts.length, currentTextIndex, handleIndexChange]\r\n  );\r\n\r\n  const reset = useCallback(() => {\r\n    if (currentTextIndex !== 0) {\r\n      handleIndexChange(0);\r\n    }\r\n  }, [currentTextIndex, handleIndexChange]);\r\n\r\n  useImperativeHandle(\r\n    ref,\r\n    () => ({\r\n      next,\r\n      previous,\r\n      jumpTo,\r\n      reset\r\n    }),\r\n    [next, previous, jumpTo, reset]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!auto) return;\r\n    const intervalId = setInterval(next, rotationInterval);\r\n    return () => clearInterval(intervalId);\r\n  }, [next, rotationInterval, auto]);\r\n\r\n  return (\r\n    <motion.span\r\n      className={cn('flex flex-wrap whitespace-pre-wrap relative', mainClassName)}\r\n      {...rest}\r\n      layout\r\n      transition={transition}\r\n    >\r\n      <span className=\"sr-only\">{texts[currentTextIndex]}</span>\r\n      <AnimatePresence mode={animatePresenceMode} initial={animatePresenceInitial}>\r\n        <motion.span\r\n          key={currentTextIndex}\r\n          className={cn(splitBy === 'lines' ? 'flex flex-col w-full' : 'flex flex-wrap whitespace-pre-wrap relative')}\r\n          layout\r\n          aria-hidden=\"true\"\r\n        >\r\n          {elements.map((wordObj, wordIndex, array) => {\r\n            const previousCharsCount = array.slice(0, wordIndex).reduce((sum, word) => sum + word.characters.length, 0);\r\n            return (\r\n              <span key={wordIndex} className={cn('inline-flex', splitLevelClassName)}>\r\n                {wordObj.characters.map((char, charIndex) => (\r\n                  <motion.span\r\n                    key={charIndex}\r\n                    initial={initial}\r\n                    animate={animate}\r\n                    exit={exit}\r\n                    transition={{\r\n                      ...transition,\r\n                      delay: getStaggerDelay(\r\n                        previousCharsCount + charIndex,\r\n                        array.reduce((sum, word) => sum + word.characters.length, 0)\r\n                      )\r\n                    }}\r\n                    className={cn('inline-block', elementLevelClassName)}\r\n                  >\r\n                    {char}\r\n                  </motion.span>\r\n                ))}\r\n                {wordObj.needsSpace && <span className=\"whitespace-pre\"> </span>}\r\n              </span>\r\n            );\r\n          })}\r\n        </motion.span>\r\n      </AnimatePresence>\r\n    </motion.span>\r\n  );\r\n});\r\n\r\nRotatingText.displayName = 'RotatingText';\r\nexport default RotatingText;\r\n",
      "type": "registry:component"
    }
  ]
}