{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "PrismaticBurst-TS-TW",
  "type": "registry:block",
  "title": "PrismaticBurst",
  "description": "Burst of light rays with controllable color, distortion, amount.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/PrismaticBurst/PrismaticBurst.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\nimport { Renderer, Program, Mesh, Triangle, Texture } from 'ogl';\r\n\r\ntype Offset = { x?: number | string; y?: number | string };\r\ntype AnimationType = 'rotate' | 'rotate3d' | 'hover';\r\n\r\nexport type PrismaticBurstProps = {\r\n  intensity?: number;\r\n  speed?: number;\r\n  animationType?: AnimationType;\r\n  colors?: string[];\r\n  distort?: number;\r\n  paused?: boolean;\r\n  offset?: Offset;\r\n  hoverDampness?: number;\r\n  rayCount?: number;\r\n  mixBlendMode?: React.CSSProperties['mixBlendMode'] | 'none';\r\n};\r\n\r\nconst vertexShader = `#version 300 es\r\nin vec2 position;\r\nin vec2 uv;\r\nout vec2 vUv;\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nout vec4 fragColor;\r\n\r\nuniform vec2  uResolution;\r\nuniform float uTime;\r\n\r\nuniform float uIntensity;\r\nuniform float uSpeed;\r\nuniform int   uAnimType;\r\nuniform vec2  uMouse;\r\nuniform int   uColorCount;\r\nuniform float uDistort;\r\nuniform vec2  uOffset;\r\nuniform sampler2D uGradient;\r\nuniform float uNoiseAmount;\r\nuniform int   uRayCount;\r\n\r\nfloat hash21(vec2 p){\r\n    p = floor(p);\r\n    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\r\n    return fract(f);\r\n}\r\n\r\nmat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\r\n\r\nfloat layeredNoise(vec2 fragPx){\r\n    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\r\n    vec2 q = rot30() * p;\r\n    float n = 0.0;\r\n    n += 0.40 * hash21(q);\r\n    n += 0.25 * hash21(q * 2.0 + 17.0);\r\n    n += 0.20 * hash21(q * 4.0 + 47.0);\r\n    n += 0.10 * hash21(q * 8.0 + 113.0);\r\n    n += 0.05 * hash21(q * 16.0 + 191.0);\r\n    return n;\r\n}\r\n\r\nvec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\r\n    float focal = res.y * max(dist, 1e-3);\r\n    return normalize(vec3(2.0 * (frag - offset) - res, focal));\r\n}\r\n\r\nfloat edgeFade(vec2 frag, vec2 res, vec2 offset){\r\n    vec2 toC = frag - 0.5 * res - offset;\r\n    float r = length(toC) / (0.5 * min(res.x, res.y));\r\n    float x = clamp(r, 0.0, 1.0);\r\n    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\r\n    float s = q * 0.5;\r\n    s = pow(s, 1.5);\r\n    float tail = 1.0 - pow(1.0 - s, 2.0);\r\n    s = mix(s, tail, 0.2);\r\n    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\r\n    return clamp(s + dn, 0.0, 1.0);\r\n}\r\n\r\nmat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\r\nmat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\r\nmat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\r\n\r\nvec3 sampleGradient(float t){\r\n    t = clamp(t, 0.0, 1.0);\r\n    return texture(uGradient, vec2(t, 0.5)).rgb;\r\n}\r\n\r\nvec2 rot2(vec2 v, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return mat2(c, -s, s, c) * v;\r\n}\r\n\r\nfloat bendAngle(vec3 q, float t){\r\n    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\r\n            + 0.7 * sin(q.y * 0.50 - t * 0.5)\r\n            + 0.6 * sin(q.z * 0.60 + t * 0.7);\r\n    return a;\r\n}\r\n\r\nvoid main(){\r\n    vec2 frag = gl_FragCoord.xy;\r\n    float t = uTime * uSpeed;\r\n    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\r\n    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\r\n    float marchT = 0.0;\r\n    vec3 col = vec3(0.0);\r\n    float n = layeredNoise(frag);\r\n    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\r\n    mat2 M2 = mat2(c.x, c.y, c.z, c.w);\r\n    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\r\n\r\n    mat3 rot3dMat = mat3(1.0);\r\n    if(uAnimType == 1){\r\n      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\r\n      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\r\n    }\r\n    mat3 hoverMat = mat3(1.0);\r\n    if(uAnimType == 2){\r\n      vec2 m = uMouse * 2.0 - 1.0;\r\n      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\r\n      hoverMat = rotY(ang.y) * rotX(ang.x);\r\n    }\r\n\r\n    for (int i = 0; i < 44; ++i) {\r\n        vec3 P = marchT * dir;\r\n        P.z -= 2.0;\r\n        float rad = length(P);\r\n        vec3 Pl = P * (10.0 / max(rad, 1e-6));\r\n\r\n        if(uAnimType == 0){\r\n            Pl.xz *= M2;\r\n        } else if(uAnimType == 1){\r\n      Pl = rot3dMat * Pl;\r\n        } else {\r\n      Pl = hoverMat * Pl;\r\n        }\r\n\r\n        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\r\n\r\n        float grow = smoothstep(0.35, 3.0, marchT);\r\n        float a1 = amp * grow * bendAngle(Pl * 0.6, t);\r\n        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\r\n        vec3 Pb = Pl;\r\n        Pb.xz = rot2(Pb.xz, a1);\r\n        Pb.xy = rot2(Pb.xy, a2);\r\n\r\n        float rayPattern = smoothstep(\r\n            0.5, 0.7,\r\n            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\r\n            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\r\n        );\r\n\r\n        if (uRayCount > 0) {\r\n            float ang = atan(Pb.y, Pb.x);\r\n            float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\r\n            comb = pow(comb, 3.0);\r\n            rayPattern *= smoothstep(0.15, 0.95, comb);\r\n        }\r\n\r\n        vec3 spectralDefault = 1.0 + vec3(\r\n            cos(marchT * 3.0 + 0.0),\r\n            cos(marchT * 3.0 + 1.0),\r\n            cos(marchT * 3.0 + 2.0)\r\n        );\r\n\r\n        float saw = fract(marchT * 0.25);\r\n        float tRay = saw * saw * (3.0 - 2.0 * saw);\r\n        vec3 userGradient = 2.0 * sampleGradient(tRay);\r\n        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\r\n        vec3 base = (0.05 / (0.4 + stepLen))\r\n                  * smoothstep(5.0, 0.0, rad)\r\n                  * spectral;\r\n\r\n        col += base * rayPattern;\r\n        marchT += stepLen;\r\n    }\r\n\r\n    col *= edgeFade(frag, uResolution, uOffset);\r\n    col *= uIntensity;\r\n\r\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\r\n}`;\r\n\r\nconst hexToRgb01 = (hex: string): [number, number, number] => {\r\n  let h = hex.trim();\r\n  if (h.startsWith('#')) h = h.slice(1);\r\n  if (h.length === 3) {\r\n    const r = h[0],\r\n      g = h[1],\r\n      b = h[2];\r\n    h = r + r + g + g + b + b;\r\n  }\r\n  const intVal = parseInt(h, 16);\r\n  if (isNaN(intVal) || (h.length !== 6 && h.length !== 8)) return [1, 1, 1];\r\n  const r = ((intVal >> 16) & 255) / 255;\r\n  const g = ((intVal >> 8) & 255) / 255;\r\n  const b = (intVal & 255) / 255;\r\n  return [r, g, b];\r\n};\r\n\r\nconst toPx = (v: number | string | undefined): number => {\r\n  if (v == null) return 0;\r\n  if (typeof v === 'number') return v;\r\n  const s = String(v).trim();\r\n  const num = parseFloat(s.replace('px', ''));\r\n  return isNaN(num) ? 0 : num;\r\n};\r\n\r\nconst PrismaticBurst = ({\r\n  intensity = 2,\r\n  speed = 0.5,\r\n  animationType = 'rotate3d',\r\n  colors,\r\n  distort = 0,\r\n  paused = false,\r\n  offset = { x: 0, y: 0 },\r\n  hoverDampness = 0,\r\n  rayCount,\r\n  mixBlendMode = 'lighten'\r\n}: PrismaticBurstProps) => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const programRef = useRef<Program | null>(null);\r\n  const rendererRef = useRef<Renderer | null>(null);\r\n  const mouseTargetRef = useRef<[number, number]>([0.5, 0.5]);\r\n  const mouseSmoothRef = useRef<[number, number]>([0.5, 0.5]);\r\n  const pausedRef = useRef<boolean>(paused);\r\n  const gradTexRef = useRef<Texture | null>(null);\r\n  const hoverDampRef = useRef<number>(hoverDampness);\r\n  const isVisibleRef = useRef<boolean>(true);\r\n  const meshRef = useRef<Mesh | null>(null);\r\n  const triRef = useRef<Triangle | null>(null);\r\n\r\n  useEffect(() => {\r\n    pausedRef.current = paused;\r\n  }, [paused]);\r\n  useEffect(() => {\r\n    hoverDampRef.current = hoverDampness;\r\n  }, [hoverDampness]);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\r\n    const renderer = new Renderer({ dpr, alpha: false, antialias: false });\r\n    rendererRef.current = renderer;\r\n\r\n    const gl = renderer.gl;\r\n    gl.canvas.style.position = 'absolute';\r\n    gl.canvas.style.inset = '0';\r\n    gl.canvas.style.width = '100%';\r\n    gl.canvas.style.height = '100%';\r\n    gl.canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\r\n    container.appendChild(gl.canvas);\r\n\r\n    const white = new Uint8Array([255, 255, 255, 255]);\r\n    const gradientTex = new Texture(gl, {\r\n      image: white,\r\n      width: 1,\r\n      height: 1,\r\n      generateMipmaps: false,\r\n      flipY: false\r\n    });\r\n\r\n    gradientTex.minFilter = gl.LINEAR;\r\n    gradientTex.magFilter = gl.LINEAR;\r\n    gradientTex.wrapS = gl.CLAMP_TO_EDGE;\r\n    gradientTex.wrapT = gl.CLAMP_TO_EDGE;\r\n    gradTexRef.current = gradientTex;\r\n\r\n    const program = new Program(gl, {\r\n      vertex: vertexShader,\r\n      fragment: fragmentShader,\r\n      uniforms: {\r\n        uResolution: { value: [1, 1] as [number, number] },\r\n        uTime: { value: 0 },\r\n\r\n        uIntensity: { value: 1 },\r\n        uSpeed: { value: 1 },\r\n        uAnimType: { value: 0 },\r\n        uMouse: { value: [0.5, 0.5] as [number, number] },\r\n        uColorCount: { value: 0 },\r\n        uDistort: { value: 0 },\r\n        uOffset: { value: [0, 0] as [number, number] },\r\n        uGradient: { value: gradientTex },\r\n        uNoiseAmount: { value: 0.8 },\r\n        uRayCount: { value: 0 }\r\n      }\r\n    });\r\n\r\n    programRef.current = program;\r\n\r\n    const triangle = new Triangle(gl);\r\n    const mesh = new Mesh(gl, { geometry: triangle, program });\r\n    triRef.current = triangle;\r\n    meshRef.current = mesh;\r\n\r\n    const resize = () => {\r\n      const w = container.clientWidth || 1;\r\n      const h = container.clientHeight || 1;\r\n      renderer.setSize(w, h);\r\n      program.uniforms.uResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight];\r\n    };\r\n\r\n    let ro: ResizeObserver | null = null;\r\n    if ('ResizeObserver' in window) {\r\n      ro = new ResizeObserver(resize);\r\n      ro.observe(container);\r\n    } else {\r\n      (window as Window).addEventListener('resize', resize);\r\n    }\r\n    resize();\r\n\r\n    const onPointer = (e: PointerEvent) => {\r\n      const rect = container.getBoundingClientRect();\r\n      const x = (e.clientX - rect.left) / Math.max(rect.width, 1);\r\n      const y = (e.clientY - rect.top) / Math.max(rect.height, 1);\r\n      mouseTargetRef.current = [Math.min(Math.max(x, 0), 1), Math.min(Math.max(y, 0), 1)];\r\n    };\r\n    container.addEventListener('pointermove', onPointer, { passive: true });\r\n\r\n    let io: IntersectionObserver | null = null;\r\n    if ('IntersectionObserver' in window) {\r\n      io = new IntersectionObserver(\r\n        entries => {\r\n          if (entries[0]) isVisibleRef.current = entries[0].isIntersecting;\r\n        },\r\n        { root: null, threshold: 0.01 }\r\n      );\r\n      io.observe(container);\r\n    }\r\n    const onVis = () => {};\r\n    document.addEventListener('visibilitychange', onVis);\r\n\r\n    let raf = 0;\r\n    let last = performance.now();\r\n    let accumTime = 0;\r\n\r\n    const update = (now: number) => {\r\n      const dt = Math.max(0, now - last) * 0.001;\r\n      last = now;\r\n      const visible = isVisibleRef.current && !document.hidden;\r\n      if (!pausedRef.current) accumTime += dt;\r\n      if (!visible) {\r\n        raf = requestAnimationFrame(update);\r\n        return;\r\n      }\r\n      const tau = 0.02 + Math.max(0, Math.min(1, hoverDampRef.current)) * 0.5;\r\n      const alpha = 1 - Math.exp(-dt / tau);\r\n      const tgt = mouseTargetRef.current;\r\n      const sm = mouseSmoothRef.current;\r\n      sm[0] += (tgt[0] - sm[0]) * alpha;\r\n      sm[1] += (tgt[1] - sm[1]) * alpha;\r\n      program.uniforms.uMouse.value = sm as any;\r\n      program.uniforms.uTime.value = accumTime;\r\n      renderer.render({ scene: meshRef.current! });\r\n      raf = requestAnimationFrame(update);\r\n    };\r\n    raf = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(raf);\r\n      container.removeEventListener('pointermove', onPointer);\r\n      ro?.disconnect();\r\n      if (!ro) window.removeEventListener('resize', resize);\r\n      io?.disconnect();\r\n      document.removeEventListener('visibilitychange', onVis);\r\n      try {\r\n        container.removeChild(gl.canvas);\r\n      } catch (e) {\r\n        void e;\r\n      }\r\n      meshRef.current = null;\r\n      triRef.current = null;\r\n      programRef.current = null;\r\n      try {\r\n        const glCtx = rendererRef.current?.gl;\r\n        if (glCtx && gradTexRef.current?.texture) glCtx.deleteTexture(gradTexRef.current.texture);\r\n      } catch (e) {\r\n        void e;\r\n      }\r\n      rendererRef.current = null;\r\n      gradTexRef.current = null;\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const canvas = rendererRef.current?.gl?.canvas as HTMLCanvasElement | undefined;\r\n    if (canvas) {\r\n      canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\r\n    }\r\n  }, [mixBlendMode]);\r\n\r\n  useEffect(() => {\r\n    const program = programRef.current;\r\n    const renderer = rendererRef.current;\r\n    const gradTex = gradTexRef.current;\r\n    if (!program || !renderer || !gradTex) return;\r\n\r\n    program.uniforms.uIntensity.value = intensity ?? 1;\r\n    program.uniforms.uSpeed.value = speed ?? 1;\r\n\r\n    const animTypeMap: Record<AnimationType, number> = {\r\n      rotate: 0,\r\n      rotate3d: 1,\r\n      hover: 2\r\n    };\r\n    program.uniforms.uAnimType.value = animTypeMap[animationType ?? 'rotate'];\r\n\r\n    program.uniforms.uDistort.value = typeof distort === 'number' ? distort : 0;\r\n\r\n    const ox = toPx(offset?.x);\r\n    const oy = toPx(offset?.y);\r\n    program.uniforms.uOffset.value = [ox, oy];\r\n    program.uniforms.uRayCount.value = Math.max(0, Math.floor(rayCount ?? 0));\r\n\r\n    let count = 0;\r\n    if (Array.isArray(colors) && colors.length > 0) {\r\n      const gl = renderer.gl;\r\n      const capped = colors.slice(0, 64);\r\n      count = capped.length;\r\n      const data = new Uint8Array(count * 4);\r\n      for (let i = 0; i < count; i++) {\r\n        const [r, g, b] = hexToRgb01(capped[i]);\r\n        data[i * 4 + 0] = Math.round(r * 255);\r\n        data[i * 4 + 1] = Math.round(g * 255);\r\n        data[i * 4 + 2] = Math.round(b * 255);\r\n        data[i * 4 + 3] = 255;\r\n      }\r\n      gradTex.image = data;\r\n      gradTex.width = count;\r\n      gradTex.height = 1;\r\n      gradTex.minFilter = gl.LINEAR;\r\n      gradTex.magFilter = gl.LINEAR;\r\n      gradTex.wrapS = gl.CLAMP_TO_EDGE;\r\n      gradTex.wrapT = gl.CLAMP_TO_EDGE;\r\n      gradTex.flipY = false;\r\n      gradTex.generateMipmaps = false;\r\n      gradTex.format = gl.RGBA;\r\n      gradTex.type = gl.UNSIGNED_BYTE;\r\n      gradTex.needsUpdate = true;\r\n    } else {\r\n      count = 0;\r\n    }\r\n    program.uniforms.uColorCount.value = count;\r\n  }, [intensity, speed, animationType, colors, distort, offset, rayCount]);\r\n\r\n  return <div className=\"w-full h-full relative overflow-hidden\" ref={containerRef} />;\r\n};\r\n\r\nexport default PrismaticBurst;\r\n",
      "type": "registry:component"
    }
  ]
}