{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Lanyard-TS-TW",
  "type": "registry:block",
  "title": "Lanyard",
  "description": "Swinging 3D lanyard / badge card with realistic inertial motion.",
  "dependencies": [
    "@react-three/drei",
    "@react-three/fiber",
    "@react-three/rapier",
    "meshline",
    "three"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Components/Lanyard/Lanyard.tsx",
      "content": "/* eslint-disable react/no-unknown-property */\r\n'use client';\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport { Canvas, extend, useFrame } from '@react-three/fiber';\r\nimport { useGLTF, useTexture, Environment, Lightformer } from '@react-three/drei';\r\nimport {\r\n  BallCollider,\r\n  CuboidCollider,\r\n  Physics,\r\n  RigidBody,\r\n  useRopeJoint,\r\n  useSphericalJoint,\r\n  RigidBodyProps\r\n} from '@react-three/rapier';\r\nimport { MeshLineGeometry, MeshLineMaterial } from 'meshline';\r\nimport * as THREE from 'three';\r\n\r\n// replace with your own imports, see the usage snippet for details\r\nimport cardGLB from './card.glb';\r\nimport lanyard from './lanyard.png';\r\n\r\nextend({ MeshLineGeometry, MeshLineMaterial });\r\n\r\ninterface LanyardProps {\r\n  position?: [number, number, number];\r\n  gravity?: [number, number, number];\r\n  fov?: number;\r\n  transparent?: boolean;\r\n}\r\n\r\nexport default function Lanyard({\r\n  position = [0, 0, 30],\r\n  gravity = [0, -40, 0],\r\n  fov = 20,\r\n  transparent = true\r\n}: LanyardProps) {\r\n  return (\r\n    <div className=\"relative z-0 w-full h-screen flex justify-center items-center transform scale-100 origin-center\">\r\n      <Canvas\r\n        camera={{ position, fov }}\r\n        gl={{ alpha: transparent }}\r\n        onCreated={({ gl }) => gl.setClearColor(new THREE.Color(0x000000), transparent ? 0 : 1)}\r\n      >\r\n        <ambientLight intensity={Math.PI} />\r\n        <Physics gravity={gravity} timeStep={1 / 60}>\r\n          <Band />\r\n        </Physics>\r\n        <Environment blur={0.75}>\r\n          <Lightformer\r\n            intensity={2}\r\n            color=\"white\"\r\n            position={[0, -1, 5]}\r\n            rotation={[0, 0, Math.PI / 3]}\r\n            scale={[100, 0.1, 1]}\r\n          />\r\n          <Lightformer\r\n            intensity={3}\r\n            color=\"white\"\r\n            position={[-1, -1, 1]}\r\n            rotation={[0, 0, Math.PI / 3]}\r\n            scale={[100, 0.1, 1]}\r\n          />\r\n          <Lightformer\r\n            intensity={3}\r\n            color=\"white\"\r\n            position={[1, 1, 1]}\r\n            rotation={[0, 0, Math.PI / 3]}\r\n            scale={[100, 0.1, 1]}\r\n          />\r\n          <Lightformer\r\n            intensity={10}\r\n            color=\"white\"\r\n            position={[-10, 0, 14]}\r\n            rotation={[0, Math.PI / 2, Math.PI / 3]}\r\n            scale={[100, 10, 1]}\r\n          />\r\n        </Environment>\r\n      </Canvas>\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface BandProps {\r\n  maxSpeed?: number;\r\n  minSpeed?: number;\r\n}\r\n\r\nfunction Band({ maxSpeed = 50, minSpeed = 0 }: BandProps) {\r\n  // Using \"any\" for refs since the exact types depend on Rapier's internals\r\n  const band = useRef<any>(null);\r\n  const fixed = useRef<any>(null);\r\n  const j1 = useRef<any>(null);\r\n  const j2 = useRef<any>(null);\r\n  const j3 = useRef<any>(null);\r\n  const card = useRef<any>(null);\r\n\r\n  const vec = new THREE.Vector3();\r\n  const ang = new THREE.Vector3();\r\n  const rot = new THREE.Vector3();\r\n  const dir = new THREE.Vector3();\r\n\r\n  const segmentProps: any = {\r\n    type: 'dynamic' as RigidBodyProps['type'],\r\n    canSleep: true,\r\n    colliders: false,\r\n    angularDamping: 4,\r\n    linearDamping: 4\r\n  };\r\n\r\n  const { nodes, materials } = useGLTF(cardGLB) as any;\r\n  const texture = useTexture(lanyard);\r\n  const [curve] = useState(\r\n    () =>\r\n      new THREE.CatmullRomCurve3([new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()])\r\n  );\r\n  const [dragged, drag] = useState<false | THREE.Vector3>(false);\r\n  const [hovered, hover] = useState(false);\r\n\r\n  const [isSmall, setIsSmall] = useState<boolean>(() => {\r\n    if (typeof window !== 'undefined') {\r\n      return window.innerWidth < 1024;\r\n    }\r\n    return false;\r\n  });\r\n\r\n  useEffect(() => {\r\n    const handleResize = (): void => {\r\n      setIsSmall(window.innerWidth < 1024);\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n    return (): void => window.removeEventListener('resize', handleResize);\r\n  }, []);\r\n\r\n  useRopeJoint(fixed, j1, [[0, 0, 0], [0, 0, 0], 1]);\r\n  useRopeJoint(j1, j2, [[0, 0, 0], [0, 0, 0], 1]);\r\n  useRopeJoint(j2, j3, [[0, 0, 0], [0, 0, 0], 1]);\r\n  useSphericalJoint(j3, card, [\r\n    [0, 0, 0],\r\n    [0, 1.45, 0]\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (hovered) {\r\n      document.body.style.cursor = dragged ? 'grabbing' : 'grab';\r\n      return () => {\r\n        document.body.style.cursor = 'auto';\r\n      };\r\n    }\r\n  }, [hovered, dragged]);\r\n\r\n  useFrame((state, delta) => {\r\n    if (dragged && typeof dragged !== 'boolean') {\r\n      vec.set(state.pointer.x, state.pointer.y, 0.5).unproject(state.camera);\r\n      dir.copy(vec).sub(state.camera.position).normalize();\r\n      vec.add(dir.multiplyScalar(state.camera.position.length()));\r\n      [card, j1, j2, j3, fixed].forEach(ref => ref.current?.wakeUp());\r\n      card.current?.setNextKinematicTranslation({\r\n        x: vec.x - dragged.x,\r\n        y: vec.y - dragged.y,\r\n        z: vec.z - dragged.z\r\n      });\r\n    }\r\n    if (fixed.current) {\r\n      [j1, j2].forEach(ref => {\r\n        if (!ref.current.lerped) ref.current.lerped = new THREE.Vector3().copy(ref.current.translation());\r\n        const clampedDistance = Math.max(0.1, Math.min(1, ref.current.lerped.distanceTo(ref.current.translation())));\r\n        ref.current.lerped.lerp(\r\n          ref.current.translation(),\r\n          delta * (minSpeed + clampedDistance * (maxSpeed - minSpeed))\r\n        );\r\n      });\r\n      curve.points[0].copy(j3.current.translation());\r\n      curve.points[1].copy(j2.current.lerped);\r\n      curve.points[2].copy(j1.current.lerped);\r\n      curve.points[3].copy(fixed.current.translation());\r\n      band.current.geometry.setPoints(curve.getPoints(32));\r\n      ang.copy(card.current.angvel());\r\n      rot.copy(card.current.rotation());\r\n      card.current.setAngvel({ x: ang.x, y: ang.y - rot.y * 0.25, z: ang.z });\r\n    }\r\n  });\r\n\r\n  curve.curveType = 'chordal';\r\n  texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n\r\n  return (\r\n    <>\r\n      <group position={[0, 4, 0]}>\r\n        <RigidBody ref={fixed} {...segmentProps} type={'fixed' as RigidBodyProps['type']} />\r\n        <RigidBody position={[0.5, 0, 0]} ref={j1} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\r\n          <BallCollider args={[0.1]} />\r\n        </RigidBody>\r\n        <RigidBody position={[1, 0, 0]} ref={j2} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\r\n          <BallCollider args={[0.1]} />\r\n        </RigidBody>\r\n        <RigidBody position={[1.5, 0, 0]} ref={j3} {...segmentProps} type={'dynamic' as RigidBodyProps['type']}>\r\n          <BallCollider args={[0.1]} />\r\n        </RigidBody>\r\n        <RigidBody\r\n          position={[2, 0, 0]}\r\n          ref={card}\r\n          {...segmentProps}\r\n          type={dragged ? ('kinematicPosition' as RigidBodyProps['type']) : ('dynamic' as RigidBodyProps['type'])}\r\n        >\r\n          <CuboidCollider args={[0.8, 1.125, 0.01]} />\r\n          <group\r\n            scale={2.25}\r\n            position={[0, -1.2, -0.05]}\r\n            onPointerOver={() => hover(true)}\r\n            onPointerOut={() => hover(false)}\r\n            onPointerUp={(e: any) => {\r\n              e.target.releasePointerCapture(e.pointerId);\r\n              drag(false);\r\n            }}\r\n            onPointerDown={(e: any) => {\r\n              e.target.setPointerCapture(e.pointerId);\r\n              drag(new THREE.Vector3().copy(e.point).sub(vec.copy(card.current.translation())));\r\n            }}\r\n          >\r\n            <mesh geometry={nodes.card.geometry}>\r\n              <meshPhysicalMaterial\r\n                map={materials.base.map}\r\n                map-anisotropy={16}\r\n                clearcoat={1}\r\n                clearcoatRoughness={0.15}\r\n                roughness={0.9}\r\n                metalness={0.8}\r\n              />\r\n            </mesh>\r\n            <mesh geometry={nodes.clip.geometry} material={materials.metal} material-roughness={0.3} />\r\n            <mesh geometry={nodes.clamp.geometry} material={materials.metal} />\r\n          </group>\r\n        </RigidBody>\r\n      </group>\r\n      <mesh ref={band}>\r\n        <meshLineGeometry />\r\n        <meshLineMaterial\r\n          color=\"white\"\r\n          depthTest={false}\r\n          resolution={isSmall ? [1000, 2000] : [1000, 1000]}\r\n          useMap\r\n          map={texture}\r\n          repeat={[-4, 1]}\r\n          lineWidth={1}\r\n        />\r\n      </mesh>\r\n    </>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}