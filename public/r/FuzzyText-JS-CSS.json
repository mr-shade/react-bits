{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "FuzzyText-JS-CSS",
  "type": "registry:block",
  "title": "FuzzyText",
  "description": "Vibrating fuzzy text with controllable hover intensity.",
  "files": [
    {
      "path": "public/default/src/content/TextAnimations/FuzzyText/FuzzyText.jsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\n\r\nconst FuzzyText = ({\r\n  children,\r\n  fontSize = 'clamp(2rem, 10vw, 10rem)',\r\n  fontWeight = 900,\r\n  fontFamily = 'inherit',\r\n  color = '#fff',\r\n  enableHover = true,\r\n  baseIntensity = 0.18,\r\n  hoverIntensity = 0.5\r\n}) => {\r\n  const canvasRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    let animationFrameId;\r\n    let isCancelled = false;\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const init = async () => {\r\n      if (document.fonts?.ready) {\r\n        await document.fonts.ready;\r\n      }\r\n      if (isCancelled) return;\r\n\r\n      const ctx = canvas.getContext('2d');\r\n      if (!ctx) return;\r\n\r\n      const computedFontFamily =\r\n        fontFamily === 'inherit' ? window.getComputedStyle(canvas).fontFamily || 'sans-serif' : fontFamily;\r\n\r\n      const fontSizeStr = typeof fontSize === 'number' ? `${fontSize}px` : fontSize;\r\n      let numericFontSize;\r\n      if (typeof fontSize === 'number') {\r\n        numericFontSize = fontSize;\r\n      } else {\r\n        const temp = document.createElement('span');\r\n        temp.style.fontSize = fontSize;\r\n        document.body.appendChild(temp);\r\n        const computedSize = window.getComputedStyle(temp).fontSize;\r\n        numericFontSize = parseFloat(computedSize);\r\n        document.body.removeChild(temp);\r\n      }\r\n\r\n      const text = React.Children.toArray(children).join('');\r\n\r\n      const offscreen = document.createElement('canvas');\r\n      const offCtx = offscreen.getContext('2d');\r\n      if (!offCtx) return;\r\n\r\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\r\n      offCtx.textBaseline = 'alphabetic';\r\n      const metrics = offCtx.measureText(text);\r\n\r\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\r\n      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;\r\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\r\n      const actualDescent = metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\r\n\r\n      const textBoundingWidth = Math.ceil(actualLeft + actualRight);\r\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\r\n\r\n      const extraWidthBuffer = 10;\r\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\r\n\r\n      offscreen.width = offscreenWidth;\r\n      offscreen.height = tightHeight;\r\n\r\n      const xOffset = extraWidthBuffer / 2;\r\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\r\n      offCtx.textBaseline = 'alphabetic';\r\n      offCtx.fillStyle = color;\r\n      offCtx.fillText(text, xOffset - actualLeft, actualAscent);\r\n\r\n      const horizontalMargin = 50;\r\n      const verticalMargin = 0;\r\n      canvas.width = offscreenWidth + horizontalMargin * 2;\r\n      canvas.height = tightHeight + verticalMargin * 2;\r\n      ctx.translate(horizontalMargin, verticalMargin);\r\n\r\n      const interactiveLeft = horizontalMargin + xOffset;\r\n      const interactiveTop = verticalMargin;\r\n      const interactiveRight = interactiveLeft + textBoundingWidth;\r\n      const interactiveBottom = interactiveTop + tightHeight;\r\n\r\n      let isHovering = false;\r\n      const fuzzRange = 30;\r\n\r\n      const run = () => {\r\n        if (isCancelled) return;\r\n        ctx.clearRect(-fuzzRange, -fuzzRange, offscreenWidth + 2 * fuzzRange, tightHeight + 2 * fuzzRange);\r\n        const intensity = isHovering ? hoverIntensity : baseIntensity;\r\n        for (let j = 0; j < tightHeight; j++) {\r\n          const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);\r\n          ctx.drawImage(offscreen, 0, j, offscreenWidth, 1, dx, j, offscreenWidth, 1);\r\n        }\r\n        animationFrameId = window.requestAnimationFrame(run);\r\n      };\r\n\r\n      run();\r\n\r\n      const isInsideTextArea = (x, y) => {\r\n        return x >= interactiveLeft && x <= interactiveRight && y >= interactiveTop && y <= interactiveBottom;\r\n      };\r\n\r\n      const handleMouseMove = e => {\r\n        if (!enableHover) return;\r\n        const rect = canvas.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n        isHovering = isInsideTextArea(x, y);\r\n      };\r\n\r\n      const handleMouseLeave = () => {\r\n        isHovering = false;\r\n      };\r\n\r\n      const handleTouchMove = e => {\r\n        if (!enableHover) return;\r\n        e.preventDefault();\r\n        const rect = canvas.getBoundingClientRect();\r\n        const touch = e.touches[0];\r\n        const x = touch.clientX - rect.left;\r\n        const y = touch.clientY - rect.top;\r\n        isHovering = isInsideTextArea(x, y);\r\n      };\r\n\r\n      const handleTouchEnd = () => {\r\n        isHovering = false;\r\n      };\r\n\r\n      if (enableHover) {\r\n        canvas.addEventListener('mousemove', handleMouseMove);\r\n        canvas.addEventListener('mouseleave', handleMouseLeave);\r\n        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });\r\n        canvas.addEventListener('touchend', handleTouchEnd);\r\n      }\r\n\r\n      const cleanup = () => {\r\n        window.cancelAnimationFrame(animationFrameId);\r\n        if (enableHover) {\r\n          canvas.removeEventListener('mousemove', handleMouseMove);\r\n          canvas.removeEventListener('mouseleave', handleMouseLeave);\r\n          canvas.removeEventListener('touchmove', handleTouchMove);\r\n          canvas.removeEventListener('touchend', handleTouchEnd);\r\n        }\r\n      };\r\n\r\n      canvas.cleanupFuzzyText = cleanup;\r\n    };\r\n\r\n    init();\r\n\r\n    return () => {\r\n      isCancelled = true;\r\n      window.cancelAnimationFrame(animationFrameId);\r\n      if (canvas && canvas.cleanupFuzzyText) {\r\n        canvas.cleanupFuzzyText();\r\n      }\r\n    };\r\n  }, [children, fontSize, fontWeight, fontFamily, color, enableHover, baseIntensity, hoverIntensity]);\r\n\r\n  return <canvas ref={canvasRef} />;\r\n};\r\n\r\nexport default FuzzyText;\r\n",
      "type": "registry:component"
    }
  ]
}