{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "GridDistortion-TS-TW",
  "type": "registry:block",
  "title": "GridDistortion",
  "description": "Warped grid mesh distorts smoothly reacting to cursor.",
  "dependencies": [
    "three"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/GridDistortion/GridDistortion.tsx",
      "content": "import React, { useRef, useEffect } from 'react';\r\nimport * as THREE from 'three';\r\n\r\ninterface GridDistortionProps {\r\n  grid?: number;\r\n  mouse?: number;\r\n  strength?: number;\r\n  relaxation?: number;\r\n  imageSrc: string;\r\n  className?: string;\r\n}\r\n\r\nconst vertexShader = `\r\nuniform float time;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  vPosition = position;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `\r\nuniform sampler2D uDataTexture;\r\nuniform sampler2D uTexture;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv;\r\n  vec4 offset = texture2D(uDataTexture, vUv);\r\n  gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);\r\n}\r\n`;\r\n\r\nconst GridDistortion: React.FC<GridDistortionProps> = ({\r\n  grid = 15,\r\n  mouse = 0.1,\r\n  strength = 0.15,\r\n  relaxation = 0.9,\r\n  imageSrc,\r\n  className = ''\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const sceneRef = useRef<THREE.Scene | null>(null);\r\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\r\n  const cameraRef = useRef<THREE.OrthographicCamera | null>(null);\r\n  const planeRef = useRef<THREE.Mesh | null>(null);\r\n  const imageAspectRef = useRef<number>(1);\r\n  const animationIdRef = useRef<number | null>(null);\r\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n\r\n    const scene = new THREE.Scene();\r\n    sceneRef.current = scene;\r\n\r\n    const renderer = new THREE.WebGLRenderer({\r\n      antialias: true,\r\n      alpha: true,\r\n      powerPreference: 'high-performance'\r\n    });\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n    renderer.setClearColor(0x000000, 0);\r\n    rendererRef.current = renderer;\r\n\r\n    container.innerHTML = '';\r\n    container.appendChild(renderer.domElement);\r\n\r\n    const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);\r\n    camera.position.z = 2;\r\n    cameraRef.current = camera;\r\n\r\n    const uniforms = {\r\n      time: { value: 0 },\r\n      resolution: { value: new THREE.Vector4() },\r\n      uTexture: { value: null as THREE.Texture | null },\r\n      uDataTexture: { value: null as THREE.DataTexture | null }\r\n    };\r\n\r\n    const textureLoader = new THREE.TextureLoader();\r\n    textureLoader.load(imageSrc, texture => {\r\n      texture.minFilter = THREE.LinearFilter;\r\n      texture.magFilter = THREE.LinearFilter;\r\n      texture.wrapS = THREE.ClampToEdgeWrapping;\r\n      texture.wrapT = THREE.ClampToEdgeWrapping;\r\n      imageAspectRef.current = texture.image.width / texture.image.height;\r\n      uniforms.uTexture.value = texture;\r\n      handleResize();\r\n    });\r\n\r\n    const size = grid;\r\n    const data = new Float32Array(4 * size * size);\r\n    for (let i = 0; i < size * size; i++) {\r\n      data[i * 4] = Math.random() * 255 - 125;\r\n      data[i * 4 + 1] = Math.random() * 255 - 125;\r\n    }\r\n\r\n    const dataTexture = new THREE.DataTexture(data, size, size, THREE.RGBAFormat, THREE.FloatType);\r\n    dataTexture.needsUpdate = true;\r\n    uniforms.uDataTexture.value = dataTexture;\r\n\r\n    const material = new THREE.ShaderMaterial({\r\n      side: THREE.DoubleSide,\r\n      uniforms,\r\n      vertexShader,\r\n      fragmentShader,\r\n      transparent: true\r\n    });\r\n\r\n    const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);\r\n    const plane = new THREE.Mesh(geometry, material);\r\n    planeRef.current = plane;\r\n    scene.add(plane);\r\n\r\n    const handleResize = () => {\r\n      if (!container || !renderer || !camera) return;\r\n\r\n      const rect = container.getBoundingClientRect();\r\n      const width = rect.width;\r\n      const height = rect.height;\r\n\r\n      if (width === 0 || height === 0) return;\r\n\r\n      const containerAspect = width / height;\r\n\r\n      renderer.setSize(width, height);\r\n\r\n      if (plane) {\r\n        plane.scale.set(containerAspect, 1, 1);\r\n      }\r\n\r\n      const frustumHeight = 1;\r\n      const frustumWidth = frustumHeight * containerAspect;\r\n      camera.left = -frustumWidth / 2;\r\n      camera.right = frustumWidth / 2;\r\n      camera.top = frustumHeight / 2;\r\n      camera.bottom = -frustumHeight / 2;\r\n      camera.updateProjectionMatrix();\r\n\r\n      uniforms.resolution.value.set(width, height, 1, 1);\r\n    };\r\n\r\n    if (window.ResizeObserver) {\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        handleResize();\r\n      });\r\n      resizeObserver.observe(container);\r\n      resizeObserverRef.current = resizeObserver;\r\n    } else {\r\n      window.addEventListener('resize', handleResize);\r\n    }\r\n\r\n    const mouseState = {\r\n      x: 0,\r\n      y: 0,\r\n      prevX: 0,\r\n      prevY: 0,\r\n      vX: 0,\r\n      vY: 0\r\n    };\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const rect = container.getBoundingClientRect();\r\n      const x = (e.clientX - rect.left) / rect.width;\r\n      const y = 1 - (e.clientY - rect.top) / rect.height;\r\n      mouseState.vX = x - mouseState.prevX;\r\n      mouseState.vY = y - mouseState.prevY;\r\n      Object.assign(mouseState, { x, y, prevX: x, prevY: y });\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      if (dataTexture) {\r\n        dataTexture.needsUpdate = true;\r\n      }\r\n      Object.assign(mouseState, {\r\n        x: 0,\r\n        y: 0,\r\n        prevX: 0,\r\n        prevY: 0,\r\n        vX: 0,\r\n        vY: 0\r\n      });\r\n    };\r\n\r\n    container.addEventListener('mousemove', handleMouseMove);\r\n    container.addEventListener('mouseleave', handleMouseLeave);\r\n\r\n    handleResize();\r\n\r\n    const animate = () => {\r\n      animationIdRef.current = requestAnimationFrame(animate);\r\n\r\n      if (!renderer || !scene || !camera) return;\r\n\r\n      uniforms.time.value += 0.05;\r\n\r\n      if (!(dataTexture.image.data instanceof Float32Array)) {\r\n        console.error('dataTexture.image.data is not a Float32Array');\r\n        return;\r\n      }\r\n      const data: Float32Array = dataTexture.image.data;\r\n      for (let i = 0; i < size * size; i++) {\r\n        data[i * 4] *= relaxation;\r\n        data[i * 4 + 1] *= relaxation;\r\n      }\r\n\r\n      const gridMouseX = size * mouseState.x;\r\n      const gridMouseY = size * mouseState.y;\r\n      const maxDist = size * mouse;\r\n\r\n      for (let i = 0; i < size; i++) {\r\n        for (let j = 0; j < size; j++) {\r\n          const distSq = Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);\r\n          if (distSq < maxDist * maxDist) {\r\n            const index = 4 * (i + size * j);\r\n            const power = Math.min(maxDist / Math.sqrt(distSq), 10);\r\n            data[index] += strength * 100 * mouseState.vX * power;\r\n            data[index + 1] -= strength * 100 * mouseState.vY * power;\r\n          }\r\n        }\r\n      }\r\n\r\n      dataTexture.needsUpdate = true;\r\n      renderer.render(scene, camera);\r\n    };\r\n\r\n    animate();\r\n\r\n    return () => {\r\n      if (animationIdRef.current) {\r\n        cancelAnimationFrame(animationIdRef.current);\r\n      }\r\n\r\n      if (resizeObserverRef.current) {\r\n        resizeObserverRef.current.disconnect();\r\n      } else {\r\n        window.removeEventListener('resize', handleResize);\r\n      }\r\n\r\n      container.removeEventListener('mousemove', handleMouseMove);\r\n      container.removeEventListener('mouseleave', handleMouseLeave);\r\n\r\n      if (renderer) {\r\n        renderer.dispose();\r\n        if (container.contains(renderer.domElement)) {\r\n          container.removeChild(renderer.domElement);\r\n        }\r\n      }\r\n\r\n      if (geometry) geometry.dispose();\r\n      if (material) material.dispose();\r\n      if (dataTexture) dataTexture.dispose();\r\n      if (uniforms.uTexture.value) uniforms.uTexture.value.dispose();\r\n\r\n      sceneRef.current = null;\r\n      rendererRef.current = null;\r\n      cameraRef.current = null;\r\n      planeRef.current = null;\r\n    };\r\n  }, [grid, mouse, strength, relaxation, imageSrc]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`relative overflow-hidden ${className}`}\r\n      style={{\r\n        width: '100%',\r\n        height: '100%',\r\n        minWidth: '0',\r\n        minHeight: '0'\r\n      }}\r\n    />\r\n  );\r\n};\r\n\r\nexport default GridDistortion;\r\n",
      "type": "registry:component"
    }
  ]
}