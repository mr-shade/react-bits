{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Ribbons-JS-CSS",
  "type": "registry:block",
  "title": "Ribbons",
  "description": "Flowing responsive ribbons/cursor trail driven by physics and pointer motion.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/default/src/content/Animations/Ribbons/Ribbons.jsx",
      "content": "import { useEffect, useRef } from 'react';\r\nimport { Renderer, Transform, Vec3, Color, Polyline } from 'ogl';\r\n\r\nimport './Ribbons.css';\r\n\r\nconst Ribbons = ({\r\n  colors = ['#FC8EAC'],\r\n  baseSpring = 0.03,\r\n  baseFriction = 0.9,\r\n  baseThickness = 30,\r\n  offsetFactor = 0.05,\r\n  maxAge = 500,\r\n  pointCount = 50,\r\n  speedMultiplier = 0.6,\r\n  enableFade = false,\r\n  enableShaderEffect = false,\r\n  effectAmplitude = 2,\r\n  backgroundColor = [0, 0, 0, 0]\r\n}) => {\r\n  const containerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const renderer = new Renderer({ dpr: window.devicePixelRatio || 2, alpha: true });\r\n    const gl = renderer.gl;\r\n    if (Array.isArray(backgroundColor) && backgroundColor.length === 4) {\r\n      gl.clearColor(backgroundColor[0], backgroundColor[1], backgroundColor[2], backgroundColor[3]);\r\n    } else {\r\n      gl.clearColor(0, 0, 0, 0);\r\n    }\r\n\r\n    gl.canvas.style.position = 'absolute';\r\n    gl.canvas.style.top = '0';\r\n    gl.canvas.style.left = '0';\r\n    gl.canvas.style.width = '100%';\r\n    gl.canvas.style.height = '100%';\r\n    container.appendChild(gl.canvas);\r\n\r\n    const scene = new Transform();\r\n    const lines = [];\r\n\r\n    const vertex = `\r\n      precision highp float;\r\n      \r\n      attribute vec3 position;\r\n      attribute vec3 next;\r\n      attribute vec3 prev;\r\n      attribute vec2 uv;\r\n      attribute float side;\r\n      \r\n      uniform vec2 uResolution;\r\n      uniform float uDPR;\r\n      uniform float uThickness;\r\n      uniform float uTime;\r\n      uniform float uEnableShaderEffect;\r\n      uniform float uEffectAmplitude;\r\n      \r\n      varying vec2 vUV;\r\n      \r\n      vec4 getPosition() {\r\n          vec4 current = vec4(position, 1.0);\r\n          vec2 aspect = vec2(uResolution.x / uResolution.y, 1.0);\r\n          vec2 nextScreen = next.xy * aspect;\r\n          vec2 prevScreen = prev.xy * aspect;\r\n          vec2 tangent = normalize(nextScreen - prevScreen);\r\n          vec2 normal = vec2(-tangent.y, tangent.x);\r\n          normal /= aspect;\r\n          normal *= mix(1.0, 0.1, pow(abs(uv.y - 0.5) * 2.0, 2.0));\r\n          float dist = length(nextScreen - prevScreen);\r\n          normal *= smoothstep(0.0, 0.02, dist);\r\n          float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\r\n          float pixelWidth = current.w * pixelWidthRatio;\r\n          normal *= pixelWidth * uThickness;\r\n          current.xy -= normal * side;\r\n          if(uEnableShaderEffect > 0.5) {\r\n            current.xy += normal * sin(uTime + current.x * 10.0) * uEffectAmplitude;\r\n          }\r\n          return current;\r\n      }\r\n      \r\n      void main() {\r\n          vUV = uv;\r\n          gl_Position = getPosition();\r\n      }\r\n    `;\r\n\r\n    const fragment = `\r\n      precision highp float;\r\n      uniform vec3 uColor;\r\n      uniform float uOpacity;\r\n      uniform float uEnableFade;\r\n      varying vec2 vUV;\r\n      void main() {\r\n          float fadeFactor = 1.0;\r\n          if(uEnableFade > 0.5) {\r\n              fadeFactor = 1.0 - smoothstep(0.0, 1.0, vUV.y);\r\n          }\r\n          gl_FragColor = vec4(uColor, uOpacity * fadeFactor);\r\n      }\r\n    `;\r\n\r\n    function resize() {\r\n      const width = container.clientWidth;\r\n      const height = container.clientHeight;\r\n      renderer.setSize(width, height);\r\n      lines.forEach(line => line.polyline.resize());\r\n    }\r\n    window.addEventListener('resize', resize);\r\n\r\n    const center = (colors.length - 1) / 2;\r\n    colors.forEach((color, index) => {\r\n      const spring = baseSpring + (Math.random() - 0.5) * 0.05;\r\n      const friction = baseFriction + (Math.random() - 0.5) * 0.05;\r\n      const thickness = baseThickness + (Math.random() - 0.5) * 3;\r\n      const mouseOffset = new Vec3(\r\n        (index - center) * offsetFactor + (Math.random() - 0.5) * 0.01,\r\n        (Math.random() - 0.5) * 0.1,\r\n        0\r\n      );\r\n\r\n      const line = {\r\n        spring,\r\n        friction,\r\n        mouseVelocity: new Vec3(),\r\n        mouseOffset\r\n      };\r\n\r\n      const count = pointCount;\r\n      const points = [];\r\n      for (let i = 0; i < count; i++) {\r\n        points.push(new Vec3());\r\n      }\r\n      line.points = points;\r\n\r\n      line.polyline = new Polyline(gl, {\r\n        points,\r\n        vertex,\r\n        fragment,\r\n        uniforms: {\r\n          uColor: { value: new Color(color) },\r\n          uThickness: { value: thickness },\r\n          uOpacity: { value: 1.0 },\r\n          uTime: { value: 0.0 },\r\n          uEnableShaderEffect: { value: enableShaderEffect ? 1.0 : 0.0 },\r\n          uEffectAmplitude: { value: effectAmplitude },\r\n          uEnableFade: { value: enableFade ? 1.0 : 0.0 }\r\n        }\r\n      });\r\n      line.polyline.mesh.setParent(scene);\r\n      lines.push(line);\r\n    });\r\n\r\n    resize();\r\n\r\n    const mouse = new Vec3();\r\n    function updateMouse(e) {\r\n      let x, y;\r\n      const rect = container.getBoundingClientRect();\r\n      if (e.changedTouches && e.changedTouches.length) {\r\n        x = e.changedTouches[0].clientX - rect.left;\r\n        y = e.changedTouches[0].clientY - rect.top;\r\n      } else {\r\n        x = e.clientX - rect.left;\r\n        y = e.clientY - rect.top;\r\n      }\r\n      const width = container.clientWidth;\r\n      const height = container.clientHeight;\r\n      mouse.set((x / width) * 2 - 1, (y / height) * -2 + 1, 0);\r\n    }\r\n    container.addEventListener('mousemove', updateMouse);\r\n    container.addEventListener('touchstart', updateMouse);\r\n    container.addEventListener('touchmove', updateMouse);\r\n\r\n    const tmp = new Vec3();\r\n    let frameId;\r\n    let lastTime = performance.now();\r\n    function update() {\r\n      frameId = requestAnimationFrame(update);\r\n      const currentTime = performance.now();\r\n      const dt = currentTime - lastTime;\r\n      lastTime = currentTime;\r\n\r\n      lines.forEach(line => {\r\n        tmp.copy(mouse).add(line.mouseOffset).sub(line.points[0]).multiply(line.spring);\r\n        line.mouseVelocity.add(tmp).multiply(line.friction);\r\n        line.points[0].add(line.mouseVelocity);\r\n\r\n        for (let i = 1; i < line.points.length; i++) {\r\n          if (isFinite(maxAge) && maxAge > 0) {\r\n            const segmentDelay = maxAge / (line.points.length - 1);\r\n            const alpha = Math.min(1, (dt * speedMultiplier) / segmentDelay);\r\n            line.points[i].lerp(line.points[i - 1], alpha);\r\n          } else {\r\n            line.points[i].lerp(line.points[i - 1], 0.9);\r\n          }\r\n        }\r\n        if (line.polyline.mesh.program.uniforms.uTime) {\r\n          line.polyline.mesh.program.uniforms.uTime.value = currentTime * 0.001;\r\n        }\r\n        line.polyline.updateGeometry();\r\n      });\r\n\r\n      renderer.render({ scene });\r\n    }\r\n    update();\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resize);\r\n      container.removeEventListener('mousemove', updateMouse);\r\n      container.removeEventListener('touchstart', updateMouse);\r\n      container.removeEventListener('touchmove', updateMouse);\r\n      cancelAnimationFrame(frameId);\r\n      if (gl.canvas && gl.canvas.parentNode === container) {\r\n        container.removeChild(gl.canvas);\r\n      }\r\n    };\r\n  }, [\r\n    colors,\r\n    baseSpring,\r\n    baseFriction,\r\n    baseThickness,\r\n    offsetFactor,\r\n    maxAge,\r\n    pointCount,\r\n    speedMultiplier,\r\n    enableFade,\r\n    enableShaderEffect,\r\n    effectAmplitude,\r\n    backgroundColor\r\n  ]);\r\n\r\n  return <div ref={containerRef} className=\"ribbons-container\" />;\r\n};\r\n\r\nexport default Ribbons;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/default/src/content/Animations/Ribbons/Ribbons.css",
      "content": ".ribbons-container {\r\n  width: 100%;\r\n  height: 100%;\r\n  position: relative;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}