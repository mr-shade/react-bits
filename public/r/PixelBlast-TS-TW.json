{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "PixelBlast-TS-TW",
  "type": "registry:block",
  "title": "PixelBlast",
  "description": "Exploding pixel particle bursts with optional liquid postprocessing.",
  "dependencies": [
    "postprocessing",
    "three"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/PixelBlast/PixelBlast.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\nimport * as THREE from 'three';\r\nimport { EffectComposer, EffectPass, RenderPass, Effect } from 'postprocessing';\r\n\r\ntype PixelBlastVariant = 'square' | 'circle' | 'triangle' | 'diamond';\r\n\r\ntype PixelBlastProps = {\r\n  variant?: PixelBlastVariant;\r\n  pixelSize?: number;\r\n  color?: string;\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n  antialias?: boolean;\r\n  patternScale?: number;\r\n  patternDensity?: number;\r\n  liquid?: boolean;\r\n  liquidStrength?: number;\r\n  liquidRadius?: number;\r\n  pixelSizeJitter?: number;\r\n  enableRipples?: boolean;\r\n  rippleIntensityScale?: number;\r\n  rippleThickness?: number;\r\n  rippleSpeed?: number;\r\n  liquidWobbleSpeed?: number;\r\n  autoPauseOffscreen?: boolean;\r\n  speed?: number;\r\n  transparent?: boolean;\r\n  edgeFade?: number;\r\n  noiseAmount?: number;\r\n};\r\n\r\nconst createTouchTexture = () => {\r\n  const size = 64;\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = size;\r\n  canvas.height = size;\r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) throw new Error('2D context not available');\r\n  ctx.fillStyle = 'black';\r\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  const texture = new THREE.Texture(canvas);\r\n  texture.minFilter = THREE.LinearFilter;\r\n  texture.magFilter = THREE.LinearFilter;\r\n  texture.generateMipmaps = false;\r\n  const trail: {\r\n    x: number;\r\n    y: number;\r\n    vx: number;\r\n    vy: number;\r\n    force: number;\r\n    age: number;\r\n  }[] = [];\r\n  let last: { x: number; y: number } | null = null;\r\n  const maxAge = 64;\r\n  let radius = 0.1 * size;\r\n  const speed = 1 / maxAge;\r\n  const clear = () => {\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n  };\r\n  const drawPoint = (p: { x: number; y: number; vx: number; vy: number; force: number; age: number }) => {\r\n    const pos = { x: p.x * size, y: (1 - p.y) * size };\r\n    let intensity = 1;\r\n    const easeOutSine = (t: number) => Math.sin((t * Math.PI) / 2);\r\n    const easeOutQuad = (t: number) => -t * (t - 2);\r\n    if (p.age < maxAge * 0.3) intensity = easeOutSine(p.age / (maxAge * 0.3));\r\n    else intensity = easeOutQuad(1 - (p.age - maxAge * 0.3) / (maxAge * 0.7)) || 0;\r\n    intensity *= p.force;\r\n    const color = `${((p.vx + 1) / 2) * 255}, ${((p.vy + 1) / 2) * 255}, ${intensity * 255}`;\r\n    const offset = size * 5;\r\n    ctx.shadowOffsetX = offset;\r\n    ctx.shadowOffsetY = offset;\r\n    ctx.shadowBlur = radius;\r\n    ctx.shadowColor = `rgba(${color},${0.22 * intensity})`;\r\n    ctx.beginPath();\r\n    ctx.fillStyle = 'rgba(255,0,0,1)';\r\n    ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n  };\r\n  const addTouch = (norm: { x: number; y: number }) => {\r\n    let force = 0;\r\n    let vx = 0;\r\n    let vy = 0;\r\n    if (last) {\r\n      const dx = norm.x - last.x;\r\n      const dy = norm.y - last.y;\r\n      if (dx === 0 && dy === 0) return;\r\n      const dd = dx * dx + dy * dy;\r\n      const d = Math.sqrt(dd);\r\n      vx = dx / (d || 1);\r\n      vy = dy / (d || 1);\r\n      force = Math.min(dd * 10000, 1);\r\n    }\r\n    last = { x: norm.x, y: norm.y };\r\n    trail.push({ x: norm.x, y: norm.y, age: 0, force, vx, vy });\r\n  };\r\n  const update = () => {\r\n    clear();\r\n    for (let i = trail.length - 1; i >= 0; i--) {\r\n      const point = trail[i];\r\n      const f = point.force * speed * (1 - point.age / maxAge);\r\n      point.x += point.vx * f;\r\n      point.y += point.vy * f;\r\n      point.age++;\r\n      if (point.age > maxAge) trail.splice(i, 1);\r\n    }\r\n    for (let i = 0; i < trail.length; i++) drawPoint(trail[i]);\r\n    texture.needsUpdate = true;\r\n  };\r\n  return {\r\n    canvas,\r\n    texture,\r\n    addTouch,\r\n    update,\r\n    set radiusScale(v: number) {\r\n      radius = 0.1 * size * v;\r\n    },\r\n    get radiusScale() {\r\n      return radius / (0.1 * size);\r\n    },\r\n    size\r\n  };\r\n};\r\n\r\nconst createLiquidEffect = (texture: THREE.Texture, opts?: { strength?: number; freq?: number }) => {\r\n  const fragment = `\r\n    uniform sampler2D uTexture;\r\n    uniform float uStrength;\r\n    uniform float uTime;\r\n    uniform float uFreq;\r\n\r\n    void mainUv(inout vec2 uv) {\r\n      vec4 tex = texture2D(uTexture, uv);\r\n      float vx = tex.r * 2.0 - 1.0;\r\n      float vy = tex.g * 2.0 - 1.0;\r\n      float intensity = tex.b;\r\n\r\n      float wave = 0.5 + 0.5 * sin(uTime * uFreq + intensity * 6.2831853);\r\n\r\n      float amt = uStrength * intensity * wave;\r\n\r\n      uv += vec2(vx, vy) * amt;\r\n    }\r\n    `;\r\n  return new Effect('LiquidEffect', fragment, {\r\n    uniforms: new Map<string, THREE.Uniform>([\r\n      ['uTexture', new THREE.Uniform(texture)],\r\n      ['uStrength', new THREE.Uniform(opts?.strength ?? 0.025)],\r\n      ['uTime', new THREE.Uniform(0)],\r\n      ['uFreq', new THREE.Uniform(opts?.freq ?? 4.5)]\r\n    ])\r\n  });\r\n};\r\n\r\nconst SHAPE_MAP: Record<PixelBlastVariant, number> = {\r\n  square: 0,\r\n  circle: 1,\r\n  triangle: 2,\r\n  diamond: 3\r\n};\r\n\r\nconst VERTEX_SRC = `\r\nvoid main() {\r\n  gl_Position = vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst FRAGMENT_SRC = `\r\nprecision highp float;\r\n\r\nuniform vec3  uColor;\r\nuniform vec2  uResolution;\r\nuniform float uTime;\r\nuniform float uPixelSize;\r\nuniform float uScale;\r\nuniform float uDensity;\r\nuniform float uPixelJitter;\r\nuniform int   uEnableRipples;\r\nuniform float uRippleSpeed;\r\nuniform float uRippleThickness;\r\nuniform float uRippleIntensity;\r\nuniform float uEdgeFade;\r\n\r\nuniform int   uShapeType;\r\nconst int SHAPE_SQUARE   = 0;\r\nconst int SHAPE_CIRCLE   = 1;\r\nconst int SHAPE_TRIANGLE = 2;\r\nconst int SHAPE_DIAMOND  = 3;\r\n\r\nconst int   MAX_CLICKS = 10;\r\n\r\nuniform vec2  uClickPos  [MAX_CLICKS];\r\nuniform float uClickTimes[MAX_CLICKS];\r\n\r\nout vec4 fragColor;\r\n\r\nfloat Bayer2(vec2 a) {\r\n  a = floor(a);\r\n  return fract(a.x / 2. + a.y * a.y * .75);\r\n}\r\n#define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))\r\n#define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))\r\n\r\n#define FBM_OCTAVES     5\r\n#define FBM_LACUNARITY  1.25\r\n#define FBM_GAIN        1.0\r\n\r\nfloat hash11(float n){ return fract(sin(n)*43758.5453); }\r\n\r\nfloat vnoise(vec3 p){\r\n  vec3 ip = floor(p);\r\n  vec3 fp = fract(p);\r\n  float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));\r\n  float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));\r\n  float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));\r\n  vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);\r\n  float x00 = mix(n000, n100, w.x);\r\n  float x10 = mix(n010, n110, w.x);\r\n  float x01 = mix(n001, n101, w.x);\r\n  float x11 = mix(n011, n111, w.x);\r\n  float y0  = mix(x00, x10, w.y);\r\n  float y1  = mix(x01, x11, w.y);\r\n  return mix(y0, y1, w.z) * 2.0 - 1.0;\r\n}\r\n\r\nfloat fbm2(vec2 uv, float t){\r\n  vec3 p = vec3(uv * uScale, t);\r\n  float amp = 1.0;\r\n  float freq = 1.0;\r\n  float sum = 1.0;\r\n  for (int i = 0; i < FBM_OCTAVES; ++i){\r\n    sum  += amp * vnoise(p * freq);\r\n    freq *= FBM_LACUNARITY;\r\n    amp  *= FBM_GAIN;\r\n  }\r\n  return sum * 0.5 + 0.5;\r\n}\r\n\r\nfloat maskCircle(vec2 p, float cov){\r\n  float r = sqrt(cov) * .25;\r\n  float d = length(p - 0.5) - r;\r\n  float aa = 0.5 * fwidth(d);\r\n  return cov * (1.0 - smoothstep(-aa, aa, d * 2.0));\r\n}\r\n\r\nfloat maskTriangle(vec2 p, vec2 id, float cov){\r\n  bool flip = mod(id.x + id.y, 2.0) > 0.5;\r\n  if (flip) p.x = 1.0 - p.x;\r\n  float r = sqrt(cov);\r\n  float d  = p.y - r*(1.0 - p.x);\r\n  float aa = fwidth(d);\r\n  return cov * clamp(0.5 - d/aa, 0.0, 1.0);\r\n}\r\n\r\nfloat maskDiamond(vec2 p, float cov){\r\n  float r = sqrt(cov) * 0.564;\r\n  return step(abs(p.x - 0.49) + abs(p.y - 0.49), r);\r\n}\r\n\r\nvoid main(){\r\n  float pixelSize = uPixelSize;\r\n  vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;\r\n  float aspectRatio = uResolution.x / uResolution.y;\r\n\r\n  vec2 pixelId = floor(fragCoord / pixelSize);\r\n  vec2 pixelUV = fract(fragCoord / pixelSize);\r\n\r\n  float cellPixelSize = 8.0 * pixelSize;\r\n  vec2 cellId = floor(fragCoord / cellPixelSize);\r\n  vec2 cellCoord = cellId * cellPixelSize;\r\n  vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);\r\n\r\n  float base = fbm2(uv, uTime * 0.05);\r\n  base = base * 0.5 - 0.65;\r\n\r\n  float feed = base + (uDensity - 0.5) * 0.3;\r\n\r\n  float speed     = uRippleSpeed;\r\n  float thickness = uRippleThickness;\r\n  const float dampT     = 1.0;\r\n  const float dampR     = 10.0;\r\n\r\n  if (uEnableRipples == 1) {\r\n    for (int i = 0; i < MAX_CLICKS; ++i){\r\n      vec2 pos = uClickPos[i];\r\n      if (pos.x < 0.0) continue;\r\n      float cellPixelSize = 8.0 * pixelSize;\r\n      vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution))) * vec2(aspectRatio, 1.0);\r\n      float t = max(uTime - uClickTimes[i], 0.0);\r\n      float r = distance(uv, cuv);\r\n      float waveR = speed * t;\r\n      float ring  = exp(-pow((r - waveR) / thickness, 2.0));\r\n      float atten = exp(-dampT * t) * exp(-dampR * r);\r\n      feed = max(feed, ring * atten * uRippleIntensity);\r\n    }\r\n  }\r\n\r\n  float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;\r\n  float bw = step(0.5, feed + bayer);\r\n\r\n  float h = fract(sin(dot(floor(fragCoord / uPixelSize), vec2(127.1, 311.7))) * 43758.5453);\r\n  float jitterScale = 1.0 + (h - 0.5) * uPixelJitter;\r\n  float coverage = bw * jitterScale;\r\n  float M;\r\n  if      (uShapeType == SHAPE_CIRCLE)   M = maskCircle (pixelUV, coverage);\r\n  else if (uShapeType == SHAPE_TRIANGLE) M = maskTriangle(pixelUV, pixelId, coverage);\r\n  else if (uShapeType == SHAPE_DIAMOND)  M = maskDiamond(pixelUV, coverage);\r\n  else                                   M = coverage;\r\n\r\n  if (uEdgeFade > 0.0) {\r\n    vec2 norm = gl_FragCoord.xy / uResolution;\r\n    float edge = min(min(norm.x, norm.y), min(1.0 - norm.x, 1.0 - norm.y));\r\n    float fade = smoothstep(0.0, uEdgeFade, edge);\r\n    M *= fade;\r\n  }\r\n\r\n  vec3 color = uColor;\r\n  fragColor = vec4(color, M);\r\n}\r\n`;\r\n\r\nconst MAX_CLICKS = 10;\r\n\r\nconst PixelBlast: React.FC<PixelBlastProps> = ({\r\n  variant = 'square',\r\n  pixelSize = 3,\r\n  color = '#B19EEF',\r\n  className,\r\n  style,\r\n  antialias = true,\r\n  patternScale = 2,\r\n  patternDensity = 1,\r\n  liquid = false,\r\n  liquidStrength = 0.1,\r\n  liquidRadius = 1,\r\n  pixelSizeJitter = 0,\r\n  enableRipples = true,\r\n  rippleIntensityScale = 1,\r\n  rippleThickness = 0.1,\r\n  rippleSpeed = 0.3,\r\n  liquidWobbleSpeed = 4.5,\r\n  autoPauseOffscreen = true,\r\n  speed = 0.5,\r\n  transparent = true,\r\n  edgeFade = 0.5,\r\n  noiseAmount = 0\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement | null>(null);\r\n  const visibilityRef = useRef({ visible: true });\r\n  const speedRef = useRef(speed);\r\n\r\n  const threeRef = useRef<{\r\n    renderer: THREE.WebGLRenderer;\r\n    scene: THREE.Scene;\r\n    camera: THREE.OrthographicCamera;\r\n    material: THREE.ShaderMaterial;\r\n    clock: THREE.Clock;\r\n    clickIx: number;\r\n    uniforms: {\r\n      uResolution: { value: THREE.Vector2 };\r\n      uTime: { value: number };\r\n      uColor: { value: THREE.Color };\r\n      uClickPos: { value: THREE.Vector2[] };\r\n      uClickTimes: { value: Float32Array };\r\n      uShapeType: { value: number };\r\n      uPixelSize: { value: number };\r\n      uScale: { value: number };\r\n      uDensity: { value: number };\r\n      uPixelJitter: { value: number };\r\n      uEnableRipples: { value: number };\r\n      uRippleSpeed: { value: number };\r\n      uRippleThickness: { value: number };\r\n      uRippleIntensity: { value: number };\r\n      uEdgeFade: { value: number };\r\n    };\r\n    resizeObserver?: ResizeObserver;\r\n    raf?: number;\r\n    quad?: THREE.Mesh<THREE.PlaneGeometry, THREE.ShaderMaterial>;\r\n    timeOffset?: number;\r\n    composer?: EffectComposer;\r\n    touch?: ReturnType<typeof createTouchTexture>;\r\n    liquidEffect?: Effect;\r\n  } | null>(null);\r\n  const prevConfigRef = useRef<any>(null);\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    speedRef.current = speed;\r\n    const needsReinitKeys = ['antialias', 'liquid', 'noiseAmount'];\r\n    const cfg = { antialias, liquid, noiseAmount };\r\n    let mustReinit = false;\r\n    if (!threeRef.current) mustReinit = true;\r\n    else if (prevConfigRef.current) {\r\n      for (const k of needsReinitKeys)\r\n        if (prevConfigRef.current[k] !== (cfg as any)[k]) {\r\n          mustReinit = true;\r\n          break;\r\n        }\r\n    }\r\n    if (mustReinit) {\r\n      if (threeRef.current) {\r\n        const t = threeRef.current;\r\n        t.resizeObserver?.disconnect();\r\n        cancelAnimationFrame(t.raf!);\r\n        t.quad?.geometry.dispose();\r\n        t.material.dispose();\r\n        t.composer?.dispose();\r\n        t.renderer.dispose();\r\n        if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\r\n        threeRef.current = null;\r\n      }\r\n      const canvas = document.createElement('canvas');\r\n      const gl = canvas.getContext('webgl2', { antialias, alpha: true });\r\n      if (!gl) return;\r\n      const renderer = new THREE.WebGLRenderer({\r\n        canvas,\r\n        context: gl as WebGL2RenderingContext,\r\n        antialias,\r\n        alpha: true\r\n      });\r\n      renderer.domElement.style.width = '100%';\r\n      renderer.domElement.style.height = '100%';\r\n      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));\r\n      container.appendChild(renderer.domElement);\r\n      const uniforms = {\r\n        uResolution: { value: new THREE.Vector2(0, 0) },\r\n        uTime: { value: 0 },\r\n        uColor: { value: new THREE.Color(color) },\r\n        uClickPos: {\r\n          value: Array.from({ length: MAX_CLICKS }, () => new THREE.Vector2(-1, -1))\r\n        },\r\n        uClickTimes: { value: new Float32Array(MAX_CLICKS) },\r\n        uShapeType: { value: SHAPE_MAP[variant] ?? 0 },\r\n        uPixelSize: { value: pixelSize * renderer.getPixelRatio() },\r\n        uScale: { value: patternScale },\r\n        uDensity: { value: patternDensity },\r\n        uPixelJitter: { value: pixelSizeJitter },\r\n        uEnableRipples: { value: enableRipples ? 1 : 0 },\r\n        uRippleSpeed: { value: rippleSpeed },\r\n        uRippleThickness: { value: rippleThickness },\r\n        uRippleIntensity: { value: rippleIntensityScale },\r\n        uEdgeFade: { value: edgeFade }\r\n      };\r\n      const scene = new THREE.Scene();\r\n      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n      const material = new THREE.ShaderMaterial({\r\n        vertexShader: VERTEX_SRC,\r\n        fragmentShader: FRAGMENT_SRC,\r\n        uniforms,\r\n        transparent: true,\r\n        glslVersion: THREE.GLSL3,\r\n        depthTest: false,\r\n        depthWrite: false\r\n      });\r\n      const quadGeom = new THREE.PlaneGeometry(2, 2);\r\n      const quad = new THREE.Mesh(quadGeom, material);\r\n      scene.add(quad);\r\n      const clock = new THREE.Clock();\r\n      const setSize = () => {\r\n        const w = container.clientWidth || 1;\r\n        const h = container.clientHeight || 1;\r\n        renderer.setSize(w, h, false);\r\n        uniforms.uResolution.value.set(renderer.domElement.width, renderer.domElement.height);\r\n        if (threeRef.current?.composer)\r\n          threeRef.current.composer.setSize(renderer.domElement.width, renderer.domElement.height);\r\n        uniforms.uPixelSize.value = pixelSize * renderer.getPixelRatio();\r\n      };\r\n      setSize();\r\n      const ro = new ResizeObserver(setSize);\r\n      ro.observe(container);\r\n      const randomFloat = () => {\r\n        if (typeof window !== 'undefined' && (window as any).crypto?.getRandomValues) {\r\n          const u32 = new Uint32Array(1);\r\n          window.crypto.getRandomValues(u32);\r\n          return u32[0] / 0xffffffff;\r\n        }\r\n        return Math.random();\r\n      };\r\n      const timeOffset = randomFloat() * 1000;\r\n      let composer: EffectComposer | undefined;\r\n      let touch: ReturnType<typeof createTouchTexture> | undefined;\r\n      let liquidEffect: Effect | undefined;\r\n      if (liquid) {\r\n        touch = createTouchTexture();\r\n        touch.radiusScale = liquidRadius;\r\n        composer = new EffectComposer(renderer);\r\n        const renderPass = new RenderPass(scene, camera);\r\n        liquidEffect = createLiquidEffect(touch.texture, {\r\n          strength: liquidStrength,\r\n          freq: liquidWobbleSpeed\r\n        });\r\n        const effectPass = new EffectPass(camera, liquidEffect);\r\n        effectPass.renderToScreen = true;\r\n        composer.addPass(renderPass);\r\n        composer.addPass(effectPass);\r\n      }\r\n      if (noiseAmount > 0) {\r\n        if (!composer) {\r\n          composer = new EffectComposer(renderer);\r\n          composer.addPass(new RenderPass(scene, camera));\r\n        }\r\n        const noiseEffect = new Effect(\r\n          'NoiseEffect',\r\n          `uniform float uTime; uniform float uAmount; float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);} void mainUv(inout vec2 uv){} void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){ float n=hash(floor(uv*vec2(1920.0,1080.0))+floor(uTime*60.0)); float g=(n-0.5)*uAmount; outputColor=inputColor+vec4(vec3(g),0.0);} `,\r\n          {\r\n            uniforms: new Map<string, THREE.Uniform>([\r\n              ['uTime', new THREE.Uniform(0)],\r\n              ['uAmount', new THREE.Uniform(noiseAmount)]\r\n            ])\r\n          }\r\n        );\r\n        const noisePass = new EffectPass(camera, noiseEffect);\r\n        noisePass.renderToScreen = true;\r\n        if (composer && composer.passes.length > 0) composer.passes.forEach(p => ((p as any).renderToScreen = false));\r\n        composer.addPass(noisePass);\r\n      }\r\n      if (composer) composer.setSize(renderer.domElement.width, renderer.domElement.height);\r\n      const mapToPixels = (e: PointerEvent) => {\r\n        const rect = renderer.domElement.getBoundingClientRect();\r\n        const scaleX = renderer.domElement.width / rect.width;\r\n        const scaleY = renderer.domElement.height / rect.height;\r\n        const fx = (e.clientX - rect.left) * scaleX;\r\n        const fy = (rect.height - (e.clientY - rect.top)) * scaleY;\r\n        return {\r\n          fx,\r\n          fy,\r\n          w: renderer.domElement.width,\r\n          h: renderer.domElement.height\r\n        };\r\n      };\r\n      const onPointerDown = (e: PointerEvent) => {\r\n        const { fx, fy } = mapToPixels(e);\r\n        const ix = threeRef.current?.clickIx ?? 0;\r\n        uniforms.uClickPos.value[ix].set(fx, fy);\r\n        uniforms.uClickTimes.value[ix] = uniforms.uTime.value;\r\n        if (threeRef.current) threeRef.current.clickIx = (ix + 1) % MAX_CLICKS;\r\n      };\r\n      const onPointerMove = (e: PointerEvent) => {\r\n        if (!touch) return;\r\n        const { fx, fy, w, h } = mapToPixels(e);\r\n        touch.addTouch({ x: fx / w, y: fy / h });\r\n      };\r\n      renderer.domElement.addEventListener('pointerdown', onPointerDown, {\r\n        passive: true\r\n      });\r\n      renderer.domElement.addEventListener('pointermove', onPointerMove, {\r\n        passive: true\r\n      });\r\n      let raf = 0;\r\n      const animate = () => {\r\n        if (autoPauseOffscreen && !visibilityRef.current.visible) {\r\n          raf = requestAnimationFrame(animate);\r\n          return;\r\n        }\r\n        uniforms.uTime.value = timeOffset + clock.getElapsedTime() * speedRef.current;\r\n        if (liquidEffect) (liquidEffect as any).uniforms.get('uTime').value = uniforms.uTime.value;\r\n        if (composer) {\r\n          if (touch) touch.update();\r\n          composer.passes.forEach(p => {\r\n            const effs = (p as any).effects;\r\n            if (effs)\r\n              effs.forEach((eff: any) => {\r\n                const u = eff.uniforms?.get('uTime');\r\n                if (u) u.value = uniforms.uTime.value;\r\n              });\r\n          });\r\n          composer.render();\r\n        } else renderer.render(scene, camera);\r\n        raf = requestAnimationFrame(animate);\r\n      };\r\n      raf = requestAnimationFrame(animate);\r\n      threeRef.current = {\r\n        renderer,\r\n        scene,\r\n        camera,\r\n        material,\r\n        clock,\r\n        clickIx: 0,\r\n        uniforms,\r\n        resizeObserver: ro,\r\n        raf,\r\n        quad,\r\n        timeOffset,\r\n        composer,\r\n        touch,\r\n        liquidEffect\r\n      };\r\n    } else {\r\n      const t = threeRef.current!;\r\n      t.uniforms.uShapeType.value = SHAPE_MAP[variant] ?? 0;\r\n      t.uniforms.uPixelSize.value = pixelSize * t.renderer.getPixelRatio();\r\n      t.uniforms.uColor.value.set(color);\r\n      t.uniforms.uScale.value = patternScale;\r\n      t.uniforms.uDensity.value = patternDensity;\r\n      t.uniforms.uPixelJitter.value = pixelSizeJitter;\r\n      t.uniforms.uEnableRipples.value = enableRipples ? 1 : 0;\r\n      t.uniforms.uRippleIntensity.value = rippleIntensityScale;\r\n      t.uniforms.uRippleThickness.value = rippleThickness;\r\n      t.uniforms.uRippleSpeed.value = rippleSpeed;\r\n      t.uniforms.uEdgeFade.value = edgeFade;\r\n      if (transparent) t.renderer.setClearAlpha(0);\r\n      else t.renderer.setClearColor(0x000000, 1);\r\n      if (t.liquidEffect) {\r\n        const uStrength = (t.liquidEffect as any).uniforms.get('uStrength');\r\n        if (uStrength) uStrength.value = liquidStrength;\r\n        const uFreq = (t.liquidEffect as any).uniforms.get('uFreq');\r\n        if (uFreq) uFreq.value = liquidWobbleSpeed;\r\n      }\r\n      if (t.touch) t.touch.radiusScale = liquidRadius;\r\n    }\r\n    prevConfigRef.current = cfg;\r\n    return () => {\r\n      if (threeRef.current && mustReinit) return;\r\n      if (!threeRef.current) return;\r\n      const t = threeRef.current;\r\n      t.resizeObserver?.disconnect();\r\n      cancelAnimationFrame(t.raf!);\r\n      t.quad?.geometry.dispose();\r\n      t.material.dispose();\r\n      t.composer?.dispose();\r\n      t.renderer.dispose();\r\n      if (t.renderer.domElement.parentElement === container) container.removeChild(t.renderer.domElement);\r\n      threeRef.current = null;\r\n    };\r\n  }, [\r\n    antialias,\r\n    liquid,\r\n    noiseAmount,\r\n    pixelSize,\r\n    patternScale,\r\n    patternDensity,\r\n    enableRipples,\r\n    rippleIntensityScale,\r\n    rippleThickness,\r\n    rippleSpeed,\r\n    pixelSizeJitter,\r\n    edgeFade,\r\n    transparent,\r\n    liquidStrength,\r\n    liquidRadius,\r\n    liquidWobbleSpeed,\r\n    autoPauseOffscreen,\r\n    variant,\r\n    color,\r\n    speed\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`w-full h-full relative overflow-hidden ${className ?? ''}`}\r\n      style={style}\r\n      aria-label=\"PixelBlast interactive background\"\r\n    />\r\n  );\r\n};\r\n\r\nexport default PixelBlast;\r\n",
      "type": "registry:component"
    }
  ]
}