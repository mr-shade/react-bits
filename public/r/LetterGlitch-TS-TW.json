{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "LetterGlitch-TS-TW",
  "type": "registry:block",
  "title": "LetterGlitch",
  "description": "Matrix style letter animation.",
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/LetterGlitch/LetterGlitch.tsx",
      "content": "import { useRef, useEffect } from 'react';\r\n\r\nconst LetterGlitch = ({\r\n  glitchColors = ['#2b4539', '#61dca3', '#61b3dc'],\r\n  glitchSpeed = 50,\r\n  centerVignette = false,\r\n  outerVignette = true,\r\n  smooth = true,\r\n  characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$&*()-_+=/[]{};:<>.,0123456789\"\r\n}: {\r\n  glitchColors: string[];\r\n  glitchSpeed: number;\r\n  centerVignette: boolean;\r\n  outerVignette: boolean;\r\n  smooth: boolean;\r\n  characters: string;\r\n}) => {\r\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\r\n  const animationRef = useRef<number | null>(null);\r\n  const letters = useRef<\r\n    {\r\n      char: string;\r\n      color: string;\r\n      targetColor: string;\r\n      colorProgress: number;\r\n    }[]\r\n  >([]);\r\n  const grid = useRef({ columns: 0, rows: 0 });\r\n  const context = useRef<CanvasRenderingContext2D | null>(null);\r\n  const lastGlitchTime = useRef(Date.now());\r\n\r\n  const lettersAndSymbols = Array.from(characters);\r\n\r\n  const fontSize = 16;\r\n  const charWidth = 10;\r\n  const charHeight = 20;\r\n\r\n\r\n  const getRandomChar = () => {\r\n    return lettersAndSymbols[Math.floor(Math.random() * lettersAndSymbols.length)];\r\n  };\r\n\r\n  const getRandomColor = () => {\r\n    return glitchColors[Math.floor(Math.random() * glitchColors.length)];\r\n  };\r\n\r\n  const hexToRgb = (hex: string) => {\r\n    const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n    hex = hex.replace(shorthandRegex, (_m, r, g, b) => {\r\n      return r + r + g + g + b + b;\r\n    });\r\n\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result\r\n      ? {\r\n          r: parseInt(result[1], 16),\r\n          g: parseInt(result[2], 16),\r\n          b: parseInt(result[3], 16)\r\n        }\r\n      : null;\r\n  };\r\n\r\n  const interpolateColor = (\r\n    start: { r: number; g: number; b: number },\r\n    end: { r: number; g: number; b: number },\r\n    factor: number\r\n  ) => {\r\n    const result = {\r\n      r: Math.round(start.r + (end.r - start.r) * factor),\r\n      g: Math.round(start.g + (end.g - start.g) * factor),\r\n      b: Math.round(start.b + (end.b - start.b) * factor)\r\n    };\r\n    return `rgb(${result.r}, ${result.g}, ${result.b})`;\r\n  };\r\n\r\n  const calculateGrid = (width: number, height: number) => {\r\n    const columns = Math.ceil(width / charWidth);\r\n    const rows = Math.ceil(height / charHeight);\r\n    return { columns, rows };\r\n  };\r\n\r\n  const initializeLetters = (columns: number, rows: number) => {\r\n    grid.current = { columns, rows };\r\n    const totalLetters = columns * rows;\r\n    letters.current = Array.from({ length: totalLetters }, () => ({\r\n      char: getRandomChar(),\r\n      color: getRandomColor(),\r\n      targetColor: getRandomColor(),\r\n      colorProgress: 1\r\n    }));\r\n  };\r\n\r\n  const resizeCanvas = () => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    const parent = canvas.parentElement;\r\n    if (!parent) return;\r\n\r\n    const dpr = window.devicePixelRatio || 1;\r\n    const rect = parent.getBoundingClientRect();\r\n\r\n    canvas.width = rect.width * dpr;\r\n    canvas.height = rect.height * dpr;\r\n\r\n    canvas.style.width = `${rect.width}px`;\r\n    canvas.style.height = `${rect.height}px`;\r\n\r\n    if (context.current) {\r\n      context.current.setTransform(dpr, 0, 0, dpr, 0, 0);\r\n    }\r\n\r\n    const { columns, rows } = calculateGrid(rect.width, rect.height);\r\n    initializeLetters(columns, rows);\r\n    drawLetters();\r\n  };\r\n\r\n  const drawLetters = () => {\r\n    if (!context.current || letters.current.length === 0) return;\r\n    const ctx = context.current;\r\n    const { width, height } = canvasRef.current!.getBoundingClientRect();\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.font = `${fontSize}px monospace`;\r\n    ctx.textBaseline = 'top';\r\n\r\n    letters.current.forEach((letter, index) => {\r\n      const x = (index % grid.current.columns) * charWidth;\r\n      const y = Math.floor(index / grid.current.columns) * charHeight;\r\n      ctx.fillStyle = letter.color;\r\n      ctx.fillText(letter.char, x, y);\r\n    });\r\n  };\r\n\r\n  const updateLetters = () => {\r\n    if (!letters.current || letters.current.length === 0) return;\r\n\r\n    const updateCount = Math.max(1, Math.floor(letters.current.length * 0.05));\r\n\r\n    for (let i = 0; i < updateCount; i++) {\r\n      const index = Math.floor(Math.random() * letters.current.length);\r\n      if (!letters.current[index]) continue;\r\n\r\n      letters.current[index].char = getRandomChar();\r\n      letters.current[index].targetColor = getRandomColor();\r\n\r\n      if (!smooth) {\r\n        letters.current[index].color = letters.current[index].targetColor;\r\n        letters.current[index].colorProgress = 1;\r\n      } else {\r\n        letters.current[index].colorProgress = 0;\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleSmoothTransitions = () => {\r\n    let needsRedraw = false;\r\n    letters.current.forEach(letter => {\r\n      if (letter.colorProgress < 1) {\r\n        letter.colorProgress += 0.05;\r\n        if (letter.colorProgress > 1) letter.colorProgress = 1;\r\n\r\n        const startRgb = hexToRgb(letter.color);\r\n        const endRgb = hexToRgb(letter.targetColor);\r\n        if (startRgb && endRgb) {\r\n          letter.color = interpolateColor(startRgb, endRgb, letter.colorProgress);\r\n          needsRedraw = true;\r\n        }\r\n      }\r\n    });\r\n\r\n    if (needsRedraw) {\r\n      drawLetters();\r\n    }\r\n  };\r\n\r\n  const animate = () => {\r\n    const now = Date.now();\r\n    if (now - lastGlitchTime.current >= glitchSpeed) {\r\n      updateLetters();\r\n      drawLetters();\r\n      lastGlitchTime.current = now;\r\n    }\r\n\r\n    if (smooth) {\r\n      handleSmoothTransitions();\r\n    }\r\n\r\n    animationRef.current = requestAnimationFrame(animate);\r\n  };\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    context.current = canvas.getContext('2d');\r\n    resizeCanvas();\r\n    animate();\r\n\r\n    let resizeTimeout: NodeJS.Timeout;\r\n\r\n    const handleResize = () => {\r\n      clearTimeout(resizeTimeout);\r\n      resizeTimeout = setTimeout(() => {\r\n        cancelAnimationFrame(animationRef.current as number);\r\n        resizeCanvas();\r\n        animate();\r\n      }, 100);\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationRef.current!);\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [glitchSpeed, smooth]);\r\n\r\n  return (\r\n    <div className=\"relative w-full h-full bg-black overflow-hidden\">\r\n      <canvas ref={canvasRef} className=\"block w-full h-full\" />\r\n      {outerVignette && (\r\n        <div className=\"absolute top-0 left-0 w-full h-full pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0)_60%,_rgba(0,0,0,1)_100%)]\"></div>\r\n      )}\r\n      {centerVignette && (\r\n        <div className=\"absolute top-0 left-0 w-full h-full pointer-events-none bg-[radial-gradient(circle,_rgba(0,0,0,0.8)_0%,_rgba(0,0,0,0)_60%)]\"></div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default LetterGlitch;\r\n",
      "type": "registry:component"
    }
  ]
}