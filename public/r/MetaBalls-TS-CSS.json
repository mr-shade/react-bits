{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "MetaBalls-TS-CSS",
  "type": "registry:block",
  "title": "MetaBalls",
  "description": "Liquid metaball blobs that merge and separate with smooth implicit surface animation.",
  "dependencies": [
    "ogl"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/Animations/MetaBalls/MetaBalls.tsx",
      "content": "import React, { useEffect, useRef } from 'react';\r\nimport { Renderer, Program, Mesh, Triangle, Transform, Vec3, Camera } from 'ogl';\r\nimport './MetaBalls.css';\r\n\r\ntype MetaBallsProps = {\r\n  color?: string;\r\n  speed?: number;\r\n  enableMouseInteraction?: boolean;\r\n  hoverSmoothness?: number;\r\n  animationSize?: number;\r\n  ballCount?: number;\r\n  clumpFactor?: number;\r\n  cursorBallSize?: number;\r\n  cursorBallColor?: string;\r\n  enableTransparency?: boolean;\r\n};\r\n\r\nfunction parseHexColor(hex: string): [number, number, number] {\r\n  const c = hex.replace('#', '');\r\n  const r = parseInt(c.substring(0, 2), 16) / 255;\r\n  const g = parseInt(c.substring(2, 4), 16) / 255;\r\n  const b = parseInt(c.substring(4, 6), 16) / 255;\r\n  return [r, g, b];\r\n}\r\n\r\nfunction fract(x: number): number {\r\n  return x - Math.floor(x);\r\n}\r\n\r\nfunction hash31(p: number): number[] {\r\n  let r = [p * 0.1031, p * 0.103, p * 0.0973].map(fract);\r\n  const r_yzx = [r[1], r[2], r[0]];\r\n  const dotVal = r[0] * (r_yzx[0] + 33.33) + r[1] * (r_yzx[1] + 33.33) + r[2] * (r_yzx[2] + 33.33);\r\n  for (let i = 0; i < 3; i++) {\r\n    r[i] = fract(r[i] + dotVal);\r\n  }\r\n  return r;\r\n}\r\n\r\nfunction hash33(v: number[]): number[] {\r\n  let p = [v[0] * 0.1031, v[1] * 0.103, v[2] * 0.0973].map(fract);\r\n  const p_yxz = [p[1], p[0], p[2]];\r\n  const dotVal = p[0] * (p_yxz[0] + 33.33) + p[1] * (p_yxz[1] + 33.33) + p[2] * (p_yxz[2] + 33.33);\r\n  for (let i = 0; i < 3; i++) {\r\n    p[i] = fract(p[i] + dotVal);\r\n  }\r\n  const p_xxy = [p[0], p[0], p[1]];\r\n  const p_yxx = [p[1], p[0], p[0]];\r\n  const p_zyx = [p[2], p[1], p[0]];\r\n  const result: number[] = [];\r\n  for (let i = 0; i < 3; i++) {\r\n    result[i] = fract((p_xxy[i] + p_yxx[i]) * p_zyx[i]);\r\n  }\r\n  return result;\r\n}\r\n\r\nconst vertex = `#version 300 es\r\nprecision highp float;\r\nlayout(location = 0) in vec2 position;\r\nvoid main() {\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nconst fragment = `#version 300 es\r\nprecision highp float;\r\nuniform vec3 iResolution;\r\nuniform float iTime;\r\nuniform vec3 iMouse;\r\nuniform vec3 iColor;\r\nuniform vec3 iCursorColor;\r\nuniform float iAnimationSize;\r\nuniform int iBallCount;\r\nuniform float iCursorBallSize;\r\nuniform vec3 iMetaBalls[50];\r\nuniform float iClumpFactor;\r\nuniform bool enableTransparency;\r\nout vec4 outColor;\r\nconst float PI = 3.14159265359;\r\n \r\nfloat getMetaBallValue(vec2 c, float r, vec2 p) {\r\n    vec2 d = p - c;\r\n    float dist2 = dot(d, d);\r\n    return (r * r) / dist2;\r\n}\r\n \r\nvoid main() {\r\n    vec2 fc = gl_FragCoord.xy;\r\n    float scale = iAnimationSize / iResolution.y;\r\n    vec2 coord = (fc - iResolution.xy * 0.5) * scale;\r\n    vec2 mouseW = (iMouse.xy - iResolution.xy * 0.5) * scale;\r\n    float m1 = 0.0;\r\n    for (int i = 0; i < 50; i++) {\r\n        if (i >= iBallCount) break;\r\n        m1 += getMetaBallValue(iMetaBalls[i].xy, iMetaBalls[i].z, coord);\r\n    }\r\n    float m2 = getMetaBallValue(mouseW, iCursorBallSize, coord);\r\n    float total = m1 + m2;\r\n    float f = smoothstep(-1.0, 1.0, (total - 1.3) / min(1.0, fwidth(total)));\r\n    vec3 cFinal = vec3(0.0);\r\n    if (total > 0.0) {\r\n        float alpha1 = m1 / total;\r\n        float alpha2 = m2 / total;\r\n        cFinal = iColor * alpha1 + iCursorColor * alpha2;\r\n    }\r\n    outColor = vec4(cFinal * f, enableTransparency ? f : 1.0);\r\n}\r\n`;\r\n\r\ntype BallParams = {\r\n  st: number;\r\n  dtFactor: number;\r\n  baseScale: number;\r\n  toggle: number;\r\n  radius: number;\r\n};\r\n\r\nconst MetaBalls: React.FC<MetaBallsProps> = ({\r\n  color = '#ffffff',\r\n  speed = 0.3,\r\n  enableMouseInteraction = true,\r\n  hoverSmoothness = 0.05,\r\n  animationSize = 30,\r\n  ballCount = 15,\r\n  clumpFactor = 1,\r\n  cursorBallSize = 3,\r\n  cursorBallColor = '#ffffff',\r\n  enableTransparency = false\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const dpr = 1;\r\n    const renderer = new Renderer({\r\n      dpr,\r\n      alpha: true,\r\n      premultipliedAlpha: false\r\n    });\r\n    const gl = renderer.gl;\r\n    gl.clearColor(0, 0, 0, enableTransparency ? 0 : 1);\r\n    container.appendChild(gl.canvas);\r\n\r\n    const camera = new Camera(gl, {\r\n      left: -1,\r\n      right: 1,\r\n      top: 1,\r\n      bottom: -1,\r\n      near: 0.1,\r\n      far: 10\r\n    });\r\n    camera.position.z = 1;\r\n\r\n    const geometry = new Triangle(gl);\r\n    const [r1, g1, b1] = parseHexColor(color);\r\n    const [r2, g2, b2] = parseHexColor(cursorBallColor);\r\n\r\n    const metaBallsUniform: Vec3[] = [];\r\n    for (let i = 0; i < 50; i++) {\r\n      metaBallsUniform.push(new Vec3(0, 0, 0));\r\n    }\r\n\r\n    const program = new Program(gl, {\r\n      vertex,\r\n      fragment,\r\n      uniforms: {\r\n        iTime: { value: 0 },\r\n        iResolution: { value: new Vec3(0, 0, 0) },\r\n        iMouse: { value: new Vec3(0, 0, 0) },\r\n        iColor: { value: new Vec3(r1, g1, b1) },\r\n        iCursorColor: { value: new Vec3(r2, g2, b2) },\r\n        iAnimationSize: { value: animationSize },\r\n        iBallCount: { value: ballCount },\r\n        iCursorBallSize: { value: cursorBallSize },\r\n        iMetaBalls: { value: metaBallsUniform },\r\n        iClumpFactor: { value: clumpFactor },\r\n        enableTransparency: { value: enableTransparency }\r\n      }\r\n    });\r\n\r\n    const mesh = new Mesh(gl, { geometry, program });\r\n    const scene = new Transform();\r\n    mesh.setParent(scene);\r\n\r\n    const maxBalls = 50;\r\n    const effectiveBallCount = Math.min(ballCount, maxBalls);\r\n    const ballParams: BallParams[] = [];\r\n    for (let i = 0; i < effectiveBallCount; i++) {\r\n      const idx = i + 1;\r\n      const h1 = hash31(idx);\r\n      const st = h1[0] * (2 * Math.PI);\r\n      const dtFactor = 0.1 * Math.PI + h1[1] * (0.4 * Math.PI - 0.1 * Math.PI);\r\n      const baseScale = 5.0 + h1[1] * (10.0 - 5.0);\r\n      const h2 = hash33(h1);\r\n      const toggle = Math.floor(h2[0] * 2.0);\r\n      const radiusVal = 0.5 + h2[2] * (2.0 - 0.5);\r\n      ballParams.push({ st, dtFactor, baseScale, toggle, radius: radiusVal });\r\n    }\r\n\r\n    const mouseBallPos = { x: 0, y: 0 };\r\n    let pointerInside = false;\r\n    let pointerX = 0;\r\n    let pointerY = 0;\r\n\r\n    function resize() {\r\n      if (!container) return;\r\n      const width = container.clientWidth;\r\n      const height = container.clientHeight;\r\n      renderer.setSize(width * dpr, height * dpr);\r\n      gl.canvas.style.width = `${width}px`;\r\n      gl.canvas.style.height = `${height}px`;\r\n      program.uniforms.iResolution.value.set(gl.canvas.width, gl.canvas.height, 0);\r\n    }\r\n    window.addEventListener('resize', resize);\r\n    resize();\r\n\r\n    function onPointerMove(e: PointerEvent) {\r\n      if (!enableMouseInteraction || !container) return;\r\n      const rect = container.getBoundingClientRect();\r\n      const px = e.clientX - rect.left;\r\n      const py = e.clientY - rect.top;\r\n      pointerX = (px / rect.width) * gl.canvas.width;\r\n      pointerY = (1 - py / rect.height) * gl.canvas.height;\r\n    }\r\n    function onPointerEnter() {\r\n      if (!enableMouseInteraction) return;\r\n      pointerInside = true;\r\n    }\r\n    function onPointerLeave() {\r\n      if (!enableMouseInteraction) return;\r\n      pointerInside = false;\r\n    }\r\n    container.addEventListener('pointermove', onPointerMove);\r\n    container.addEventListener('pointerenter', onPointerEnter);\r\n    container.addEventListener('pointerleave', onPointerLeave);\r\n\r\n    const startTime = performance.now();\r\n    let animationFrameId: number;\r\n    function update(t: number) {\r\n      animationFrameId = requestAnimationFrame(update);\r\n      const elapsed = (t - startTime) * 0.001;\r\n      program.uniforms.iTime.value = elapsed;\r\n\r\n      for (let i = 0; i < effectiveBallCount; i++) {\r\n        const p = ballParams[i];\r\n        const dt = elapsed * speed * p.dtFactor;\r\n        const th = p.st + dt;\r\n        const x = Math.cos(th);\r\n        const y = Math.sin(th + dt * p.toggle);\r\n        const posX = x * p.baseScale * clumpFactor;\r\n        const posY = y * p.baseScale * clumpFactor;\r\n        metaBallsUniform[i].set(posX, posY, p.radius);\r\n      }\r\n\r\n      let targetX: number, targetY: number;\r\n      if (pointerInside) {\r\n        targetX = pointerX;\r\n        targetY = pointerY;\r\n      } else {\r\n        const cx = gl.canvas.width * 0.5;\r\n        const cy = gl.canvas.height * 0.5;\r\n        const rx = gl.canvas.width * 0.15;\r\n        const ry = gl.canvas.height * 0.15;\r\n        targetX = cx + Math.cos(elapsed * speed) * rx;\r\n        targetY = cy + Math.sin(elapsed * speed) * ry;\r\n      }\r\n      mouseBallPos.x += (targetX - mouseBallPos.x) * hoverSmoothness;\r\n      mouseBallPos.y += (targetY - mouseBallPos.y) * hoverSmoothness;\r\n      program.uniforms.iMouse.value.set(mouseBallPos.x, mouseBallPos.y, 0);\r\n\r\n      renderer.render({ scene, camera });\r\n    }\r\n    animationFrameId = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationFrameId);\r\n      window.removeEventListener('resize', resize);\r\n      container.removeEventListener('pointermove', onPointerMove);\r\n      container.removeEventListener('pointerenter', onPointerEnter);\r\n      container.removeEventListener('pointerleave', onPointerLeave);\r\n      container.removeChild(gl.canvas);\r\n      gl.getExtension('WEBGL_lose_context')?.loseContext();\r\n    };\r\n  }, [\r\n    color,\r\n    cursorBallColor,\r\n    speed,\r\n    enableMouseInteraction,\r\n    hoverSmoothness,\r\n    animationSize,\r\n    ballCount,\r\n    clumpFactor,\r\n    cursorBallSize,\r\n    enableTransparency\r\n  ]);\r\n\r\n  return <div ref={containerRef} className=\"metaballs-container\" />;\r\n};\r\n\r\nexport default MetaBalls;\r\n",
      "type": "registry:component"
    },
    {
      "path": "public/ts/default/src/ts-default/Animations/MetaBalls/MetaBalls.css",
      "content": ".metaballs-container {\r\n  position: relative;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n",
      "type": "registry:item"
    }
  ]
}