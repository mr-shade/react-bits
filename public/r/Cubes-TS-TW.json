{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Cubes-TS-TW",
  "type": "registry:block",
  "title": "Cubes",
  "description": "3D rotating cube cluster. Supports auto-rotation or hover interaction.",
  "dependencies": [
    "gsap"
  ],
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Animations/Cubes/Cubes.tsx",
      "content": "import React, { useCallback, useEffect, useRef } from 'react';\r\nimport gsap from 'gsap';\r\n\r\ninterface Gap {\r\n  row: number;\r\n  col: number;\r\n}\r\ninterface Duration {\r\n  enter: number;\r\n  leave: number;\r\n}\r\n\r\nexport interface CubesProps {\r\n  gridSize?: number;\r\n  cubeSize?: number;\r\n  maxAngle?: number;\r\n  radius?: number;\r\n  easing?: gsap.EaseString;\r\n  duration?: Duration;\r\n  cellGap?: number | Gap;\r\n  borderStyle?: string;\r\n  faceColor?: string;\r\n  shadow?: boolean | string;\r\n  autoAnimate?: boolean;\r\n  rippleOnClick?: boolean;\r\n  rippleColor?: string;\r\n  rippleSpeed?: number;\r\n}\r\n\r\nconst Cubes: React.FC<CubesProps> = ({\r\n  gridSize = 10,\r\n  cubeSize,\r\n  maxAngle = 45,\r\n  radius = 3,\r\n  easing = 'power3.out',\r\n  duration = { enter: 0.3, leave: 0.6 },\r\n  cellGap,\r\n  borderStyle = '1px solid #fff',\r\n  faceColor = '#060010',\r\n  shadow = false,\r\n  autoAnimate = true,\r\n  rippleOnClick = true,\r\n  rippleColor = '#fff',\r\n  rippleSpeed = 2\r\n}) => {\r\n  const sceneRef = useRef<HTMLDivElement | null>(null);\r\n  const rafRef = useRef<number | null>(null);\r\n  const idleTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const userActiveRef = useRef(false);\r\n  const simPosRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\r\n  const simTargetRef = useRef<{ x: number; y: number }>({ x: 0, y: 0 });\r\n  const simRAFRef = useRef<number | null>(null);\r\n\r\n  const colGap =\r\n    typeof cellGap === 'number'\r\n      ? `${cellGap}px`\r\n      : (cellGap as Gap)?.col !== undefined\r\n        ? `${(cellGap as Gap).col}px`\r\n        : '5%';\r\n  const rowGap =\r\n    typeof cellGap === 'number'\r\n      ? `${cellGap}px`\r\n      : (cellGap as Gap)?.row !== undefined\r\n        ? `${(cellGap as Gap).row}px`\r\n        : '5%';\r\n\r\n  const enterDur = duration.enter;\r\n  const leaveDur = duration.leave;\r\n\r\n  const tiltAt = useCallback(\r\n    (rowCenter: number, colCenter: number) => {\r\n      if (!sceneRef.current) return;\r\n      sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube => {\r\n        const r = +cube.dataset.row!;\r\n        const c = +cube.dataset.col!;\r\n        const dist = Math.hypot(r - rowCenter, c - colCenter);\r\n        if (dist <= radius) {\r\n          const pct = 1 - dist / radius;\r\n          const angle = pct * maxAngle;\r\n          gsap.to(cube, {\r\n            duration: enterDur,\r\n            ease: easing,\r\n            overwrite: true,\r\n            rotateX: -angle,\r\n            rotateY: angle\r\n          });\r\n        } else {\r\n          gsap.to(cube, {\r\n            duration: leaveDur,\r\n            ease: 'power3.out',\r\n            overwrite: true,\r\n            rotateX: 0,\r\n            rotateY: 0\r\n          });\r\n        }\r\n      });\r\n    },\r\n    [radius, maxAngle, enterDur, leaveDur, easing]\r\n  );\r\n\r\n  const onPointerMove = useCallback(\r\n    (e: PointerEvent) => {\r\n      userActiveRef.current = true;\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n\r\n      const rect = sceneRef.current!.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n      const colCenter = (e.clientX - rect.left) / cellW;\r\n      const rowCenter = (e.clientY - rect.top) / cellH;\r\n\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\r\n\r\n      idleTimerRef.current = setTimeout(() => {\r\n        userActiveRef.current = false;\r\n      }, 3000);\r\n    },\r\n    [gridSize, tiltAt]\r\n  );\r\n\r\n  const resetAll = useCallback(() => {\r\n    if (!sceneRef.current) return;\r\n    sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube =>\r\n      gsap.to(cube, {\r\n        duration: leaveDur,\r\n        rotateX: 0,\r\n        rotateY: 0,\r\n        ease: 'power3.out'\r\n      })\r\n    );\r\n  }, [leaveDur]);\r\n\r\n  const onTouchMove = useCallback(\r\n    (e: TouchEvent) => {\r\n      e.preventDefault();\r\n      userActiveRef.current = true;\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n\r\n      const rect = sceneRef.current!.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n\r\n      const touch = e.touches[0];\r\n      const colCenter = (touch.clientX - rect.left) / cellW;\r\n      const rowCenter = (touch.clientY - rect.top) / cellH;\r\n\r\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\r\n      rafRef.current = requestAnimationFrame(() => tiltAt(rowCenter, colCenter));\r\n\r\n      idleTimerRef.current = setTimeout(() => {\r\n        userActiveRef.current = false;\r\n      }, 3000);\r\n    },\r\n    [gridSize, tiltAt]\r\n  );\r\n\r\n  const onTouchStart = useCallback(() => {\r\n    userActiveRef.current = true;\r\n  }, []);\r\n\r\n  const onTouchEnd = useCallback(() => {\r\n    if (!sceneRef.current) return;\r\n    resetAll();\r\n  }, [resetAll]);\r\n\r\n  const onClick = useCallback(\r\n    (e: MouseEvent | TouchEvent) => {\r\n      if (!rippleOnClick || !sceneRef.current) return;\r\n      const rect = sceneRef.current.getBoundingClientRect();\r\n      const cellW = rect.width / gridSize;\r\n      const cellH = rect.height / gridSize;\r\n\r\n      const clientX = (e as MouseEvent).clientX || ((e as TouchEvent).touches && (e as TouchEvent).touches[0].clientX);\r\n      const clientY = (e as MouseEvent).clientY || ((e as TouchEvent).touches && (e as TouchEvent).touches[0].clientY);\r\n\r\n      const colHit = Math.floor((clientX - rect.left) / cellW);\r\n      const rowHit = Math.floor((clientY - rect.top) / cellH);\r\n\r\n      const baseRingDelay = 0.15;\r\n      const baseAnimDur = 0.3;\r\n      const baseHold = 0.6;\r\n\r\n      const spreadDelay = baseRingDelay / rippleSpeed;\r\n      const animDuration = baseAnimDur / rippleSpeed;\r\n      const holdTime = baseHold / rippleSpeed;\r\n\r\n      const rings: Record<number, HTMLDivElement[]> = {};\r\n      sceneRef.current.querySelectorAll<HTMLDivElement>('.cube').forEach(cube => {\r\n        const r = +cube.dataset.row!;\r\n        const c = +cube.dataset.col!;\r\n        const dist = Math.hypot(r - rowHit, c - colHit);\r\n        const ring = Math.round(dist);\r\n        if (!rings[ring]) rings[ring] = [];\r\n        rings[ring].push(cube);\r\n      });\r\n\r\n      Object.keys(rings)\r\n        .map(Number)\r\n        .sort((a, b) => a - b)\r\n        .forEach(ring => {\r\n          const delay = ring * spreadDelay;\r\n          const faces = rings[ring].flatMap(cube => Array.from(cube.querySelectorAll<HTMLElement>('.cube-face')));\r\n\r\n          gsap.to(faces, {\r\n            backgroundColor: rippleColor,\r\n            duration: animDuration,\r\n            delay,\r\n            ease: 'power3.out'\r\n          });\r\n          gsap.to(faces, {\r\n            backgroundColor: faceColor,\r\n            duration: animDuration,\r\n            delay: delay + animDuration + holdTime,\r\n            ease: 'power3.out'\r\n          });\r\n        });\r\n    },\r\n    [rippleOnClick, gridSize, faceColor, rippleColor, rippleSpeed]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!autoAnimate || !sceneRef.current) return;\r\n    simPosRef.current = {\r\n      x: Math.random() * gridSize,\r\n      y: Math.random() * gridSize\r\n    };\r\n    simTargetRef.current = {\r\n      x: Math.random() * gridSize,\r\n      y: Math.random() * gridSize\r\n    };\r\n    const speed = 0.02;\r\n    const loop = () => {\r\n      if (!userActiveRef.current) {\r\n        const pos = simPosRef.current;\r\n        const tgt = simTargetRef.current;\r\n        pos.x += (tgt.x - pos.x) * speed;\r\n        pos.y += (tgt.y - pos.y) * speed;\r\n        tiltAt(pos.y, pos.x);\r\n        if (Math.hypot(pos.x - tgt.x, pos.y - tgt.y) < 0.1) {\r\n          simTargetRef.current = {\r\n            x: Math.random() * gridSize,\r\n            y: Math.random() * gridSize\r\n          };\r\n        }\r\n      }\r\n      simRAFRef.current = requestAnimationFrame(loop);\r\n    };\r\n    simRAFRef.current = requestAnimationFrame(loop);\r\n    return () => {\r\n      if (simRAFRef.current != null) cancelAnimationFrame(simRAFRef.current);\r\n    };\r\n  }, [autoAnimate, gridSize, tiltAt]);\r\n\r\n  useEffect(() => {\r\n    const el = sceneRef.current;\r\n    if (!el) return;\r\n    el.addEventListener('pointermove', onPointerMove);\r\n    el.addEventListener('pointerleave', resetAll);\r\n    el.addEventListener('click', onClick);\r\n\r\n    el.addEventListener('touchmove', onTouchMove, { passive: false });\r\n    el.addEventListener('touchstart', onTouchStart, { passive: true });\r\n    el.addEventListener('touchend', onTouchEnd, { passive: true });\r\n\r\n    return () => {\r\n      el.removeEventListener('pointermove', onPointerMove);\r\n      el.removeEventListener('pointerleave', resetAll);\r\n      el.removeEventListener('click', onClick);\r\n\r\n      el.removeEventListener('touchmove', onTouchMove);\r\n      el.removeEventListener('touchstart', onTouchStart);\r\n      el.removeEventListener('touchend', onTouchEnd);\r\n\r\n      if (rafRef.current != null) cancelAnimationFrame(rafRef.current);\r\n      if (idleTimerRef.current) clearTimeout(idleTimerRef.current);\r\n    };\r\n  }, [onPointerMove, resetAll, onClick, onTouchMove, onTouchStart, onTouchEnd]);\r\n\r\n  const cells = Array.from({ length: gridSize });\r\n  const sceneStyle: React.CSSProperties = {\r\n    gridTemplateColumns: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\r\n    gridTemplateRows: cubeSize ? `repeat(${gridSize}, ${cubeSize}px)` : `repeat(${gridSize}, 1fr)`,\r\n    columnGap: colGap,\r\n    rowGap: rowGap,\r\n    perspective: '99999999px',\r\n    gridAutoRows: '1fr'\r\n  };\r\n  const wrapperStyle = {\r\n    '--cube-face-border': borderStyle,\r\n    '--cube-face-bg': faceColor,\r\n    '--cube-face-shadow': shadow === true ? '0 0 6px rgba(0,0,0,.5)' : shadow || 'none',\r\n    ...(cubeSize\r\n      ? {\r\n          width: `${gridSize * cubeSize}px`,\r\n          height: `${gridSize * cubeSize}px`\r\n        }\r\n      : {})\r\n  } as React.CSSProperties;\r\n\r\n  return (\r\n    <div className=\"relative w-1/2 max-md:w-11/12 aspect-square\" style={wrapperStyle}>\r\n      <div ref={sceneRef} className=\"grid w-full h-full\" style={sceneStyle}>\r\n        {cells.map((_, r) =>\r\n          cells.map((__, c) => (\r\n            <div\r\n              key={`${r}-${c}`}\r\n              className=\"cube relative w-full h-full aspect-square [transform-style:preserve-3d]\"\r\n              data-row={r}\r\n              data-col={c}\r\n            >\r\n              <span className=\"absolute pointer-events-none -inset-9\" />\r\n\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'translateY(-50%) rotateX(90deg)'\r\n                }}\r\n              />\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'translateY(50%) rotateX(-90deg)'\r\n                }}\r\n              />\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'translateX(-50%) rotateY(-90deg)'\r\n                }}\r\n              />\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'translateX(50%) rotateY(90deg)'\r\n                }}\r\n              />\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'rotateY(-90deg) translateX(50%) rotateY(90deg)'\r\n                }}\r\n              />\r\n              <div\r\n                className=\"cube-face absolute inset-0 flex items-center justify-center\"\r\n                style={{\r\n                  background: 'var(--cube-face-bg)',\r\n                  border: 'var(--cube-face-border)',\r\n                  boxShadow: 'var(--cube-face-shadow)',\r\n                  transform: 'rotateY(90deg) translateX(-50%) rotateY(-90deg)'\r\n                }}\r\n              />\r\n            </div>\r\n          ))\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Cubes;\r\n",
      "type": "registry:component"
    }
  ]
}