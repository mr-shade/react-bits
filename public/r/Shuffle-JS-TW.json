{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Shuffle-JS-TW",
  "type": "registry:block",
  "title": "Shuffle",
  "description": "Animated text reveal where characters shuffle before settling.",
  "dependencies": [
    "@gsap/react",
    "gsap"
  ],
  "files": [
    {
      "path": "public/tailwind/src/tailwind/TextAnimations/Shuffle/Shuffle.jsx",
      "content": "import React, { useRef, useEffect, useState } from 'react';\r\nimport { gsap } from 'gsap';\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger';\r\nimport { SplitText as GSAPSplitText } from 'gsap/SplitText';\r\nimport { useGSAP } from '@gsap/react';\r\n\r\ngsap.registerPlugin(ScrollTrigger, GSAPSplitText, useGSAP);\r\n\r\nconst Shuffle = ({\r\n  text,\r\n  className = '',\r\n  style = {},\r\n  shuffleDirection = 'right',\r\n  duration = 0.35,\r\n  maxDelay = 0,\r\n  ease = 'power3.out',\r\n  threshold = 0.1,\r\n  rootMargin = '-100px',\r\n  tag = 'p',\r\n  textAlign = 'center',\r\n  onShuffleComplete,\r\n  shuffleTimes = 1,\r\n  animationMode = 'evenodd',\r\n  loop = false,\r\n  loopDelay = 0,\r\n  stagger = 0.03,\r\n  scrambleCharset = '',\r\n  colorFrom,\r\n  colorTo,\r\n  triggerOnce = true,\r\n  respectReducedMotion = true,\r\n  triggerOnHover = true\r\n}) => {\r\n  const ref = useRef(null);\r\n  const [fontsLoaded, setFontsLoaded] = useState(false);\r\n  const [ready, setReady] = useState(false);\r\n\r\n  const splitRef = useRef(null);\r\n  const wrappersRef = useRef([]);\r\n  const tlRef = useRef(null);\r\n  const playingRef = useRef(false);\r\n  const hoverHandlerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if ('fonts' in document) {\r\n      if (document.fonts.status === 'loaded') setFontsLoaded(true);\r\n      else document.fonts.ready.then(() => setFontsLoaded(true));\r\n    } else setFontsLoaded(true);\r\n  }, []);\r\n\r\n  useGSAP(\r\n    () => {\r\n      if (!ref.current || !text || !fontsLoaded) return;\r\n      if (respectReducedMotion && window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\r\n        onShuffleComplete?.();\r\n        return;\r\n      }\r\n\r\n      const el = ref.current;\r\n\r\n      const startPct = (1 - threshold) * 100;\r\n      const mm = /^(-?\\d+(?:\\.\\d+)?)(px|em|rem|%)?$/.exec(rootMargin || '');\r\n      const mv = mm ? parseFloat(mm[1]) : 0;\r\n      const mu = mm ? mm[2] || 'px' : 'px';\r\n      const sign = mv === 0 ? '' : mv < 0 ? `-=${Math.abs(mv)}${mu}` : `+=${mv}${mu}`;\r\n      const start = `top ${startPct}%${sign}`;\r\n\r\n      const removeHover = () => {\r\n        if (hoverHandlerRef.current && ref.current) {\r\n          ref.current.removeEventListener('mouseenter', hoverHandlerRef.current);\r\n          hoverHandlerRef.current = null;\r\n        }\r\n      };\r\n\r\n      const teardown = () => {\r\n        if (tlRef.current) {\r\n          tlRef.current.kill();\r\n          tlRef.current = null;\r\n        }\r\n        if (wrappersRef.current.length) {\r\n          wrappersRef.current.forEach(wrap => {\r\n            const inner = wrap.firstElementChild;\r\n            const orig = inner?.querySelector('[data-orig=\"1\"]');\r\n            if (orig && wrap.parentNode) wrap.parentNode.replaceChild(orig, wrap);\r\n          });\r\n          wrappersRef.current = [];\r\n        }\r\n        try {\r\n          splitRef.current?.revert();\r\n        } catch {\r\n          /* noop */\r\n        }\r\n        splitRef.current = null;\r\n        playingRef.current = false;\r\n      };\r\n\r\n      const build = () => {\r\n        teardown();\r\n\r\n        splitRef.current = new GSAPSplitText(el, {\r\n          type: 'chars',\r\n          charsClass: 'shuffle-char',\r\n          wordsClass: 'shuffle-word',\r\n          linesClass: 'shuffle-line',\r\n          smartWrap: true,\r\n          reduceWhiteSpace: false\r\n        });\r\n\r\n        const chars = splitRef.current.chars || [];\r\n        wrappersRef.current = [];\r\n\r\n        const rolls = Math.max(1, Math.floor(shuffleTimes));\r\n        const rand = set => set.charAt(Math.floor(Math.random() * set.length)) || '';\r\n\r\n        chars.forEach(ch => {\r\n          const parent = ch.parentElement;\r\n          if (!parent) return;\r\n\r\n          const w = ch.getBoundingClientRect().width;\r\n          if (!w) return;\r\n\r\n          const wrap = document.createElement('span');\r\n          wrap.className = 'inline-block overflow-hidden align-baseline text-left';\r\n          Object.assign(wrap.style, { width: w + 'px' });\r\n\r\n          const inner = document.createElement('span');\r\n          inner.className = 'inline-block whitespace-nowrap will-change-transform origin-left transform-gpu';\r\n\r\n          parent.insertBefore(wrap, ch);\r\n          wrap.appendChild(inner);\r\n\r\n          const firstOrig = ch.cloneNode(true);\r\n          firstOrig.className = 'inline-block text-left';\r\n          Object.assign(firstOrig.style, { width: w + 'px' });\r\n\r\n          ch.setAttribute('data-orig', '1');\r\n          ch.className = 'inline-block text-left';\r\n          Object.assign(ch.style, { width: w + 'px' });\r\n\r\n          inner.appendChild(firstOrig);\r\n          for (let k = 0; k < rolls; k++) {\r\n            const c = ch.cloneNode(true);\r\n            if (scrambleCharset) c.textContent = rand(scrambleCharset);\r\n            c.className = 'inline-block text-left';\r\n            Object.assign(c.style, { width: w + 'px' });\r\n            inner.appendChild(c);\r\n          }\r\n          inner.appendChild(ch);\r\n\r\n          const steps = rolls + 1;\r\n          let startX = 0;\r\n          let finalX = -steps * w;\r\n          if (shuffleDirection === 'right') {\r\n            const firstCopy = inner.firstElementChild;\r\n            const real = inner.lastElementChild;\r\n            if (real) inner.insertBefore(real, inner.firstChild);\r\n            if (firstCopy) inner.appendChild(firstCopy);\r\n            startX = -steps * w;\r\n            finalX = 0;\r\n          }\r\n\r\n          gsap.set(inner, { x: startX, force3D: true });\r\n          if (colorFrom) inner.style.color = colorFrom;\r\n\r\n          inner.setAttribute('data-final-x', String(finalX));\r\n          inner.setAttribute('data-start-x', String(startX));\r\n\r\n          wrappersRef.current.push(wrap);\r\n        });\r\n      };\r\n\r\n      const inners = () => wrappersRef.current.map(w => w.firstElementChild);\r\n\r\n      const randomizeScrambles = () => {\r\n        if (!scrambleCharset) return;\r\n        wrappersRef.current.forEach(w => {\r\n          const strip = w.firstElementChild;\r\n          if (!strip) return;\r\n          const kids = Array.from(strip.children);\r\n          for (let i = 1; i < kids.length - 1; i++) {\r\n            kids[i].textContent = scrambleCharset.charAt(Math.floor(Math.random() * scrambleCharset.length));\r\n          }\r\n        });\r\n      };\r\n\r\n      const cleanupToStill = () => {\r\n        wrappersRef.current.forEach(w => {\r\n          const strip = w.firstElementChild;\r\n          if (!strip) return;\r\n          const real = strip.querySelector('[data-orig=\"1\"]');\r\n          if (!real) return;\r\n          strip.replaceChildren(real);\r\n          strip.style.transform = 'none';\r\n          strip.style.willChange = 'auto';\r\n        });\r\n      };\r\n\r\n      const play = () => {\r\n        const strips = inners();\r\n        if (!strips.length) return;\r\n\r\n        playingRef.current = true;\r\n\r\n        const tl = gsap.timeline({\r\n          smoothChildTiming: true,\r\n          repeat: loop ? -1 : 0,\r\n          repeatDelay: loop ? loopDelay : 0,\r\n          onRepeat: () => {\r\n            if (scrambleCharset) randomizeScrambles();\r\n            gsap.set(strips, { x: (i, t) => parseFloat(t.getAttribute('data-start-x') || '0') });\r\n            onShuffleComplete?.();\r\n          },\r\n          onComplete: () => {\r\n            playingRef.current = false;\r\n            if (!loop) {\r\n              cleanupToStill();\r\n              if (colorTo) gsap.set(strips, { color: colorTo });\r\n              onShuffleComplete?.();\r\n              armHover();\r\n            }\r\n          }\r\n        });\r\n\r\n        const addTween = (targets, at) => {\r\n          tl.to(\r\n            targets,\r\n            {\r\n              x: (i, t) => parseFloat(t.getAttribute('data-final-x') || '0'),\r\n              duration,\r\n              ease,\r\n              force3D: true,\r\n              stagger: animationMode === 'evenodd' ? stagger : 0\r\n            },\r\n            at\r\n          );\r\n          if (colorFrom && colorTo) tl.to(targets, { color: colorTo, duration, ease }, at);\r\n        };\r\n\r\n        if (animationMode === 'evenodd') {\r\n          const odd = strips.filter((_, i) => i % 2 === 1);\r\n          const even = strips.filter((_, i) => i % 2 === 0);\r\n          const oddTotal = duration + Math.max(0, odd.length - 1) * stagger;\r\n          const evenStart = odd.length ? oddTotal * 0.7 : 0;\r\n          if (odd.length) addTween(odd, 0);\r\n          if (even.length) addTween(even, evenStart);\r\n        } else {\r\n          strips.forEach(strip => {\r\n            const d = Math.random() * maxDelay;\r\n            tl.to(\r\n              strip,\r\n              {\r\n                x: parseFloat(strip.getAttribute('data-final-x') || '0'),\r\n                duration,\r\n                ease,\r\n                force3D: true\r\n              },\r\n              d\r\n            );\r\n            if (colorFrom && colorTo) tl.fromTo(strip, { color: colorFrom }, { color: colorTo, duration, ease }, d);\r\n          });\r\n        }\r\n\r\n        tlRef.current = tl;\r\n      };\r\n\r\n      const armHover = () => {\r\n        if (!triggerOnHover || !ref.current) return;\r\n        removeHover();\r\n        const handler = () => {\r\n          if (playingRef.current) return;\r\n          build();\r\n          if (scrambleCharset) randomizeScrambles();\r\n          play();\r\n        };\r\n        hoverHandlerRef.current = handler;\r\n        ref.current.addEventListener('mouseenter', handler);\r\n      };\r\n\r\n      const create = () => {\r\n        build();\r\n        if (scrambleCharset) randomizeScrambles();\r\n        play();\r\n        armHover();\r\n        setReady(true);\r\n      };\r\n\r\n      const st = ScrollTrigger.create({\r\n        trigger: el,\r\n        start,\r\n        once: triggerOnce,\r\n        onEnter: create\r\n      });\r\n\r\n      return () => {\r\n        st.kill();\r\n        removeHover();\r\n        teardown();\r\n        setReady(false);\r\n      };\r\n    },\r\n    {\r\n      dependencies: [\r\n        text,\r\n        duration,\r\n        maxDelay,\r\n        ease,\r\n        threshold,\r\n        rootMargin,\r\n        fontsLoaded,\r\n        shuffleDirection,\r\n        shuffleTimes,\r\n        animationMode,\r\n        loop,\r\n        loopDelay,\r\n        stagger,\r\n        scrambleCharset,\r\n        colorFrom,\r\n        colorTo,\r\n        triggerOnce,\r\n        respectReducedMotion,\r\n        triggerOnHover\r\n      ],\r\n      scope: ref\r\n    }\r\n  );\r\n\r\n  const baseTw = 'inline-block whitespace-normal break-words will-change-transform uppercase text-[4rem] leading-none';\r\n  const commonStyle = {\r\n    textAlign,\r\n    fontFamily: `'Press Start 2P', sans-serif`,\r\n    ...style\r\n  };\r\n\r\n  const classes = `${baseTw} ${ready ? 'visible' : 'invisible'} ${className}`.trim();\r\n  const Tag = tag || 'p';\r\n\r\n  return React.createElement(Tag, { ref: ref, className: classes, style: commonStyle }, text);\r\n};\r\n\r\nexport default Shuffle;\r\n",
      "type": "registry:component"
    }
  ]
}