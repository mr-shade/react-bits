{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ModelViewer-TS-CSS",
  "type": "registry:block",
  "title": "ModelViewer",
  "description": "Three.js model viewer with orbit controls and lighting presets.",
  "dependencies": [
    "@react-three/drei",
    "@react-three/fiber",
    "three"
  ],
  "files": [
    {
      "path": "public/ts/default/src/ts-default/Components/ModelViewer/ModelViewer.tsx",
      "content": "import { FC, Suspense, useRef, useLayoutEffect, useEffect, useMemo } from 'react';\r\nimport { Canvas, useFrame, useLoader, useThree, invalidate } from '@react-three/fiber';\r\nimport { OrbitControls, useGLTF, useFBX, useProgress, Html, Environment, ContactShadows } from '@react-three/drei';\r\nimport { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader';\r\nimport * as THREE from 'three';\r\n\r\nexport interface ViewerProps {\r\n  url: string;\r\n  width?: number | string;\r\n  height?: number | string;\r\n  modelXOffset?: number;\r\n  modelYOffset?: number;\r\n  defaultRotationX?: number;\r\n  defaultRotationY?: number;\r\n  defaultZoom?: number;\r\n  minZoomDistance?: number;\r\n  maxZoomDistance?: number;\r\n  enableMouseParallax?: boolean;\r\n  enableManualRotation?: boolean;\r\n  enableHoverRotation?: boolean;\r\n  enableManualZoom?: boolean;\r\n  ambientIntensity?: number;\r\n  keyLightIntensity?: number;\r\n  fillLightIntensity?: number;\r\n  rimLightIntensity?: number;\r\n  environmentPreset?: 'city' | 'sunset' | 'night' | 'dawn' | 'studio' | 'apartment' | 'forest' | 'park' | 'none';\r\n  autoFrame?: boolean;\r\n  placeholderSrc?: string;\r\n  showScreenshotButton?: boolean;\r\n  fadeIn?: boolean;\r\n  autoRotate?: boolean;\r\n  autoRotateSpeed?: number;\r\n  onModelLoaded?: () => void;\r\n}\r\n\r\nconst isTouch = typeof window !== 'undefined' && ('ontouchstart' in window || navigator.maxTouchPoints > 0);\r\nconst deg2rad = (d: number) => (d * Math.PI) / 180;\r\nconst DECIDE = 8; // px before we decide horizontal vs vertical\r\nconst ROTATE_SPEED = 0.005;\r\nconst INERTIA = 0.925;\r\nconst PARALLAX_MAG = 0.05;\r\nconst PARALLAX_EASE = 0.12;\r\nconst HOVER_MAG = deg2rad(6);\r\nconst HOVER_EASE = 0.15;\r\n\r\nconst Loader: FC<{ placeholderSrc?: string }> = ({ placeholderSrc }) => {\r\n  const { progress, active } = useProgress();\r\n  if (!active && placeholderSrc) return null;\r\n  return (\r\n    <Html center>\r\n      {placeholderSrc ? (\r\n        <img src={placeholderSrc} width={128} height={128} style={{ filter: 'blur(8px)', borderRadius: 8 }} />\r\n      ) : (\r\n        `${Math.round(progress)} %`\r\n      )}\r\n    </Html>\r\n  );\r\n};\r\n\r\nconst DesktopControls: FC<{\r\n  pivot: THREE.Vector3;\r\n  min: number;\r\n  max: number;\r\n  zoomEnabled: boolean;\r\n}> = ({ pivot, min, max, zoomEnabled }) => {\r\n  const ref = useRef<any>(null);\r\n  useFrame(() => ref.current?.target.copy(pivot));\r\n  return (\r\n    <OrbitControls\r\n      ref={ref}\r\n      makeDefault\r\n      enablePan={false}\r\n      enableRotate={false}\r\n      enableZoom={zoomEnabled}\r\n      minDistance={min}\r\n      maxDistance={max}\r\n    />\r\n  );\r\n};\r\n\r\ninterface ModelInnerProps {\r\n  url: string;\r\n  xOff: number;\r\n  yOff: number;\r\n  pivot: THREE.Vector3;\r\n  initYaw: number;\r\n  initPitch: number;\r\n  minZoom: number;\r\n  maxZoom: number;\r\n  enableMouseParallax: boolean;\r\n  enableManualRotation: boolean;\r\n  enableHoverRotation: boolean;\r\n  enableManualZoom: boolean;\r\n  autoFrame: boolean;\r\n  fadeIn: boolean;\r\n  autoRotate: boolean;\r\n  autoRotateSpeed: number;\r\n  onLoaded?: () => void;\r\n}\r\n\r\nconst ModelInner: FC<ModelInnerProps> = ({\r\n  url,\r\n  xOff,\r\n  yOff,\r\n  pivot,\r\n  initYaw,\r\n  initPitch,\r\n  minZoom,\r\n  maxZoom,\r\n  enableMouseParallax,\r\n  enableManualRotation,\r\n  enableHoverRotation,\r\n  enableManualZoom,\r\n  autoFrame,\r\n  fadeIn,\r\n  autoRotate,\r\n  autoRotateSpeed,\r\n  onLoaded\r\n}) => {\r\n  const outer = useRef<THREE.Group>(null!);\r\n  const inner = useRef<THREE.Group>(null!);\r\n  const { camera, gl } = useThree();\r\n\r\n  const vel = useRef({ x: 0, y: 0 });\r\n  const tPar = useRef({ x: 0, y: 0 });\r\n  const cPar = useRef({ x: 0, y: 0 });\r\n  const tHov = useRef({ x: 0, y: 0 });\r\n  const cHov = useRef({ x: 0, y: 0 });\r\n\r\n  const ext = useMemo(() => url.split('.').pop()!.toLowerCase(), [url]);\r\n  const content = useMemo<THREE.Object3D | null>(() => {\r\n    if (ext === 'glb' || ext === 'gltf') return useGLTF(url).scene.clone();\r\n    if (ext === 'fbx') return useFBX(url).clone();\r\n    if (ext === 'obj') return useLoader(OBJLoader, url).clone();\r\n    console.error('Unsupported format:', ext);\r\n    return null;\r\n  }, [url, ext]);\r\n\r\n  const pivotW = useRef(new THREE.Vector3());\r\n  useLayoutEffect(() => {\r\n    if (!content) return;\r\n    const g = inner.current;\r\n    g.updateWorldMatrix(true, true);\r\n\r\n    const sphere = new THREE.Box3().setFromObject(g).getBoundingSphere(new THREE.Sphere());\r\n    const s = 1 / (sphere.radius * 2);\r\n    g.position.set(-sphere.center.x, -sphere.center.y, -sphere.center.z);\r\n    g.scale.setScalar(s);\r\n\r\n    g.traverse((o: any) => {\r\n      if (o.isMesh) {\r\n        o.castShadow = true;\r\n        o.receiveShadow = true;\r\n        if (fadeIn) {\r\n          o.material.transparent = true;\r\n          o.material.opacity = 0;\r\n        }\r\n      }\r\n    });\r\n\r\n    g.getWorldPosition(pivotW.current);\r\n    pivot.copy(pivotW.current);\r\n    outer.current.rotation.set(initPitch, initYaw, 0);\r\n\r\n    if (autoFrame && (camera as THREE.PerspectiveCamera).isPerspectiveCamera) {\r\n      const persp = camera as THREE.PerspectiveCamera;\r\n      const fitR = sphere.radius * s;\r\n      const d = (fitR * 1.2) / Math.sin((persp.fov * Math.PI) / 180 / 2);\r\n      persp.position.set(pivotW.current.x, pivotW.current.y, pivotW.current.z + d);\r\n      persp.near = d / 10;\r\n      persp.far = d * 10;\r\n      persp.updateProjectionMatrix();\r\n    }\r\n\r\n    /* optional fade-in */\r\n    if (fadeIn) {\r\n      let t = 0;\r\n      const id = setInterval(() => {\r\n        t += 0.05;\r\n        const v = Math.min(t, 1);\r\n        g.traverse((o: any) => {\r\n          if (o.isMesh) o.material.opacity = v;\r\n        });\r\n        invalidate();\r\n        if (v === 1) {\r\n          clearInterval(id);\r\n          onLoaded?.();\r\n        }\r\n      }, 16);\r\n      return () => clearInterval(id);\r\n    } else onLoaded?.();\r\n  }, [content]);\r\n\r\n  useEffect(() => {\r\n    if (!enableManualRotation || isTouch) return;\r\n    const el = gl.domElement;\r\n    let drag = false;\r\n    let lx = 0,\r\n      ly = 0;\r\n    const down = (e: PointerEvent) => {\r\n      if (e.pointerType !== 'mouse' && e.pointerType !== 'pen') return;\r\n      drag = true;\r\n      lx = e.clientX;\r\n      ly = e.clientY;\r\n      window.addEventListener('pointerup', up);\r\n    };\r\n    const move = (e: PointerEvent) => {\r\n      if (!drag) return;\r\n      const dx = e.clientX - lx;\r\n      const dy = e.clientY - ly;\r\n      lx = e.clientX;\r\n      ly = e.clientY;\r\n      outer.current.rotation.y += dx * ROTATE_SPEED;\r\n      outer.current.rotation.x += dy * ROTATE_SPEED;\r\n      vel.current = { x: dx * ROTATE_SPEED, y: dy * ROTATE_SPEED };\r\n      invalidate();\r\n    };\r\n    const up = () => (drag = false);\r\n    el.addEventListener('pointerdown', down);\r\n    el.addEventListener('pointermove', move);\r\n    return () => {\r\n      el.removeEventListener('pointerdown', down);\r\n      el.removeEventListener('pointermove', move);\r\n      window.removeEventListener('pointerup', up);\r\n    };\r\n  }, [gl, enableManualRotation]);\r\n\r\n  useEffect(() => {\r\n    if (!isTouch) return;\r\n    const el = gl.domElement;\r\n    const pts = new Map<number, { x: number; y: number }>();\r\n    type Mode = 'idle' | 'decide' | 'rotate' | 'pinch';\r\n    let mode: Mode = 'idle';\r\n    let sx = 0,\r\n      sy = 0,\r\n      lx = 0,\r\n      ly = 0,\r\n      startDist = 0,\r\n      startZ = 0;\r\n\r\n    const down = (e: PointerEvent) => {\r\n      if (e.pointerType !== 'touch') return;\r\n      pts.set(e.pointerId, { x: e.clientX, y: e.clientY });\r\n      if (pts.size === 1) {\r\n        mode = 'decide';\r\n        sx = lx = e.clientX;\r\n        sy = ly = e.clientY;\r\n      } else if (pts.size === 2 && enableManualZoom) {\r\n        mode = 'pinch';\r\n        const [p1, p2] = [...pts.values()];\r\n        startDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);\r\n        startZ = camera.position.z;\r\n        e.preventDefault();\r\n      }\r\n      invalidate();\r\n    };\r\n\r\n    const move = (e: PointerEvent) => {\r\n      const p = pts.get(e.pointerId);\r\n      if (!p) return;\r\n      p.x = e.clientX;\r\n      p.y = e.clientY;\r\n\r\n      if (mode === 'decide') {\r\n        const dx = e.clientX - sx;\r\n        const dy = e.clientY - sy;\r\n        if (Math.abs(dx) > DECIDE || Math.abs(dy) > DECIDE) {\r\n          if (enableManualRotation && Math.abs(dx) > Math.abs(dy)) {\r\n            mode = 'rotate';\r\n            el.setPointerCapture(e.pointerId);\r\n          } else {\r\n            mode = 'idle';\r\n            pts.clear();\r\n          }\r\n        }\r\n      }\r\n\r\n      if (mode === 'rotate') {\r\n        e.preventDefault();\r\n        const dx = e.clientX - lx;\r\n        const dy = e.clientY - ly;\r\n        lx = e.clientX;\r\n        ly = e.clientY;\r\n        outer.current.rotation.y += dx * ROTATE_SPEED;\r\n        outer.current.rotation.x += dy * ROTATE_SPEED;\r\n        vel.current = { x: dx * ROTATE_SPEED, y: dy * ROTATE_SPEED };\r\n        invalidate();\r\n      } else if (mode === 'pinch' && pts.size === 2) {\r\n        e.preventDefault();\r\n        const [p1, p2] = [...pts.values()];\r\n        const d = Math.hypot(p1.x - p2.x, p1.y - p2.y);\r\n        const ratio = startDist / d;\r\n        camera.position.z = THREE.MathUtils.clamp(startZ * ratio, minZoom, maxZoom);\r\n        invalidate();\r\n      }\r\n    };\r\n\r\n    const up = (e: PointerEvent) => {\r\n      pts.delete(e.pointerId);\r\n      if (mode === 'rotate' && pts.size === 0) mode = 'idle';\r\n      if (mode === 'pinch' && pts.size < 2) mode = 'idle';\r\n    };\r\n\r\n    el.addEventListener('pointerdown', down, { passive: true });\r\n    window.addEventListener('pointermove', move, { passive: false });\r\n    window.addEventListener('pointerup', up, { passive: true });\r\n    window.addEventListener('pointercancel', up, { passive: true });\r\n    return () => {\r\n      el.removeEventListener('pointerdown', down);\r\n      window.removeEventListener('pointermove', move);\r\n      window.removeEventListener('pointerup', up);\r\n      window.removeEventListener('pointercancel', up);\r\n    };\r\n  }, [gl, enableManualRotation, enableManualZoom, minZoom, maxZoom]);\r\n\r\n  useEffect(() => {\r\n    if (isTouch) return;\r\n    const mm = (e: PointerEvent) => {\r\n      if (e.pointerType !== 'mouse') return;\r\n      const nx = (e.clientX / window.innerWidth) * 2 - 1;\r\n      const ny = (e.clientY / window.innerHeight) * 2 - 1;\r\n      if (enableMouseParallax) tPar.current = { x: -nx * PARALLAX_MAG, y: -ny * PARALLAX_MAG };\r\n      if (enableHoverRotation) tHov.current = { x: ny * HOVER_MAG, y: nx * HOVER_MAG };\r\n      invalidate();\r\n    };\r\n    window.addEventListener('pointermove', mm);\r\n    return () => window.removeEventListener('pointermove', mm);\r\n  }, [enableMouseParallax, enableHoverRotation]);\r\n\r\n  useFrame((_, dt) => {\r\n    let need = false;\r\n    cPar.current.x += (tPar.current.x - cPar.current.x) * PARALLAX_EASE;\r\n    cPar.current.y += (tPar.current.y - cPar.current.y) * PARALLAX_EASE;\r\n    const phx = cHov.current.x,\r\n      phy = cHov.current.y;\r\n    cHov.current.x += (tHov.current.x - cHov.current.x) * HOVER_EASE;\r\n    cHov.current.y += (tHov.current.y - cHov.current.y) * HOVER_EASE;\r\n\r\n    const ndc = pivotW.current.clone().project(camera);\r\n    ndc.x += xOff + cPar.current.x;\r\n    ndc.y += yOff + cPar.current.y;\r\n    outer.current.position.copy(ndc.unproject(camera));\r\n\r\n    outer.current.rotation.x += cHov.current.x - phx;\r\n    outer.current.rotation.y += cHov.current.y - phy;\r\n\r\n    if (autoRotate) {\r\n      outer.current.rotation.y += autoRotateSpeed * dt;\r\n      need = true;\r\n    }\r\n\r\n    outer.current.rotation.y += vel.current.x;\r\n    outer.current.rotation.x += vel.current.y;\r\n    vel.current.x *= INERTIA;\r\n    vel.current.y *= INERTIA;\r\n    if (Math.abs(vel.current.x) > 1e-4 || Math.abs(vel.current.y) > 1e-4) need = true;\r\n\r\n    if (\r\n      Math.abs(cPar.current.x - tPar.current.x) > 1e-4 ||\r\n      Math.abs(cPar.current.y - tPar.current.y) > 1e-4 ||\r\n      Math.abs(cHov.current.x - tHov.current.x) > 1e-4 ||\r\n      Math.abs(cHov.current.y - tHov.current.y) > 1e-4\r\n    )\r\n      need = true;\r\n\r\n    if (need) invalidate();\r\n  });\r\n\r\n  if (!content) return null;\r\n  return (\r\n    <group ref={outer}>\r\n      <group ref={inner}>\r\n        <primitive object={content} />\r\n      </group>\r\n    </group>\r\n  );\r\n};\r\n\r\nconst ModelViewer: FC<ViewerProps> = ({\r\n  url,\r\n  width = 400,\r\n  height = 400,\r\n  modelXOffset = 0,\r\n  modelYOffset = 0,\r\n  defaultRotationX = -50,\r\n  defaultRotationY = 20,\r\n  defaultZoom = 0.5,\r\n  minZoomDistance = 0.5,\r\n  maxZoomDistance = 10,\r\n  enableMouseParallax = true,\r\n  enableManualRotation = true,\r\n  enableHoverRotation = true,\r\n  enableManualZoom = true,\r\n  ambientIntensity = 0.3,\r\n  keyLightIntensity = 1,\r\n  fillLightIntensity = 0.5,\r\n  rimLightIntensity = 0.8,\r\n  environmentPreset = 'forest',\r\n  autoFrame = false,\r\n  placeholderSrc,\r\n  showScreenshotButton = true,\r\n  fadeIn = false,\r\n  autoRotate = false,\r\n  autoRotateSpeed = 0.35,\r\n  onModelLoaded\r\n}) => {\r\n  useEffect(() => void useGLTF.preload(url), [url]);\r\n  const pivot = useRef(new THREE.Vector3()).current;\r\n  const contactRef = useRef<THREE.Mesh>(null);\r\n  const rendererRef = useRef<THREE.WebGLRenderer>(null);\r\n  const sceneRef = useRef<THREE.Scene>(null);\r\n  const cameraRef = useRef<THREE.Camera>(null);\r\n\r\n  const initYaw = deg2rad(defaultRotationX);\r\n  const initPitch = deg2rad(defaultRotationY);\r\n  const camZ = Math.min(Math.max(defaultZoom, minZoomDistance), maxZoomDistance);\r\n\r\n  const capture = () => {\r\n    const g = rendererRef.current,\r\n      s = sceneRef.current,\r\n      c = cameraRef.current;\r\n    if (!g || !s || !c) return;\r\n    g.shadowMap.enabled = false;\r\n    const tmp: { l: THREE.Light; cast: boolean }[] = [];\r\n    s.traverse((o: any) => {\r\n      if (o.isLight && 'castShadow' in o) {\r\n        tmp.push({ l: o, cast: o.castShadow });\r\n        o.castShadow = false;\r\n      }\r\n    });\r\n    if (contactRef.current) contactRef.current.visible = false;\r\n    g.render(s, c);\r\n    const urlPNG = g.domElement.toDataURL('image/png');\r\n    const a = document.createElement('a');\r\n    a.download = 'model.png';\r\n    a.href = urlPNG;\r\n    a.click();\r\n    g.shadowMap.enabled = true;\r\n    tmp.forEach(({ l, cast }) => (l.castShadow = cast));\r\n    if (contactRef.current) contactRef.current.visible = true;\r\n    invalidate();\r\n  };\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        width,\r\n        height,\r\n        position: 'relative',\r\n        touchAction: 'pan-y pinch-zoom'\r\n      }}\r\n    >\r\n      {showScreenshotButton && (\r\n        <button\r\n          onClick={capture}\r\n          style={{\r\n            position: 'absolute',\r\n            border: '1px solid #fff',\r\n            right: 16,\r\n            top: 16,\r\n            zIndex: 10,\r\n            cursor: 'pointer',\r\n            padding: '8px 16px',\r\n            borderRadius: 10\r\n          }}\r\n        >\r\n          Take Screenshot\r\n        </button>\r\n      )}\r\n\r\n      <Canvas\r\n        shadows\r\n        frameloop=\"demand\"\r\n        gl={{ preserveDrawingBuffer: true }}\r\n        onCreated={({ gl, scene, camera }) => {\r\n          rendererRef.current = gl;\r\n          sceneRef.current = scene;\r\n          cameraRef.current = camera;\r\n          gl.toneMapping = THREE.ACESFilmicToneMapping;\r\n          gl.outputColorSpace = THREE.SRGBColorSpace;\r\n        }}\r\n        camera={{ fov: 50, position: [0, 0, camZ], near: 0.01, far: 100 }}\r\n        style={{ touchAction: 'pan-y pinch-zoom' }}\r\n      >\r\n        {environmentPreset !== 'none' && <Environment preset={environmentPreset as any} background={false} />}\r\n\r\n        <ambientLight intensity={ambientIntensity} />\r\n        <directionalLight position={[5, 5, 5]} intensity={keyLightIntensity} castShadow />\r\n        <directionalLight position={[-5, 2, 5]} intensity={fillLightIntensity} />\r\n        <directionalLight position={[0, 4, -5]} intensity={rimLightIntensity} />\r\n\r\n        <ContactShadows ref={contactRef as any} position={[0, -0.5, 0]} opacity={0.35} scale={10} blur={2} />\r\n\r\n        <Suspense fallback={<Loader placeholderSrc={placeholderSrc} />}>\r\n          <ModelInner\r\n            url={url}\r\n            xOff={modelXOffset}\r\n            yOff={modelYOffset}\r\n            pivot={pivot}\r\n            initYaw={initYaw}\r\n            initPitch={initPitch}\r\n            minZoom={minZoomDistance}\r\n            maxZoom={maxZoomDistance}\r\n            enableMouseParallax={enableMouseParallax}\r\n            enableManualRotation={enableManualRotation}\r\n            enableHoverRotation={enableHoverRotation}\r\n            enableManualZoom={enableManualZoom}\r\n            autoFrame={autoFrame}\r\n            fadeIn={fadeIn}\r\n            autoRotate={autoRotate}\r\n            autoRotateSpeed={autoRotateSpeed}\r\n            onLoaded={onModelLoaded}\r\n          />\r\n        </Suspense>\r\n\r\n        {!isTouch && (\r\n          <DesktopControls pivot={pivot} min={minZoomDistance} max={maxZoomDistance} zoomEnabled={enableManualZoom} />\r\n        )}\r\n      </Canvas>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ModelViewer;\r\n",
      "type": "registry:component"
    }
  ]
}