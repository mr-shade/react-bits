{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "Lightning-TS-TW",
  "type": "registry:block",
  "title": "Lightning",
  "description": "Procedural lightning bolts with branching and glow flicker.",
  "files": [
    {
      "path": "public/ts/tailwind/src/ts-tailwind/Backgrounds/Lightning/Lightning.tsx",
      "content": "import React, { useRef, useEffect } from 'react';\r\n\r\ninterface LightningProps {\r\n  hue?: number;\r\n  xOffset?: number;\r\n  speed?: number;\r\n  intensity?: number;\r\n  size?: number;\r\n}\r\n\r\nconst Lightning: React.FC<LightningProps> = ({ hue = 230, xOffset = 0, speed = 1, intensity = 1, size = 1 }) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const resizeCanvas = () => {\r\n      canvas.width = canvas.clientWidth;\r\n      canvas.height = canvas.clientHeight;\r\n    };\r\n    resizeCanvas();\r\n    window.addEventListener('resize', resizeCanvas);\r\n\r\n    const gl = canvas.getContext('webgl');\r\n    if (!gl) {\r\n      console.error('WebGL not supported');\r\n      return;\r\n    }\r\n\r\n    const vertexShaderSource = `\r\n      attribute vec2 aPosition;\r\n      void main() {\r\n        gl_Position = vec4(aPosition, 0.0, 1.0);\r\n      }\r\n    `;\r\n\r\n    const fragmentShaderSource = `\r\n      precision mediump float;\r\n      uniform vec2 iResolution;\r\n      uniform float iTime;\r\n      uniform float uHue;\r\n      uniform float uXOffset;\r\n      uniform float uSpeed;\r\n      uniform float uIntensity;\r\n      uniform float uSize;\r\n      \r\n      #define OCTAVE_COUNT 10\r\n\r\n      vec3 hsv2rgb(vec3 c) {\r\n          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\r\n          return c.z * mix(vec3(1.0), rgb, c.y);\r\n      }\r\n\r\n      float hash11(float p) {\r\n          p = fract(p * .1031);\r\n          p *= p + 33.33;\r\n          p *= p + p;\r\n          return fract(p);\r\n      }\r\n\r\n      float hash12(vec2 p) {\r\n          vec3 p3 = fract(vec3(p.xyx) * .1031);\r\n          p3 += dot(p3, p3.yzx + 33.33);\r\n          return fract((p3.x + p3.y) * p3.z);\r\n      }\r\n\r\n      mat2 rotate2d(float theta) {\r\n          float c = cos(theta);\r\n          float s = sin(theta);\r\n          return mat2(c, -s, s, c);\r\n      }\r\n\r\n      float noise(vec2 p) {\r\n          vec2 ip = floor(p);\r\n          vec2 fp = fract(p);\r\n          float a = hash12(ip);\r\n          float b = hash12(ip + vec2(1.0, 0.0));\r\n          float c = hash12(ip + vec2(0.0, 1.0));\r\n          float d = hash12(ip + vec2(1.0, 1.0));\r\n          \r\n          vec2 t = smoothstep(0.0, 1.0, fp);\r\n          return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\r\n      }\r\n\r\n      float fbm(vec2 p) {\r\n          float value = 0.0;\r\n          float amplitude = 0.5;\r\n          for (int i = 0; i < OCTAVE_COUNT; ++i) {\r\n              value += amplitude * noise(p);\r\n              p *= rotate2d(0.45);\r\n              p *= 2.0;\r\n              amplitude *= 0.5;\r\n          }\r\n          return value;\r\n      }\r\n\r\n      void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\r\n          vec2 uv = fragCoord / iResolution.xy;\r\n          uv = 2.0 * uv - 1.0;\r\n          uv.x *= iResolution.x / iResolution.y;\r\n          uv.x += uXOffset;\r\n          \r\n          uv += 2.0 * fbm(uv * uSize + 0.8 * iTime * uSpeed) - 1.0;\r\n          \r\n          float dist = abs(uv.x);\r\n          vec3 baseColor = hsv2rgb(vec3(uHue / 360.0, 0.7, 0.8));\r\n          vec3 col = baseColor * pow(mix(0.0, 0.07, hash11(iTime * uSpeed)) / dist, 1.0) * uIntensity;\r\n          col = pow(col, vec3(1.0));\r\n          fragColor = vec4(col, 1.0);\r\n      }\r\n\r\n      void main() {\r\n          mainImage(gl_FragColor, gl_FragCoord.xy);\r\n      }\r\n    `;\r\n\r\n    const compileShader = (source: string, type: number): WebGLShader | null => {\r\n      const shader = gl.createShader(type);\r\n      if (!shader) return null;\r\n      gl.shaderSource(shader, source);\r\n      gl.compileShader(shader);\r\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.error('Shader compile error:', gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n      }\r\n      return shader;\r\n    };\r\n\r\n    const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);\r\n    const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\r\n    if (!vertexShader || !fragmentShader) return;\r\n\r\n    const program = gl.createProgram();\r\n    if (!program) return;\r\n    gl.attachShader(program, vertexShader);\r\n    gl.attachShader(program, fragmentShader);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      console.error('Program linking error:', gl.getProgramInfoLog(program));\r\n      return;\r\n    }\r\n    gl.useProgram(program);\r\n\r\n    const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);\r\n    const vertexBuffer = gl.createBuffer();\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\r\n\r\n    const aPosition = gl.getAttribLocation(program, 'aPosition');\r\n    gl.enableVertexAttribArray(aPosition);\r\n    gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);\r\n\r\n    const iResolutionLocation = gl.getUniformLocation(program, 'iResolution');\r\n    const iTimeLocation = gl.getUniformLocation(program, 'iTime');\r\n    const uHueLocation = gl.getUniformLocation(program, 'uHue');\r\n    const uXOffsetLocation = gl.getUniformLocation(program, 'uXOffset');\r\n    const uSpeedLocation = gl.getUniformLocation(program, 'uSpeed');\r\n    const uIntensityLocation = gl.getUniformLocation(program, 'uIntensity');\r\n    const uSizeLocation = gl.getUniformLocation(program, 'uSize');\r\n\r\n    const startTime = performance.now();\r\n    const render = () => {\r\n      resizeCanvas();\r\n      gl.viewport(0, 0, canvas.width, canvas.height);\r\n      gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);\r\n      const currentTime = performance.now();\r\n      gl.uniform1f(iTimeLocation, (currentTime - startTime) / 1000.0);\r\n      gl.uniform1f(uHueLocation, hue);\r\n      gl.uniform1f(uXOffsetLocation, xOffset);\r\n      gl.uniform1f(uSpeedLocation, speed);\r\n      gl.uniform1f(uIntensityLocation, intensity);\r\n      gl.uniform1f(uSizeLocation, size);\r\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n      requestAnimationFrame(render);\r\n    };\r\n    requestAnimationFrame(render);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas);\r\n    };\r\n  }, [hue, xOffset, speed, intensity, size]);\r\n\r\n  return <canvas ref={canvasRef} className=\"w-full h-full relative\" />;\r\n};\r\n\r\nexport default Lightning;\r\n",
      "type": "registry:component"
    }
  ]
}